{"meta":{"title":"旅行的代码","subtitle":"李城的博客","description":"知行合一","author":"李城","url":"https://lchml.com","root":"/"},"pages":[{"title":"","date":"2022-05-12T00:55:13.373Z","updated":"2018-07-19T08:00:44.000Z","comments":true,"path":"404.html","permalink":"https://lchml.com/404.html","excerpt":"","text":""},{"title":"","date":"2022-05-12T00:55:13.372Z","updated":"2022-03-18T07:03:59.000Z","comments":true,"path":"av-min.js","permalink":"https://lchml.com/av-min.js","excerpt":"","text":"!function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define([],e):\"object\"==typeof exports?exports.AV=e():t.AV=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,\"a\",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p=\"\",e(e.s=35)}([function(t,e,n){var r,i;(function(){function n(t){function e(e,n,r,i,s,o){for(;s>=0&&s0?0:a-1;return arguments.length0?0:i-1;s>=0&&s0?o=s>=0?s:Math.max(s+a,o):a=s>=0?Math.min(s+1,a):s+a+1;else if(n&&s&&a)return s=n(r,i),r[s]===i?s:-1;if(i!==i)return s=e(p.call(r,o,a),O.isNaN),s>=0?s+o:-1;for(s=t>0?o:a-1;s>=0&&s"},{"title":"","date":"2022-05-12T00:55:13.378Z","updated":"2018-10-25T08:13:56.000Z","comments":true,"path":"default.css","permalink":"https://lchml.com/default.css","excerpt":"","text":".gitment-container { font-family: sans-serif; font-size: 14px; line-height: 1.5; color: #333; word-wrap: break-word; } .gitment-container * { box-sizing: border-box; } .gitment-container *:disabled { cursor: not-allowed; } .gitment-container a, .gitment-container a:visited { cursor: pointer; text-decoration: none; } .gitment-container a:hover { text-decoration: underline; } .gitment-container .gitment-hidden { display: none; } .gitment-container .gitment-spinner-icon { fill: #333; -webkit-animation: gitment-spin 1s steps(12) infinite; animation: gitment-spin 1s steps(12) infinite; } @-webkit-keyframes gitment-spin { 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg) } } @keyframes gitment-spin { 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg) } } .gitment-root-container { margin: 19px 0; } .gitment-header-container { margin: 19px 0; } .gitment-header-like-btn, .gitment-comment-like-btn { cursor: pointer; } .gitment-comment-like-btn { float: right; } .gitment-comment-like-btn.liked { color: #F44336; } .gitment-header-like-btn svg { vertical-align: middle; height: 30px; } .gitment-comment-like-btn svg { vertical-align: middle; height: 20px; } .gitment-header-like-btn.liked svg, .gitment-comment-like-btn.liked svg { fill: #F44336; } a.gitment-header-issue-link, a.gitment-header-issue-link:visited { float: right; line-height: 30px; color: #666; } a.gitment-header-issue-link:hover { color: #666; } .gitment-comments-loading, .gitment-comments-error, .gitment-comments-empty { text-align: center; margin: 50px 0; } .gitment-comments-list { list-style: none; padding-left: 0; margin: 0 0 38px; } .gitment-comment, .gitment-editor-container { position: relative; min-height: 60px; padding-left: 60px; margin: 19px 0; } .gitment-comment-avatar, .gitment-editor-avatar { float: left; margin-left: -60px; } .gitment-comment-avatar, .gitment-comment-avatar-img, .gitment-comment-avatar, .gitment-editor-avatar-img, .gitment-editor-avatar svg { width: 44px; height: 44px; border-radius: 3px; } .gitment-editor-avatar .gitment-github-icon { fill: #fff; background-color: #333; } .gitment-comment-main, .gitment-editor-main { position: relative; border: 1px solid #CFD8DC; border-radius: 0; } .gitment-editor-main::before, .gitment-editor-main::after, .gitment-comment-main::before, .gitment-comment-main::after { position: absolute; top: 11px; left: -16px; display: block; width: 0; height: 0; pointer-events: none; content: \"\"; border-color: transparent; border-style: solid solid outset; } .gitment-editor-main::before, .gitment-comment-main::before { border-width: 8px; border-right-color: #CFD8DC; } .gitment-editor-main::after, .gitment-comment-main::after { margin-top: 1px; margin-left: 2px; border-width: 7px; border-right-color: #fff; } .gitment-comment-header { margin: 12px 15px; color: #666; background-color: #fff; border-radius: 3px; } .gitment-editor-header { padding: 0; margin: 0; border-bottom: 1px solid #CFD8DC; } a.gitment-comment-name, a.gitment-comment-name:visited { font-weight: 600; color: #666; } .gitment-editor-tabs { margin-bottom: -1px; margin-left: -1px; } .gitment-editor-tab { display: inline-block; padding: 11px 12px; font-size: 14px; line-height: 20px; color: #666; text-decoration: none; background-color: transparent; border-width: 0 1px; border-style: solid; border-color: transparent; border-radius: 0; white-space: nowrap; cursor: pointer; user-select: none; outline: none; } .gitment-editor-tab.gitment-selected { color: #333; background-color: #fff; border-color: #CFD8DC; } .gitment-editor-login { float: right; margin-top: -30px; margin-right: 15px; } a.gitment-footer-project-link, a.gitment-footer-project-link:visited, a.gitment-editor-login-link, a.gitment-editor-login-link:visited { color: #2196F3; } a.gitment-editor-logout-link, a.gitment-editor-logout-link:visited { color: #666; } a.gitment-editor-logout-link:hover { color: #2196F3; text-decoration: none; } .gitment-comment-body { position: relative; margin: 12px 15px; overflow: hidden; border-radius: 3px; } .gitment-comment-body-folded { cursor: pointer; } .gitment-comment-body-folded::before { display: block !important; content: \"\"; position: absolute; width: 100%; left: 0; top: 0; bottom: 50px; pointer-events: none; background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9)); background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9)); } .gitment-comment-body-folded::after { display: block !important; content: \"Click to Expand\" !important; text-align: center; color: #666; position: absolute; width: 100%; height: 50px; line-height: 50px; left: 0; bottom: 0; pointer-events: none; background: rgba(255, 255, 255, .9); } .gitment-editor-body { margin: 0; } .gitment-comment-body > *:first-child, .gitment-editor-preview > *:first-child { margin-top: 0 !important; } .gitment-comment-body > *:last-child, .gitment-editor-preview > *:last-child { margin-bottom: 0 !important; } .gitment-editor-body textarea { display: block; width: 100%; min-height: 150px; max-height: 500px; padding: 16px; resize: vertical; max-width: 100%; margin: 0; font-size: 14px; line-height: 1.6; background-color: #fff; color: #333; vertical-align: middle; border: none; border-radius: 0; outline: none; box-shadow: none; overflow: visible; } .gitment-editor-body textarea:focus { background-color: #fff; } .gitment-editor-preview { min-height: 150px; padding: 16px; background-color: transparent; width: 100%; font-size: 14px; line-height: 1.5; word-wrap: break-word; } .gitment-editor-footer { padding: 0; margin-top: 10px; } .gitment-editor-footer::after { display: table; clear: both; content: \"\"; } a.gitment-editor-footer-tip { display: inline-block; padding-top: 10px; font-size: 12px; color: #666; } a.gitment-editor-footer-tip:hover { color: #2196F3; text-decoration: none; } .gitment-comments-pagination { list-style: none; text-align: right; border-radius: 0; margin: -19px 0 19px 0; } .gitment-comments-page-item { display: inline-block; cursor: pointer; border: 1px solid #CFD8DC; margin-left: -1px; padding: .25rem .5rem; } .gitment-comments-page-item:hover { background-color: #f5f5f5; } .gitment-comments-page-item.gitment-selected { background-color: #f5f5f5; } .gitment-editor-submit, .gitment-comments-init-btn { color: #fff; background-color: #00BCD4; position: relative; display: inline-block; padding: 7px 13px; font-size: 14px; font-weight: 600; line-height: 20px; white-space: nowrap; vertical-align: middle; cursor: pointer; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; background-size: 110% 110%; border: none; -webkit-appearance: none; -moz-appearance: none; appearance: none; } .gitment-editor-submit:hover, .gitment-comments-init-btn:hover { background-color: #00ACC1; } .gitment-comments-init-btn:disabled, .gitment-editor-submit:disabled { color: rgba(255,255,255,0.75); background-color: #4DD0E1; box-shadow: none; } .gitment-editor-submit { float: right; } .gitment-footer-container { margin-top: 30px; margin-bottom: 20px; text-align: right; font-size: 12px; } /* * Markdown CSS * Copied from https://github.com/sindresorhus/github-markdown-css */ .gitment-markdown { -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; line-height: 1.5; color: #333; font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; font-size: 16px; line-height: 1.5; word-wrap: break-word; } .gitment-markdown .pl-c { color: #969896; } .gitment-markdown .pl-c1, .gitment-markdown .pl-s .pl-v { color: #0086b3; } .gitment-markdown .pl-e, .gitment-markdown .pl-en { color: #795da3; } .gitment-markdown .pl-smi, .gitment-markdown .pl-s .pl-s1 { color: #333; } .gitment-markdown .pl-ent { color: #63a35c; } .gitment-markdown .pl-k { color: #a71d5d; } .gitment-markdown .pl-s, .gitment-markdown .pl-pds, .gitment-markdown .pl-s .pl-pse .pl-s1, .gitment-markdown .pl-sr, .gitment-markdown .pl-sr .pl-cce, .gitment-markdown .pl-sr .pl-sre, .gitment-markdown .pl-sr .pl-sra { color: #183691; } .gitment-markdown .pl-v, .gitment-markdown .pl-smw { color: #ed6a43; } .gitment-markdown .pl-bu { color: #b52a1d; } .gitment-markdown .pl-ii { color: #f8f8f8; background-color: #b52a1d; } .gitment-markdown .pl-c2 { color: #f8f8f8; background-color: #b52a1d; } .gitment-markdown .pl-c2::before { content: \"^M\"; } .gitment-markdown .pl-sr .pl-cce { font-weight: bold; color: #63a35c; } .gitment-markdown .pl-ml { color: #693a17; } .gitment-markdown .pl-mh, .gitment-markdown .pl-mh .pl-en, .gitment-markdown .pl-ms { font-weight: bold; color: #1d3e81; } .gitment-markdown .pl-mq { color: #008080; } .gitment-markdown .pl-mi { font-style: italic; color: #333; } .gitment-markdown .pl-mb { font-weight: bold; color: #333; } .gitment-markdown .pl-md { color: #bd2c00; background-color: #ffecec; } .gitment-markdown .pl-mi1 { color: #55a532; background-color: #eaffea; } .gitment-markdown .pl-mc { color: #ef9700; background-color: #ffe3b4; } .gitment-markdown .pl-mi2 { color: #d8d8d8; background-color: #808080; } .gitment-markdown .pl-mdr { font-weight: bold; color: #795da3; } .gitment-markdown .pl-mo { color: #1d3e81; } .gitment-markdown .pl-ba { color: #595e62; } .gitment-markdown .pl-sg { color: #c0c0c0; } .gitment-markdown .pl-corl { text-decoration: underline; color: #183691; } .gitment-markdown .octicon { display: inline-block; vertical-align: text-top; fill: currentColor; } .gitment-markdown a { background-color: transparent; -webkit-text-decoration-skip: objects; } .gitment-markdown a:active, .gitment-markdown a:hover { outline-width: 0; } .gitment-markdown strong { font-weight: inherit; } .gitment-markdown strong { font-weight: bolder; } .gitment-markdown h1 { font-size: 2em; margin: 0.67em 0; } .gitment-markdown img { border-style: none; } .gitment-markdown svg:not(:root) { overflow: hidden; } .gitment-markdown code, .gitment-markdown kbd, .gitment-markdown pre { font-family: monospace, monospace; font-size: 1em; } .gitment-markdown hr { box-sizing: content-box; height: 0; overflow: visible; } .gitment-markdown input { font: inherit; margin: 0; } .gitment-markdown input { overflow: visible; } .gitment-markdown [type=\"checkbox\"] { box-sizing: border-box; padding: 0; } .gitment-markdown * { box-sizing: border-box; } .gitment-markdown input { font-family: inherit; font-size: inherit; line-height: inherit; } .gitment-markdown a { color: #0366d6; text-decoration: none; } .gitment-markdown a:hover { text-decoration: underline; } .gitment-markdown strong { font-weight: 600; } .gitment-markdown hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #dfe2e5; } .gitment-markdown hr::before { display: table; content: \"\"; } .gitment-markdown hr::after { display: table; clear: both; content: \"\"; } .gitment-markdown table { border-spacing: 0; border-collapse: collapse; } .gitment-markdown td, .gitment-markdown th { padding: 0; } .gitment-markdown h1, .gitment-markdown h2, .gitment-markdown h3, .gitment-markdown h4, .gitment-markdown h5, .gitment-markdown h6 { margin-top: 0; margin-bottom: 0; } .gitment-markdown h1 { font-size: 32px; font-weight: 600; } .gitment-markdown h2 { font-size: 24px; font-weight: 600; } .gitment-markdown h3 { font-size: 20px; font-weight: 600; } .gitment-markdown h4 { font-size: 16px; font-weight: 600; } .gitment-markdown h5 { font-size: 14px; font-weight: 600; } .gitment-markdown h6 { font-size: 12px; font-weight: 600; } .gitment-markdown p { margin-top: 0; margin-bottom: 10px; } .gitment-markdown blockquote { margin: 0; } .gitment-markdown ul, .gitment-markdown ol { padding-left: 0; margin-top: 0; margin-bottom: 0; } .gitment-markdown ol ol, .gitment-markdown ul ol { list-style-type: lower-roman; } .gitment-markdown ul ul ol, .gitment-markdown ul ol ol, .gitment-markdown ol ul ol, .gitment-markdown ol ol ol { list-style-type: lower-alpha; } .gitment-markdown dd { margin-left: 0; } .gitment-markdown code { font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; font-size: 12px; } .gitment-markdown pre { margin-top: 0; margin-bottom: 0; font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; } .gitment-markdown .octicon { vertical-align: text-bottom; } .gitment-markdown .pl-0 { padding-left: 0 !important; } .gitment-markdown .pl-1 { padding-left: 4px !important; } .gitment-markdown .pl-2 { padding-left: 8px !important; } .gitment-markdown .pl-3 { padding-left: 16px !important; } .gitment-markdown .pl-4 { padding-left: 24px !important; } .gitment-markdown .pl-5 { padding-left: 32px !important; } .gitment-markdown .pl-6 { padding-left: 40px !important; } .gitment-markdown::before { display: table; content: \"\"; } .gitment-markdown::after { display: table; clear: both; content: \"\"; } .gitment-markdown>*:first-child { margin-top: 0 !important; } .gitment-markdown>*:last-child { margin-bottom: 0 !important; } .gitment-markdown a:not([href]) { color: inherit; text-decoration: none; } .gitment-markdown .anchor { float: left; padding-right: 4px; margin-left: -20px; line-height: 1; } .gitment-markdown .anchor:focus { outline: none; } .gitment-markdown p, .gitment-markdown blockquote, .gitment-markdown ul, .gitment-markdown ol, .gitment-markdown dl, .gitment-markdown table, .gitment-markdown pre { margin-top: 0; margin-bottom: 16px; } .gitment-markdown hr { height: 0.25em; padding: 0; margin: 24px 0; background-color: #e1e4e8; border: 0; } .gitment-markdown blockquote { padding: 0 1em; color: #6a737d; border-left: 0.25em solid #dfe2e5; } .gitment-markdown blockquote>:first-child { margin-top: 0; } .gitment-markdown blockquote>:last-child { margin-bottom: 0; } .gitment-markdown kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: #444d56; vertical-align: middle; background-color: #fafbfc; border: solid 1px #c6cbd1; border-bottom-color: #959da5; border-radius: 0; box-shadow: inset 0 -1px 0 #959da5; } .gitment-markdown h1, .gitment-markdown h2, .gitment-markdown h3, .gitment-markdown h4, .gitment-markdown h5, .gitment-markdown h6 { margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; } .gitment-markdown h1 .octicon-link, .gitment-markdown h2 .octicon-link, .gitment-markdown h3 .octicon-link, .gitment-markdown h4 .octicon-link, .gitment-markdown h5 .octicon-link, .gitment-markdown h6 .octicon-link { color: #1b1f23; vertical-align: middle; visibility: hidden; } .gitment-markdown h1:hover .anchor, .gitment-markdown h2:hover .anchor, .gitment-markdown h3:hover .anchor, .gitment-markdown h4:hover .anchor, .gitment-markdown h5:hover .anchor, .gitment-markdown h6:hover .anchor { text-decoration: none; } .gitment-markdown h1:hover .anchor .octicon-link, .gitment-markdown h2:hover .anchor .octicon-link, .gitment-markdown h3:hover .anchor .octicon-link, .gitment-markdown h4:hover .anchor .octicon-link, .gitment-markdown h5:hover .anchor .octicon-link, .gitment-markdown h6:hover .anchor .octicon-link { visibility: visible; } .gitment-markdown h1 { padding-bottom: 0.3em; font-size: 2em; border-bottom: 1px solid #eaecef; } .gitment-markdown h2 { padding-bottom: 0.3em; font-size: 1.5em; border-bottom: 1px solid #eaecef; } .gitment-markdown h3 { font-size: 1.25em; } .gitment-markdown h4 { font-size: 1em; } .gitment-markdown h5 { font-size: 0.875em; } .gitment-markdown h6 { font-size: 0.85em; color: #6a737d; } .gitment-markdown ul, .gitment-markdown ol { padding-left: 2em; } .gitment-markdown ul ul, .gitment-markdown ul ol, .gitment-markdown ol ol, .gitment-markdown ol ul { margin-top: 0; margin-bottom: 0; } .gitment-markdown li>p { margin-top: 16px; } .gitment-markdown li+li { margin-top: 0.25em; } .gitment-markdown dl { padding: 0; } .gitment-markdown dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: 600; } .gitment-markdown dl dd { padding: 0 16px; margin-bottom: 16px; } .gitment-markdown table { display: block; width: 100%; overflow: auto; } .gitment-markdown table th { font-weight: 600; } .gitment-markdown table th, .gitment-markdown table td { padding: 6px 13px; border: 1px solid #dfe2e5; } .gitment-markdown table tr { background-color: #fff; border-top: 1px solid #c6cbd1; } .gitment-markdown table tr:nth-child(2n) { background-color: #f5f5f5; } .gitment-markdown img { max-width: 100%; box-sizing: content-box; background-color: #fff; } .gitment-markdown code { padding: 0; padding-top: 0.2em; padding-bottom: 0.2em; margin: 0; font-size: 85%; background-color: rgba(27,31,35,0.05); border-radius: 0; } .gitment-markdown code::before, .gitment-markdown code::after { letter-spacing: -0.2em; content: \"\\00a0\"; } .gitment-markdown pre { word-wrap: normal; } .gitment-markdown pre>code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } .gitment-markdown .highlight { margin-bottom: 16px; } .gitment-markdown .highlight pre { margin-bottom: 0; word-break: normal; } .gitment-markdown .highlight pre, .gitment-markdown pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f5f5f5; border-radius: 0; } .gitment-markdown pre code { display: inline; max-width: auto; padding: 0; margin: 0; overflow: visible; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; } .gitment-markdown pre code::before, .gitment-markdown pre code::after { content: normal; } .gitment-markdown .full-commit .btn-outline:not(:disabled):hover { color: #005cc5; border-color: #005cc5; } .gitment-markdown kbd { display: inline-block; padding: 3px 5px; font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; line-height: 10px; color: #444d56; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #c6cbd1; border-bottom-color: #959da5; border-radius: 0; box-shadow: inset 0 -1px 0 #959da5; } .gitment-markdown :checked+.radio-label { position: relative; z-index: 1; border-color: #0366d6; } .gitment-markdown .task-list-item { list-style-type: none; } .gitment-markdown .task-list-item+.task-list-item { margin-top: 3px; } .gitment-markdown .task-list-item input { margin: 0 0.2em 0.25em -1.6em; vertical-align: middle; } .gitment-markdown hr { border-bottom-color: #eee; }"},{"title":"","date":"2022-05-12T00:55:13.376Z","updated":"2018-10-25T09:28:35.000Z","comments":true,"path":"gitment.default.css","permalink":"https://lchml.com/gitment.default.css","excerpt":"","text":".gitment-container { font-family: sans-serif; font-size: 14px; line-height: 1.5; color: #333; word-wrap: break-word; } .gitment-container * { box-sizing: border-box; } .gitment-container *:disabled { cursor: not-allowed; } .gitment-container a, .gitment-container a:visited { cursor: pointer; text-decoration: none; } .gitment-container a:hover { text-decoration: underline; } .gitment-container .gitment-hidden { display: none; } .gitment-container .gitment-spinner-icon { fill: #333; -webkit-animation: gitment-spin 1s steps(12) infinite; animation: gitment-spin 1s steps(12) infinite; } @-webkit-keyframes gitment-spin { 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg) } } @keyframes gitment-spin { 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg) } } .gitment-root-container { margin: 19px 0; } .gitment-header-container { margin: 19px 0; } .gitment-header-like-btn, .gitment-comment-like-btn { cursor: pointer; } .gitment-comment-like-btn { float: right; } .gitment-comment-like-btn.liked { color: #F44336; } .gitment-header-like-btn svg { vertical-align: middle; height: 30px; } .gitment-comment-like-btn svg { vertical-align: middle; height: 20px; } .gitment-header-like-btn.liked svg, .gitment-comment-like-btn.liked svg { fill: #F44336; } a.gitment-header-issue-link, a.gitment-header-issue-link:visited { float: right; line-height: 30px; color: #666; } a.gitment-header-issue-link:hover { color: #666; } .gitment-comments-loading, .gitment-comments-error, .gitment-comments-empty { text-align: center; margin: 50px 0; } .gitment-comments-list { list-style: none; padding-left: 0; margin: 0 0 38px; } .gitment-comment, .gitment-editor-container { position: relative; min-height: 60px; padding-left: 60px; margin: 19px 0; } .gitment-comment-avatar, .gitment-editor-avatar { float: left; margin-left: -60px; } .gitment-comment-avatar, .gitment-comment-avatar-img, .gitment-comment-avatar, .gitment-editor-avatar-img, .gitment-editor-avatar svg { width: 44px; height: 44px; border-radius: 3px; } .gitment-editor-avatar .gitment-github-icon { fill: #fff; background-color: #333; } .gitment-comment-main, .gitment-editor-main { position: relative; border: 1px solid #CFD8DC; border-radius: 0; } .gitment-editor-main::before, .gitment-editor-main::after, .gitment-comment-main::before, .gitment-comment-main::after { position: absolute; top: 11px; left: -16px; display: block; width: 0; height: 0; pointer-events: none; content: \"\"; border-color: transparent; border-style: solid solid outset; } .gitment-editor-main::before, .gitment-comment-main::before { border-width: 8px; border-right-color: #CFD8DC; } .gitment-editor-main::after, .gitment-comment-main::after { margin-top: 1px; margin-left: 2px; border-width: 7px; border-right-color: #fff; } .gitment-comment-header { margin: 12px 15px; color: #666; background-color: #fff; border-radius: 3px; } .gitment-editor-header { padding: 0; margin: 0; border-bottom: 1px solid #CFD8DC; } a.gitment-comment-name, a.gitment-comment-name:visited { font-weight: 600; color: #666; } .gitment-editor-tabs { margin-bottom: -1px; margin-left: -1px; } .gitment-editor-tab { display: inline-block; padding: 11px 12px; font-size: 14px; line-height: 20px; color: #666; text-decoration: none; background-color: transparent; border-width: 0 1px; border-style: solid; border-color: transparent; border-radius: 0; white-space: nowrap; cursor: pointer; user-select: none; outline: none; } .gitment-editor-tab.gitment-selected { color: #333; background-color: #fff; border-color: #CFD8DC; } .gitment-editor-login { float: right; margin-top: -30px; margin-right: 15px; } a.gitment-footer-project-link, a.gitment-footer-project-link:visited, a.gitment-editor-login-link, a.gitment-editor-login-link:visited { color: #2196F3; } a.gitment-editor-logout-link, a.gitment-editor-logout-link:visited { color: #666; } a.gitment-editor-logout-link:hover { color: #2196F3; text-decoration: none; } .gitment-comment-body { position: relative; margin: 12px 15px; overflow: hidden; border-radius: 3px; } .gitment-comment-body-folded { cursor: pointer; } .gitment-comment-body-folded::before { display: block !important; content: \"\"; position: absolute; width: 100%; left: 0; top: 0; bottom: 50px; pointer-events: none; background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9)); background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9)); } .gitment-comment-body-folded::after { display: block !important; content: \"Click to Expand\" !important; text-align: center; color: #666; position: absolute; width: 100%; height: 50px; line-height: 50px; left: 0; bottom: 0; pointer-events: none; background: rgba(255, 255, 255, .9); } .gitment-editor-body { margin: 0; } .gitment-comment-body > *:first-child, .gitment-editor-preview > *:first-child { margin-top: 0 !important; } .gitment-comment-body > *:last-child, .gitment-editor-preview > *:last-child { margin-bottom: 0 !important; } .gitment-editor-body textarea { display: block; width: 100%; min-height: 150px; max-height: 500px; padding: 16px; resize: vertical; max-width: 100%; margin: 0; font-size: 14px; line-height: 1.6; background-color: #fff; color: #333; vertical-align: middle; border: none; border-radius: 0; outline: none; box-shadow: none; overflow: visible; } .gitment-editor-body textarea:focus { background-color: #fff; } .gitment-editor-preview { min-height: 150px; padding: 16px; background-color: transparent; width: 100%; font-size: 14px; line-height: 1.5; word-wrap: break-word; } .gitment-editor-footer { padding: 0; margin-top: 10px; } .gitment-editor-footer::after { display: table; clear: both; content: \"\"; } a.gitment-editor-footer-tip { display: inline-block; padding-top: 10px; font-size: 12px; color: #666; } a.gitment-editor-footer-tip:hover { color: #2196F3; text-decoration: none; } .gitment-comments-pagination { list-style: none; text-align: right; border-radius: 0; margin: -19px 0 19px 0; } .gitment-comments-page-item { display: inline-block; cursor: pointer; border: 1px solid #CFD8DC; margin-left: -1px; padding: .25rem .5rem; } .gitment-comments-page-item:hover { background-color: #f5f5f5; } .gitment-comments-page-item.gitment-selected { background-color: #f5f5f5; } .gitment-editor-submit, .gitment-comments-init-btn { color: #fff; background-color: #00BCD4; position: relative; display: inline-block; padding: 7px 13px; font-size: 14px; font-weight: 600; line-height: 20px; white-space: nowrap; vertical-align: middle; cursor: pointer; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; background-size: 110% 110%; border: none; -webkit-appearance: none; -moz-appearance: none; appearance: none; } .gitment-editor-submit:hover, .gitment-comments-init-btn:hover { background-color: #00ACC1; } .gitment-comments-init-btn:disabled, .gitment-editor-submit:disabled { color: rgba(255,255,255,0.75); background-color: #4DD0E1; box-shadow: none; } .gitment-editor-submit { float: right; } .gitment-footer-container { margin-top: 30px; margin-bottom: 20px; text-align: right; font-size: 12px; } /* * Markdown CSS * Copied from https://github.com/sindresorhus/github-markdown-css */ .gitment-markdown { -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; line-height: 1.5; color: #333; font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; font-size: 16px; line-height: 1.5; word-wrap: break-word; } .gitment-markdown .pl-c { color: #969896; } .gitment-markdown .pl-c1, .gitment-markdown .pl-s .pl-v { color: #0086b3; } .gitment-markdown .pl-e, .gitment-markdown .pl-en { color: #795da3; } .gitment-markdown .pl-smi, .gitment-markdown .pl-s .pl-s1 { color: #333; } .gitment-markdown .pl-ent { color: #63a35c; } .gitment-markdown .pl-k { color: #a71d5d; } .gitment-markdown .pl-s, .gitment-markdown .pl-pds, .gitment-markdown .pl-s .pl-pse .pl-s1, .gitment-markdown .pl-sr, .gitment-markdown .pl-sr .pl-cce, .gitment-markdown .pl-sr .pl-sre, .gitment-markdown .pl-sr .pl-sra { color: #183691; } .gitment-markdown .pl-v, .gitment-markdown .pl-smw { color: #ed6a43; } .gitment-markdown .pl-bu { color: #b52a1d; } .gitment-markdown .pl-ii { color: #f8f8f8; background-color: #b52a1d; } .gitment-markdown .pl-c2 { color: #f8f8f8; background-color: #b52a1d; } .gitment-markdown .pl-c2::before { content: \"^M\"; } .gitment-markdown .pl-sr .pl-cce { font-weight: bold; color: #63a35c; } .gitment-markdown .pl-ml { color: #693a17; } .gitment-markdown .pl-mh, .gitment-markdown .pl-mh .pl-en, .gitment-markdown .pl-ms { font-weight: bold; color: #1d3e81; } .gitment-markdown .pl-mq { color: #008080; } .gitment-markdown .pl-mi { font-style: italic; color: #333; } .gitment-markdown .pl-mb { font-weight: bold; color: #333; } .gitment-markdown .pl-md { color: #bd2c00; background-color: #ffecec; } .gitment-markdown .pl-mi1 { color: #55a532; background-color: #eaffea; } .gitment-markdown .pl-mc { color: #ef9700; background-color: #ffe3b4; } .gitment-markdown .pl-mi2 { color: #d8d8d8; background-color: #808080; } .gitment-markdown .pl-mdr { font-weight: bold; color: #795da3; } .gitment-markdown .pl-mo { color: #1d3e81; } .gitment-markdown .pl-ba { color: #595e62; } .gitment-markdown .pl-sg { color: #c0c0c0; } .gitment-markdown .pl-corl { text-decoration: underline; color: #183691; } .gitment-markdown .octicon { display: inline-block; vertical-align: text-top; fill: currentColor; } .gitment-markdown a { background-color: transparent; -webkit-text-decoration-skip: objects; } .gitment-markdown a:active, .gitment-markdown a:hover { outline-width: 0; } .gitment-markdown strong { font-weight: inherit; } .gitment-markdown strong { font-weight: bolder; } .gitment-markdown h1 { font-size: 2em; margin: 0.67em 0; } .gitment-markdown img { border-style: none; } .gitment-markdown svg:not(:root) { overflow: hidden; } .gitment-markdown code, .gitment-markdown kbd, .gitment-markdown pre { font-family: monospace, monospace; font-size: 1em; } .gitment-markdown hr { box-sizing: content-box; height: 0; overflow: visible; } .gitment-markdown input { font: inherit; margin: 0; } .gitment-markdown input { overflow: visible; } .gitment-markdown [type=\"checkbox\"] { box-sizing: border-box; padding: 0; } .gitment-markdown * { box-sizing: border-box; } .gitment-markdown input { font-family: inherit; font-size: inherit; line-height: inherit; } .gitment-markdown a { color: #0366d6; text-decoration: none; } .gitment-markdown a:hover { text-decoration: underline; } .gitment-markdown strong { font-weight: 600; } .gitment-markdown hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #dfe2e5; } .gitment-markdown hr::before { display: table; content: \"\"; } .gitment-markdown hr::after { display: table; clear: both; content: \"\"; } .gitment-markdown table { border-spacing: 0; border-collapse: collapse; } .gitment-markdown td, .gitment-markdown th { padding: 0; } .gitment-markdown h1, .gitment-markdown h2, .gitment-markdown h3, .gitment-markdown h4, .gitment-markdown h5, .gitment-markdown h6 { margin-top: 0; margin-bottom: 0; } .gitment-markdown h1 { font-size: 32px; font-weight: 600; } .gitment-markdown h2 { font-size: 24px; font-weight: 600; } .gitment-markdown h3 { font-size: 20px; font-weight: 600; } .gitment-markdown h4 { font-size: 16px; font-weight: 600; } .gitment-markdown h5 { font-size: 14px; font-weight: 600; } .gitment-markdown h6 { font-size: 12px; font-weight: 600; } .gitment-markdown p { margin-top: 0; margin-bottom: 10px; } .gitment-markdown blockquote { margin: 0; } .gitment-markdown ul, .gitment-markdown ol { padding-left: 0; margin-top: 0; margin-bottom: 0; } .gitment-markdown ol ol, .gitment-markdown ul ol { list-style-type: lower-roman; } .gitment-markdown ul ul ol, .gitment-markdown ul ol ol, .gitment-markdown ol ul ol, .gitment-markdown ol ol ol { list-style-type: lower-alpha; } .gitment-markdown dd { margin-left: 0; } .gitment-markdown code { font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; font-size: 12px; } .gitment-markdown pre { margin-top: 0; margin-bottom: 0; font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; } .gitment-markdown .octicon { vertical-align: text-bottom; } .gitment-markdown .pl-0 { padding-left: 0 !important; } .gitment-markdown .pl-1 { padding-left: 4px !important; } .gitment-markdown .pl-2 { padding-left: 8px !important; } .gitment-markdown .pl-3 { padding-left: 16px !important; } .gitment-markdown .pl-4 { padding-left: 24px !important; } .gitment-markdown .pl-5 { padding-left: 32px !important; } .gitment-markdown .pl-6 { padding-left: 40px !important; } .gitment-markdown::before { display: table; content: \"\"; } .gitment-markdown::after { display: table; clear: both; content: \"\"; } .gitment-markdown>*:first-child { margin-top: 0 !important; } .gitment-markdown>*:last-child { margin-bottom: 0 !important; } .gitment-markdown a:not([href]) { color: inherit; text-decoration: none; } .gitment-markdown .anchor { float: left; padding-right: 4px; margin-left: -20px; line-height: 1; } .gitment-markdown .anchor:focus { outline: none; } .gitment-markdown p, .gitment-markdown blockquote, .gitment-markdown ul, .gitment-markdown ol, .gitment-markdown dl, .gitment-markdown table, .gitment-markdown pre { margin-top: 0; margin-bottom: 16px; } .gitment-markdown hr { height: 0.25em; padding: 0; margin: 24px 0; background-color: #e1e4e8; border: 0; } .gitment-markdown blockquote { padding: 0 1em; color: #6a737d; border-left: 0.25em solid #dfe2e5; } .gitment-markdown blockquote>:first-child { margin-top: 0; } .gitment-markdown blockquote>:last-child { margin-bottom: 0; } .gitment-markdown kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: #444d56; vertical-align: middle; background-color: #fafbfc; border: solid 1px #c6cbd1; border-bottom-color: #959da5; border-radius: 0; box-shadow: inset 0 -1px 0 #959da5; } .gitment-markdown h1, .gitment-markdown h2, .gitment-markdown h3, .gitment-markdown h4, .gitment-markdown h5, .gitment-markdown h6 { margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; } .gitment-markdown h1 .octicon-link, .gitment-markdown h2 .octicon-link, .gitment-markdown h3 .octicon-link, .gitment-markdown h4 .octicon-link, .gitment-markdown h5 .octicon-link, .gitment-markdown h6 .octicon-link { color: #1b1f23; vertical-align: middle; visibility: hidden; } .gitment-markdown h1:hover .anchor, .gitment-markdown h2:hover .anchor, .gitment-markdown h3:hover .anchor, .gitment-markdown h4:hover .anchor, .gitment-markdown h5:hover .anchor, .gitment-markdown h6:hover .anchor { text-decoration: none; } .gitment-markdown h1:hover .anchor .octicon-link, .gitment-markdown h2:hover .anchor .octicon-link, .gitment-markdown h3:hover .anchor .octicon-link, .gitment-markdown h4:hover .anchor .octicon-link, .gitment-markdown h5:hover .anchor .octicon-link, .gitment-markdown h6:hover .anchor .octicon-link { visibility: visible; } .gitment-markdown h1 { padding-bottom: 0.3em; font-size: 2em; border-bottom: 1px solid #eaecef; } .gitment-markdown h2 { padding-bottom: 0.3em; font-size: 1.5em; border-bottom: 1px solid #eaecef; } .gitment-markdown h3 { font-size: 1.25em; } .gitment-markdown h4 { font-size: 1em; } .gitment-markdown h5 { font-size: 0.875em; } .gitment-markdown h6 { font-size: 0.85em; color: #6a737d; } .gitment-markdown ul, .gitment-markdown ol { padding-left: 2em; } .gitment-markdown ul ul, .gitment-markdown ul ol, .gitment-markdown ol ol, .gitment-markdown ol ul { margin-top: 0; margin-bottom: 0; } .gitment-markdown li>p { margin-top: 16px; } .gitment-markdown li+li { margin-top: 0.25em; } .gitment-markdown dl { padding: 0; } .gitment-markdown dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: 600; } .gitment-markdown dl dd { padding: 0 16px; margin-bottom: 16px; } .gitment-markdown table { display: block; width: 100%; overflow: auto; } .gitment-markdown table th { font-weight: 600; } .gitment-markdown table th, .gitment-markdown table td { padding: 6px 13px; border: 1px solid #dfe2e5; } .gitment-markdown table tr { background-color: #fff; border-top: 1px solid #c6cbd1; } .gitment-markdown table tr:nth-child(2n) { background-color: #f5f5f5; } .gitment-markdown img { max-width: 100%; box-sizing: content-box; background-color: #fff; } .gitment-markdown code { padding: 0; padding-top: 0.2em; padding-bottom: 0.2em; margin: 0; font-size: 85%; background-color: rgba(27,31,35,0.05); border-radius: 0; } .gitment-markdown code::before, .gitment-markdown code::after { letter-spacing: -0.2em; content: \"\\00a0\"; } .gitment-markdown pre { word-wrap: normal; } .gitment-markdown pre>code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } .gitment-markdown .highlight { margin-bottom: 16px; } .gitment-markdown .highlight pre { margin-bottom: 0; word-break: normal; } .gitment-markdown .highlight pre, .gitment-markdown pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f5f5f5; border-radius: 0; } .gitment-markdown pre code { display: inline; max-width: auto; padding: 0; margin: 0; overflow: visible; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; } .gitment-markdown pre code::before, .gitment-markdown pre code::after { content: normal; } .gitment-markdown .full-commit .btn-outline:not(:disabled):hover { color: #005cc5; border-color: #005cc5; } .gitment-markdown kbd { display: inline-block; padding: 3px 5px; font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; line-height: 10px; color: #444d56; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #c6cbd1; border-bottom-color: #959da5; border-radius: 0; box-shadow: inset 0 -1px 0 #959da5; } .gitment-markdown :checked+.radio-label { position: relative; z-index: 1; border-color: #0366d6; } .gitment-markdown .task-list-item { list-style-type: none; } .gitment-markdown .task-list-item+.task-list-item { margin-top: 3px; } .gitment-markdown .task-list-item input { margin: 0 0.2em 0.25em -1.6em; vertical-align: middle; } .gitment-markdown hr { border-bottom-color: #eee; }"},{"title":"","date":"2022-05-12T00:55:13.371Z","updated":"2018-10-25T09:28:14.000Z","comments":true,"path":"gitment.browser.js","permalink":"https://lchml.com/gitment.browser.js","excerpt":"","text":"var Gitmint = /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) { /******/ return installedModules[moduleId].exports; /******/ } /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ i: moduleId, /******/ l: false, /******/ exports: {} /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.l = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // identity function for calling harmony imports with the correct context /******/ __webpack_require__.i = function(value) { return value; }; /******/ /******/ // define getter function for harmony exports /******/ __webpack_require__.d = function(exports, name, getter) { /******/ if(!__webpack_require__.o(exports, name)) { /******/ Object.defineProperty(exports, name, { /******/ configurable: false, /******/ enumerable: true, /******/ get: getter /******/ }); /******/ } /******/ }; /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules /******/ __webpack_require__.n = function(module) { /******/ var getter = module && module.__esModule ? /******/ function getDefault() { return module['default']; } : /******/ function getModuleExports() { return module; }; /******/ __webpack_require__.d(getter, 'a', getter); /******/ return getter; /******/ }; /******/ /******/ // Object.prototype.hasOwnProperty.call /******/ __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(__webpack_require__.s = 5); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); var LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token'; var LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info'; var NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized'); /***/ }), /* 1 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; /* WEBPACK VAR INJECTION */(function(global) { Object.defineProperty(exports, \"__esModule\", { value: true }); var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /** MobX - (c) Michel Weststrate 2015, 2016 - MIT Licensed */ /*! ***************************************************************************** Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. See the Apache Version 2.0 License for specific language governing permissions and limitations under the License. ***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; } || function (d, b) { for (var p in b) { if (b.hasOwnProperty(p)) d[p] = b[p]; } }; function __extends(d, b) { extendStatics(d, b); function __() { this.constructor = d; } d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __()); } /** * Anything that can be used to _store_ state is an Atom in mobx. Atoms have two important jobs * * 1) detect when they are being _used_ and report this (using reportObserved). This allows mobx to make the connection between running functions and the data they used * 2) they should notify mobx whenever they have _changed_. This way mobx can re-run any functions (derivations) that are using this atom. */ var BaseAtom = function () { /** * Create a new atom. For debugging purposes it is recommended to give it a name. * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management. */ function BaseAtom(name) { if (name === void 0) { name = \"Atom@\" + getNextId(); } this.name = name; this.isPendingUnobservation = true; // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed this.observers = []; this.observersIndexes = {}; this.diffValue = 0; this.lastAccessedBy = 0; this.lowestObserverState = IDerivationState.NOT_TRACKING; } BaseAtom.prototype.onBecomeUnobserved = function () { // noop }; /** * Invoke this method to notify mobx that your atom has been used somehow. */ BaseAtom.prototype.reportObserved = function () { reportObserved(this); }; /** * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate. */ BaseAtom.prototype.reportChanged = function () { startBatch(); propagateChanged(this); endBatch(); }; BaseAtom.prototype.toString = function () { return this.name; }; return BaseAtom; }(); var Atom = function (_super) { __extends(Atom, _super); /** * Create a new atom. For debugging purposes it is recommended to give it a name. * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management. */ function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) { if (name === void 0) { name = \"Atom@\" + getNextId(); } if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; } if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; } var _this = _super.call(this, name) || this; _this.name = name; _this.onBecomeObservedHandler = onBecomeObservedHandler; _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler; _this.isPendingUnobservation = false; // for effective unobserving. _this.isBeingTracked = false; return _this; } Atom.prototype.reportObserved = function () { startBatch(); _super.prototype.reportObserved.call(this); if (!this.isBeingTracked) { this.isBeingTracked = true; this.onBecomeObservedHandler(); } endBatch(); return !!globalState.trackingDerivation; // return doesn't really give useful info, because it can be as well calling computed which calls atom (no reactions) // also it could not trigger when calculating reaction dependent on Atom because Atom's value was cached by computed called by given reaction. }; Atom.prototype.onBecomeUnobserved = function () { this.isBeingTracked = false; this.onBecomeUnobservedHandler(); }; return Atom; }(BaseAtom); var isAtom = createInstanceofPredicate(\"Atom\", BaseAtom); function hasInterceptors(interceptable) { return interceptable.interceptors && interceptable.interceptors.length > 0; } function registerInterceptor(interceptable, handler) { var interceptors = interceptable.interceptors || (interceptable.interceptors = []); interceptors.push(handler); return once(function () { var idx = interceptors.indexOf(handler); if (idx !== -1) interceptors.splice(idx, 1); }); } function interceptChange(interceptable, change) { var prevU = untrackedStart(); try { var interceptors = interceptable.interceptors; if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) { change = interceptors[i](change); invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\"); if (!change) break; } return change; } finally { untrackedEnd(prevU); } } function hasListeners(listenable) { return listenable.changeListeners && listenable.changeListeners.length > 0; } function registerListener(listenable, handler) { var listeners = listenable.changeListeners || (listenable.changeListeners = []); listeners.push(handler); return once(function () { var idx = listeners.indexOf(handler); if (idx !== -1) listeners.splice(idx, 1); }); } function notifyListeners(listenable, change) { var prevU = untrackedStart(); var listeners = listenable.changeListeners; if (!listeners) return; listeners = listeners.slice(); for (var i = 0, l = listeners.length; i < l; i++) { listeners[i](change); } untrackedEnd(prevU); } function isSpyEnabled() { return !!globalState.spyListeners.length; } function spyReport(event) { if (!globalState.spyListeners.length) return; var listeners = globalState.spyListeners; for (var i = 0, l = listeners.length; i < l; i++) { listeners[i](event); } } function spyReportStart(event) { var change = objectAssign({}, event, { spyReportStart: true }); spyReport(change); } var END_EVENT = { spyReportEnd: true }; function spyReportEnd(change) { if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT); } function spy(listener) { globalState.spyListeners.push(listener); return once(function () { var idx = globalState.spyListeners.indexOf(listener); if (idx !== -1) globalState.spyListeners.splice(idx, 1); }); } function iteratorSymbol() { return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\"; } var IS_ITERATING_MARKER = \"__$$iterating\"; function arrayAsIterator(array) { // returning an array for entries(), values() etc for maps was a mis-interpretation of the specs.., // yet it is quite convenient to be able to use the response both as array directly and as iterator // it is suboptimal, but alas... invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\"); addHiddenFinalProp(array, IS_ITERATING_MARKER, true); var idx = -1; addHiddenFinalProp(array, \"next\", function next() { idx++; return { done: idx >= this.length, value: idx < this.length ? this[idx] : undefined }; }); return array; } function declareIterator(prototType, iteratorFactory) { addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory); } var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859 // Detects bug in safari 9.1.1 (or iOS 9 safari mobile). See #364 var safariPrototypeSetterInheritanceBug = function () { var v = false; var p = {}; Object.defineProperty(p, \"0\", { set: function set() { v = true; } }); Object.create(p)[\"0\"] = 1; return v === false; }(); /** * This array buffer contains two lists of properties, so that all arrays * can recycle their property definitions, which significantly improves performance of creating * properties on the fly. */ var OBSERVABLE_ARRAY_BUFFER_SIZE = 0; // Typescript workaround to make sure ObservableArray extends Array var StubArray = function () { function StubArray() {} return StubArray; }(); function inherit(ctor, proto) { if (typeof Object[\"setPrototypeOf\"] !== \"undefined\") { Object[\"setPrototypeOf\"](ctor.prototype, proto); } else if (typeof ctor.prototype.__proto__ !== \"undefined\") { ctor.prototype.__proto__ = proto; } else { ctor[\"prototype\"] = proto; } } inherit(StubArray, Array.prototype); var ObservableArrayAdministration = function () { function ObservableArrayAdministration(name, enhancer, array, owned) { this.array = array; this.owned = owned; this.values = []; this.lastKnownLength = 0; this.interceptors = null; this.changeListeners = null; this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId()); this.enhancer = function (newV, oldV) { return enhancer(newV, oldV, name + \"[..]\"); }; } ObservableArrayAdministration.prototype.dehanceValue = function (value) { if (this.dehancer !== undefined) return this.dehancer(value); return value; }; ObservableArrayAdministration.prototype.dehanceValues = function (values) { if (this.dehancer !== undefined) return values.map(this.dehancer); return values; }; ObservableArrayAdministration.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) { if (fireImmediately === void 0) { fireImmediately = false; } if (fireImmediately) { listener({ object: this.array, type: \"splice\", index: 0, added: this.values.slice(), addedCount: this.values.length, removed: [], removedCount: 0 }); } return registerListener(this, listener); }; ObservableArrayAdministration.prototype.getArrayLength = function () { this.atom.reportObserved(); return this.values.length; }; ObservableArrayAdministration.prototype.setArrayLength = function (newLength) { if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength); var currentLength = this.values.length; if (newLength === currentLength) return;else if (newLength > currentLength) { var newItems = new Array(newLength - currentLength); for (var i = 0; i < newLength - currentLength; i++) { newItems[i] = undefined; } // No Array.fill everywhere... this.spliceWithArray(currentLength, 0, newItems); } else this.spliceWithArray(newLength, currentLength - newLength); }; // adds / removes the necessary numeric properties to this object ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) { if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\"); this.lastKnownLength += delta; if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1); }; ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) { var _this = this; checkIfStateModificationsAreAllowed(this.atom); var length = this.values.length; if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index); if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index)); if (newItems === undefined) newItems = []; if (hasInterceptors(this)) { var change = interceptChange(this, { object: this.array, type: \"splice\", index: index, removedCount: deleteCount, added: newItems }); if (!change) return EMPTY_ARRAY; deleteCount = change.removedCount; newItems = change.added; } newItems = newItems.map(function (v) { return _this.enhancer(v, undefined); }); var lengthDelta = newItems.length - deleteCount; this.updateArrayLength(length, lengthDelta); // create or remove new entries var res = this.spliceItemsIntoValues(index, deleteCount, newItems); if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res); return this.dehanceValues(res); }; ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) { if (newItems.length < MAX_SPLICE_SIZE) { return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems)); } else { var res = this.values.slice(index, index + deleteCount); this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount)); return res; } var _a; }; ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) { var notifySpy = !this.owned && isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { object: this.array, type: \"update\", index: index, newValue: newValue, oldValue: oldValue } : null; if (notifySpy) spyReportStart(change); this.atom.reportChanged(); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); }; ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) { var notifySpy = !this.owned && isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { object: this.array, type: \"splice\", index: index, removed: removed, added: added, removedCount: removed.length, addedCount: added.length } : null; if (notifySpy) spyReportStart(change); this.atom.reportChanged(); // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); }; return ObservableArrayAdministration; }(); var ObservableArray = function (_super) { __extends(ObservableArray, _super); function ObservableArray(initialValues, enhancer, name, owned) { if (name === void 0) { name = \"ObservableArray@\" + getNextId(); } if (owned === void 0) { owned = false; } var _this = _super.call(this) || this; var adm = new ObservableArrayAdministration(name, enhancer, _this, owned); addHiddenFinalProp(_this, \"$mobx\", adm); if (initialValues && initialValues.length) { _this.spliceWithArray(0, 0, initialValues); } if (safariPrototypeSetterInheritanceBug) { // Seems that Safari won't use numeric prototype setter untill any * numeric property is // defined on the instance. After that it works fine, even if this property is deleted. Object.defineProperty(adm.array, \"0\", ENTRY_0); } return _this; } ObservableArray.prototype.intercept = function (handler) { return this.$mobx.intercept(handler); }; ObservableArray.prototype.observe = function (listener, fireImmediately) { if (fireImmediately === void 0) { fireImmediately = false; } return this.$mobx.observe(listener, fireImmediately); }; ObservableArray.prototype.clear = function () { return this.splice(0); }; ObservableArray.prototype.concat = function () { var arrays = []; for (var _i = 0; _i < arguments.length; _i++) { arrays[_i] = arguments[_i]; } this.$mobx.atom.reportObserved(); return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) { return isObservableArray(a) ? a.peek() : a; })); }; ObservableArray.prototype.replace = function (newItems) { return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems); }; /** * Converts this array back to a (shallow) javascript structure. * For a deep clone use mobx.toJS */ ObservableArray.prototype.toJS = function () { return this.slice(); }; ObservableArray.prototype.toJSON = function () { // Used by JSON.stringify return this.toJS(); }; ObservableArray.prototype.peek = function () { this.$mobx.atom.reportObserved(); return this.$mobx.dehanceValues(this.$mobx.values); }; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) { if (fromIndex === void 0) { fromIndex = 0; } var idx = this.findIndex.apply(this, arguments); return idx === -1 ? undefined : this.get(idx); }; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex ObservableArray.prototype.findIndex = function (predicate, thisArg, fromIndex) { if (fromIndex === void 0) { fromIndex = 0; } var items = this.peek(), l = items.length; for (var i = fromIndex; i < l; i++) { if (predicate.call(thisArg, items[i], i, this)) return i; }return -1; }; /* functions that do alter the internal structure of the array, (based on lib.es6.d.ts) since these functions alter the inner structure of the array, the have side effects. Because the have side effects, they should not be used in computed function, and for that reason the do not call dependencyState.notifyObserved */ ObservableArray.prototype.splice = function (index, deleteCount) { var newItems = []; for (var _i = 2; _i < arguments.length; _i++) { newItems[_i - 2] = arguments[_i]; } switch (arguments.length) { case 0: return []; case 1: return this.$mobx.spliceWithArray(index); case 2: return this.$mobx.spliceWithArray(index, deleteCount); } return this.$mobx.spliceWithArray(index, deleteCount, newItems); }; ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) { return this.$mobx.spliceWithArray(index, deleteCount, newItems); }; ObservableArray.prototype.push = function () { var items = []; for (var _i = 0; _i < arguments.length; _i++) { items[_i] = arguments[_i]; } var adm = this.$mobx; adm.spliceWithArray(adm.values.length, 0, items); return adm.values.length; }; ObservableArray.prototype.pop = function () { return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0]; }; ObservableArray.prototype.shift = function () { return this.splice(0, 1)[0]; }; ObservableArray.prototype.unshift = function () { var items = []; for (var _i = 0; _i < arguments.length; _i++) { items[_i] = arguments[_i]; } var adm = this.$mobx; adm.spliceWithArray(0, 0, items); return adm.values.length; }; ObservableArray.prototype.reverse = function () { // reverse by default mutates in place before returning the result // which makes it both a 'derivation' and a 'mutation'. // so we deviate from the default and just make it an dervitation var clone = this.slice(); return clone.reverse.apply(clone, arguments); }; ObservableArray.prototype.sort = function (compareFn) { // sort by default mutates in place before returning the result // which goes against all good practices. Let's not change the array in place! var clone = this.slice(); return clone.sort.apply(clone, arguments); }; ObservableArray.prototype.remove = function (value) { var idx = this.$mobx.dehanceValues(this.$mobx.values).indexOf(value); if (idx > -1) { this.splice(idx, 1); return true; } return false; }; ObservableArray.prototype.move = function (fromIndex, toIndex) { function checkIndex(index) { if (index < 0) { throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\"); } var length = this.$mobx.values.length; if (index >= length) { throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length); } } checkIndex.call(this, fromIndex); checkIndex.call(this, toIndex); if (fromIndex === toIndex) { return; } var oldItems = this.$mobx.values; var newItems; if (fromIndex < toIndex) { newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1)); } else { newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1)); } this.replace(newItems); }; // See #734, in case property accessors are unreliable... ObservableArray.prototype.get = function (index) { var impl = this.$mobx; if (impl) { if (index < impl.values.length) { impl.atom.reportObserved(); return impl.dehanceValue(impl.values[index]); } console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\"); } return undefined; }; // See #734, in case property accessors are unreliable... ObservableArray.prototype.set = function (index, newValue) { var adm = this.$mobx; var values = adm.values; if (index < values.length) { // update at index in range checkIfStateModificationsAreAllowed(adm.atom); var oldValue = values[index]; if (hasInterceptors(adm)) { var change = interceptChange(adm, { type: \"update\", object: this, index: index, newValue: newValue }); if (!change) return; newValue = change.newValue; } newValue = adm.enhancer(newValue, oldValue); var changed = newValue !== oldValue; if (changed) { values[index] = newValue; adm.notifyArrayChildUpdate(index, newValue, oldValue); } } else if (index === values.length) { // add a new item adm.spliceWithArray(index, 0, [newValue]); } else { // out of bounds throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length); } }; return ObservableArray; }(StubArray); declareIterator(ObservableArray.prototype, function () { return arrayAsIterator(this.slice()); }); Object.defineProperty(ObservableArray.prototype, \"length\", { enumerable: false, configurable: true, get: function get() { return this.$mobx.getArrayLength(); }, set: function set(newLength) { this.$mobx.setArrayLength(newLength); } }); /** * Wrap function from prototype */ [\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\", \"toString\", \"toLocaleString\"].forEach(function (funcName) { var baseFunc = Array.prototype[funcName]; invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\"); addHiddenProp(ObservableArray.prototype, funcName, function () { return baseFunc.apply(this.peek(), arguments); }); }); /** * We don't want those to show up in `for (const key in ar)` ... */ makeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"get\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"findIndex\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"set\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]); // See #364 var ENTRY_0 = createArrayEntryDescriptor(0); function createArrayEntryDescriptor(index) { return { enumerable: false, configurable: false, get: function get() { // TODO: Check `this`?, see #752? return this.get(index); }, set: function set(value) { this.set(index, value); } }; } function createArrayBufferItem(index) { Object.defineProperty(ObservableArray.prototype, \"\" + index, createArrayEntryDescriptor(index)); } function reserveArrayBuffer(max) { for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) { createArrayBufferItem(index); }OBSERVABLE_ARRAY_BUFFER_SIZE = max; } reserveArrayBuffer(1000); var isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration); function isObservableArray(thing) { return isObject(thing) && isObservableArrayAdministration(thing.$mobx); } var UNCHANGED = {}; var ObservableValue = function (_super) { __extends(ObservableValue, _super); function ObservableValue(value, enhancer, name, notifySpy) { if (name === void 0) { name = \"ObservableValue@\" + getNextId(); } if (notifySpy === void 0) { notifySpy = true; } var _this = _super.call(this, name) || this; _this.enhancer = enhancer; _this.hasUnreportedChange = false; _this.dehancer = undefined; _this.value = enhancer(value, undefined, name); if (notifySpy && isSpyEnabled()) { // only notify spy if this is a stand-alone observable spyReport({ type: \"create\", object: _this, newValue: _this.value }); } return _this; } ObservableValue.prototype.dehanceValue = function (value) { if (this.dehancer !== undefined) return this.dehancer(value); return value; }; ObservableValue.prototype.set = function (newValue) { var oldValue = this.value; newValue = this.prepareNewValue(newValue); if (newValue !== UNCHANGED) { var notifySpy = isSpyEnabled(); if (notifySpy) { spyReportStart({ type: \"update\", object: this, newValue: newValue, oldValue: oldValue }); } this.setNewValue(newValue); if (notifySpy) spyReportEnd(); } }; ObservableValue.prototype.prepareNewValue = function (newValue) { checkIfStateModificationsAreAllowed(this); if (hasInterceptors(this)) { var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue }); if (!change) return UNCHANGED; newValue = change.newValue; } // apply modifier newValue = this.enhancer(newValue, this.value, this.name); return this.value !== newValue ? newValue : UNCHANGED; }; ObservableValue.prototype.setNewValue = function (newValue) { var oldValue = this.value; this.value = newValue; this.reportChanged(); if (hasListeners(this)) { notifyListeners(this, { type: \"update\", object: this, newValue: newValue, oldValue: oldValue }); } }; ObservableValue.prototype.get = function () { this.reportObserved(); return this.dehanceValue(this.value); }; ObservableValue.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; ObservableValue.prototype.observe = function (listener, fireImmediately) { if (fireImmediately) listener({ object: this, type: \"update\", newValue: this.value, oldValue: undefined }); return registerListener(this, listener); }; ObservableValue.prototype.toJSON = function () { return this.get(); }; ObservableValue.prototype.toString = function () { return this.name + \"[\" + this.value + \"]\"; }; ObservableValue.prototype.valueOf = function () { return toPrimitive(this.get()); }; return ObservableValue; }(BaseAtom); ObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf; var isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue); var messages = { \"m001\": \"It is not allowed to assign new values to @action fields\", \"m002\": \"`runInAction` expects a function\", \"m003\": \"`runInAction` expects a function without arguments\", \"m004\": \"autorun expects a function\", \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\", \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\", \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\", \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\", \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\", \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\", \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\", \"m012\": \"computed takes one or two arguments if used as function\", \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\", \"m014\": \"extendObservable expected 2 or more arguments\", \"m015\": \"extendObservable expects an object as first argument\", \"m016\": \"extendObservable should not be used on maps, use map.merge instead\", \"m017\": \"all arguments of extendObservable should be objects\", \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\", \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\", \"m020\": \"modifiers can only be used for individual object properties\", \"m021\": \"observable expects zero or one arguments\", \"m022\": \"@observable can not be used on getters, use @computed instead\", \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\", \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\", \"m025\": \"whyRun can only be used on reactions and computed values\", \"m026\": \"`action` can only be invoked on functions\", \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\", \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\", \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \", \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \", \"m031\": \"Computed values are not allowed to cause side effects by changing observables that are already being observed. Tried to modify: \", \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n Didn't expect this computation to be suspended at this point?\\n 1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n 2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\", \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\", \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\", \"m035\": \"Cannot make the designated object observable; it is not extensible\", \"m036\": \"It is not possible to get index atoms from arrays\", \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\", \"m038\": \"Missing items in this list?\\n 1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n 2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\" }; function getMessage(id) { return messages[id]; } function createAction(actionName, fn) { invariant(typeof fn === \"function\", getMessage(\"m026\")); invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\"); var res = function res() { return executeAction(actionName, fn, this, arguments); }; res.originalFn = fn; res.isMobxAction = true; return res; } function executeAction(actionName, fn, scope, args) { var runInfo = startAction(actionName, fn, scope, args); try { return fn.apply(scope, args); } finally { endAction(runInfo); } } function startAction(actionName, fn, scope, args) { var notifySpy = isSpyEnabled() && !!actionName; var startTime = 0; if (notifySpy) { startTime = Date.now(); var l = args && args.length || 0; var flattendArgs = new Array(l); if (l > 0) for (var i = 0; i < l; i++) { flattendArgs[i] = args[i]; }spyReportStart({ type: \"action\", name: actionName, fn: fn, object: scope, arguments: flattendArgs }); } var prevDerivation = untrackedStart(); startBatch(); var prevAllowStateChanges = allowStateChangesStart(true); return { prevDerivation: prevDerivation, prevAllowStateChanges: prevAllowStateChanges, notifySpy: notifySpy, startTime: startTime }; } function endAction(runInfo) { allowStateChangesEnd(runInfo.prevAllowStateChanges); endBatch(); untrackedEnd(runInfo.prevDerivation); if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime }); } function useStrict(strict) { invariant(globalState.trackingDerivation === null, getMessage(\"m028\")); globalState.strictMode = strict; globalState.allowStateChanges = !strict; } function isStrictModeEnabled() { return globalState.strictMode; } function allowStateChanges(allowStateChanges, func) { // TODO: deprecate / refactor this function in next major // Currently only used by `@observer` // Proposed change: remove first param, rename to `forbidStateChanges`, // require error callback instead of the hardcoded error message now used // Use `inAction` instead of allowStateChanges in derivation.ts to check strictMode var prev = allowStateChangesStart(allowStateChanges); var res; try { res = func(); } finally { allowStateChangesEnd(prev); } return res; } function allowStateChangesStart(allowStateChanges) { var prev = globalState.allowStateChanges; globalState.allowStateChanges = allowStateChanges; return prev; } function allowStateChangesEnd(prev) { globalState.allowStateChanges = prev; } /** * Constructs a decorator, that normalizes the differences between * TypeScript and Babel. Mainly caused by the fact that legacy-decorator cannot assign * values during instance creation to properties that have a getter setter. * * - Sigh - * * Also takes care of the difference between @decorator field and @decorator(args) field, and different forms of values. * For performance (cpu and mem) reasons the properties are always defined on the prototype (at least initially). * This means that these properties despite being enumerable might not show up in Object.keys() (but they will show up in for...in loops). */ function createClassPropertyDecorator( /** * This function is invoked once, when the property is added to a new instance. * When this happens is not strictly determined due to differences in TS and Babel: * Typescript: Usually when constructing the new instance * Babel, sometimes Typescript: during the first get / set * Both: when calling `runLazyInitializers(instance)` */ onInitialize, _get, _set, enumerable, /** * Can this decorator invoked with arguments? e.g. @decorator(args) */ allowCustomArguments) { function classPropertyDecorator(target, key, descriptor, customArgs, argLen) { if (argLen === void 0) { argLen = 0; } invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\"); if (!descriptor) { // typescript (except for getter / setters) var newDescriptor = { enumerable: enumerable, configurable: true, get: function get() { if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor); return _get.call(this, key); }, set: function set(v) { if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) { typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor); } else { _set.call(this, key, v); } } }; if (arguments.length < 3 || arguments.length === 5 && argLen < 3) { // Typescript target is ES3, so it won't define property for us // or using Reflect.decorate polyfill, which will return no descriptor // (see https://github.com/mobxjs/mobx/issues/333) Object.defineProperty(target, key, newDescriptor); } return newDescriptor; } else { // babel and typescript getter / setter props if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) { addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || [] // support inheritance ); } var value_1 = descriptor.value, initializer_1 = descriptor.initializer; target.__mobxLazyInitializers.push(function (instance) { onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor); }); return { enumerable: enumerable, configurable: true, get: function get() { if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this); return _get.call(this, key); }, set: function set(v) { if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this); _set.call(this, key, v); } }; } } if (allowCustomArguments) { /** If custom arguments are allowed, we should return a function that returns a decorator */ return function () { /** Direct invocation: @decorator bla */ if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments); /** Indirect invocation: @decorator(args) bla */ var outerArgs = arguments; var argLen = arguments.length; return function (target, key, descriptor) { return classPropertyDecorator(target, key, descriptor, outerArgs, argLen); }; }; } return classPropertyDecorator; } function typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) { if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {}); instance.__mobxInitializedProps[key] = true; onInitialize(instance, key, v, customArgs, baseDescriptor); } function runLazyInitializers(instance) { if (instance.__mobxDidRunLazyInitializers === true) return; if (instance.__mobxLazyInitializers) { addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true); instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) { return initializer(instance); }); } } function quacksLikeADecorator(args) { return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\"; } var actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) { var actionName = args && args.length === 1 ? args[0] : value.name || key || \"\"; var wrappedAction = action(actionName, value); addHiddenProp(target, key, wrappedAction); }, function (key) { return this[key]; }, function () { invariant(false, getMessage(\"m001\")); }, false, true); var boundActionDecorator = createClassPropertyDecorator(function (target, key, value) { defineBoundAction(target, key, value); }, function (key) { return this[key]; }, function () { invariant(false, getMessage(\"m001\")); }, false, false); var action = function action(arg1, arg2, arg3, arg4) { if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"\", arg1); if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2); if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1); return namedActionDecorator(arg2).apply(null, arguments); }; action.bound = function boundAction(arg1, arg2, arg3) { if (typeof arg1 === \"function\") { var action_1 = createAction(\"\", arg1); action_1.autoBind = true; return action_1; } return boundActionDecorator.apply(null, arguments); }; function namedActionDecorator(name) { return function (target, prop, descriptor) { if (descriptor && typeof descriptor.value === \"function\") { // TypeScript @action method() { }. Defined on proto before being decorated // Don't use the field decorator if we are just decorating a method descriptor.value = createAction(name, descriptor.value); descriptor.enumerable = false; descriptor.configurable = true; return descriptor; } // bound instance methods return actionFieldDecorator(name).apply(this, arguments); }; } function runInAction(arg1, arg2, arg3) { var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"\"; var fn = typeof arg1 === \"function\" ? arg1 : arg2; var scope = typeof arg1 === \"function\" ? arg2 : arg3; invariant(typeof fn === \"function\", getMessage(\"m002\")); invariant(fn.length === 0, getMessage(\"m003\")); invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\"); return executeAction(actionName, fn, scope, undefined); } function isAction(thing) { return typeof thing === \"function\" && thing.isMobxAction === true; } function defineBoundAction(target, propertyName, fn) { var res = function res() { return executeAction(propertyName, fn, target, arguments); }; res.isMobxAction = true; addHiddenProp(target, propertyName, res); } function identityComparer(a, b) { return a === b; } function structuralComparer(a, b) { if (typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b)) { return true; } return deepEqual(a, b); } function defaultComparer(a, b) { if (typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b)) { return true; } return identityComparer(a, b); } var comparer = { identity: identityComparer, structural: structuralComparer, default: defaultComparer }; function autorun(arg1, arg2, arg3) { var name, view, scope; if (typeof arg1 === \"string\") { name = arg1; view = arg2; scope = arg3; } else { name = arg1.name || \"Autorun@\" + getNextId(); view = arg1; scope = arg2; } invariant(typeof view === \"function\", getMessage(\"m004\")); invariant(isAction(view) === false, getMessage(\"m005\")); if (scope) view = view.bind(scope); var reaction = new Reaction(name, function () { this.track(reactionRunner); }); function reactionRunner() { view(reaction); } reaction.schedule(); return reaction.getDisposer(); } function when(arg1, arg2, arg3, arg4) { var name, predicate, effect, scope; if (typeof arg1 === \"string\") { name = arg1; predicate = arg2; effect = arg3; scope = arg4; } else { name = \"When@\" + getNextId(); predicate = arg1; effect = arg2; scope = arg3; } var disposer = autorun(name, function (r) { if (predicate.call(scope)) { r.dispose(); var prevUntracked = untrackedStart(); effect.call(scope); untrackedEnd(prevUntracked); } }); return disposer; } function autorunAsync(arg1, arg2, arg3, arg4) { var name, func, delay, scope; if (typeof arg1 === \"string\") { name = arg1; func = arg2; delay = arg3; scope = arg4; } else { name = arg1.name || \"AutorunAsync@\" + getNextId(); func = arg1; delay = arg2; scope = arg3; } invariant(isAction(func) === false, getMessage(\"m006\")); if (delay === void 0) delay = 1; if (scope) func = func.bind(scope); var isScheduled = false; var r = new Reaction(name, function () { if (!isScheduled) { isScheduled = true; setTimeout(function () { isScheduled = false; if (!r.isDisposed) r.track(reactionRunner); }, delay); } }); function reactionRunner() { func(r); } r.schedule(); return r.getDisposer(); } function reaction(expression, effect, arg3) { if (arguments.length > 3) { fail(getMessage(\"m007\")); } if (isModifierDescriptor(expression)) { fail(getMessage(\"m008\")); } var opts; if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") { opts = arg3; } else { opts = {}; } opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId(); opts.fireImmediately = arg3 === true || opts.fireImmediately === true; opts.delay = opts.delay || 0; opts.compareStructural = opts.compareStructural || opts.struct || false; effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect); if (opts.context) { expression = expression.bind(opts.context); } var firstTime = true; var isScheduled = false; var value; var equals = opts.equals ? opts.equals : opts.compareStructural || opts.struct ? comparer.structural : comparer.default; var r = new Reaction(opts.name, function () { if (firstTime || opts.delay < 1) { reactionRunner(); } else if (!isScheduled) { isScheduled = true; setTimeout(function () { isScheduled = false; reactionRunner(); }, opts.delay); } }); function reactionRunner() { if (r.isDisposed) return; var changed = false; r.track(function () { var nextValue = expression(r); changed = firstTime || !equals(value, nextValue); value = nextValue; }); if (firstTime && opts.fireImmediately) effect(value, r); if (!firstTime && changed === true) effect(value, r); if (firstTime) firstTime = false; } r.schedule(); return r.getDisposer(); } /** * A node in the state dependency root that observes other nodes, and can be observed itself. * * ComputedValue will remember result of the computation for duration of a batch, or being observed * During this time it will recompute only when one of its direct dependencies changed, * but only when it is being accessed with `ComputedValue.get()`. * * Implementation description: * 1. First time it's being accessed it will compute and remember result * give back remembered result until 2. happens * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3. * 3. When it's being accessed, recompute if any shallow dependency changed. * if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step. * go to step 2. either way * * If at any point it's outside batch and it isn't observed: reset everything and go to 1. */ var ComputedValue = function () { /** * Create a new computed value based on a function expression. * * The `name` property is for debug purposes only. * * The `equals` property specifies the comparer function to use to determine if a newly produced * value differs from the previous value. Two comparers are provided in the library; `defaultComparer` * compares based on identity comparison (===), and `structualComparer` deeply compares the structure. * Structural comparison can be convenient if you always produce an new aggregated object and * don't want to notify observers if it is structurally the same. * This is useful for working with vectors, mouse coordinates etc. */ function ComputedValue(derivation, scope, equals, name, setter) { this.derivation = derivation; this.scope = scope; this.equals = equals; this.dependenciesState = IDerivationState.NOT_TRACKING; this.observing = []; // nodes we are looking at. Our value depends on these nodes this.newObserving = null; // during tracking it's an array with new observed observers this.isPendingUnobservation = false; this.observers = []; this.observersIndexes = {}; this.diffValue = 0; this.runId = 0; this.lastAccessedBy = 0; this.lowestObserverState = IDerivationState.UP_TO_DATE; this.unboundDepsCount = 0; this.__mapid = \"#\" + getNextId(); this.value = new CaughtException(null); this.isComputing = false; // to check for cycles this.isRunningSetter = false; this.name = name || \"ComputedValue@\" + getNextId(); if (setter) this.setter = createAction(name + \"-setter\", setter); } ComputedValue.prototype.onBecomeStale = function () { propagateMaybeChanged(this); }; ComputedValue.prototype.onBecomeUnobserved = function () { clearObserving(this); this.value = undefined; }; /** * Returns the current value of this computed value. * Will evaluate its computation first if needed. */ ComputedValue.prototype.get = function () { invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation); if (globalState.inBatch === 0) { // This is an minor optimization which could be omitted to simplify the code // The computedValue is accessed outside of any mobx stuff. Batch observing should be enough and don't need // tracking as it will never be called again inside this batch. startBatch(); if (shouldCompute(this)) this.value = this.computeValue(false); endBatch(); } else { reportObserved(this); if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this); } var result = this.value; if (isCaughtException(result)) throw result.cause; return result; }; ComputedValue.prototype.peek = function () { var res = this.computeValue(false); if (isCaughtException(res)) throw res.cause; return res; }; ComputedValue.prototype.set = function (value) { if (this.setter) { invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\"); this.isRunningSetter = true; try { this.setter.call(this.scope, value); } finally { this.isRunningSetter = false; } } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\"); }; ComputedValue.prototype.trackAndCompute = function () { if (isSpyEnabled()) { spyReport({ object: this.scope, type: \"compute\", fn: this.derivation }); } var oldValue = this.value; var newValue = this.value = this.computeValue(true); return isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals(oldValue, newValue); }; ComputedValue.prototype.computeValue = function (track) { this.isComputing = true; globalState.computationDepth++; var res; if (track) { res = trackDerivedFunction(this, this.derivation, this.scope); } else { try { res = this.derivation.call(this.scope); } catch (e) { res = new CaughtException(e); } } globalState.computationDepth--; this.isComputing = false; return res; }; ComputedValue.prototype.observe = function (listener, fireImmediately) { var _this = this; var firstTime = true; var prevValue = undefined; return autorun(function () { var newValue = _this.get(); if (!firstTime || fireImmediately) { var prevU = untrackedStart(); listener({ type: \"update\", object: _this, newValue: newValue, oldValue: prevValue }); untrackedEnd(prevU); } firstTime = false; prevValue = newValue; }); }; ComputedValue.prototype.toJSON = function () { return this.get(); }; ComputedValue.prototype.toString = function () { return this.name + \"[\" + this.derivation.toString() + \"]\"; }; ComputedValue.prototype.valueOf = function () { return toPrimitive(this.get()); }; ComputedValue.prototype.whyRun = function () { var isTracking = Boolean(globalState.trackingDerivation); var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) { return dep.name; }); var observers = unique(getObservers(this).map(function (dep) { return dep.name; })); return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n \" + joinStrings(observing) + \"\\n \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n * If the outcome of this computation changes, the following observers will be re-run:\\n \" + joinStrings(observers) + \"\\n\"); }; return ComputedValue; }(); ComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf; var isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue); var ObservableObjectAdministration = function () { function ObservableObjectAdministration(target, name) { this.target = target; this.name = name; this.values = {}; this.changeListeners = null; this.interceptors = null; } /** * Observes this object. Triggers for the events 'add', 'update' and 'delete'. * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe * for callback details */ ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) { invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\"); return registerListener(this, callback); }; ObservableObjectAdministration.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; return ObservableObjectAdministration; }(); function asObservableObject(target, name) { if (isObservableObject(target)) return target.$mobx; invariant(Object.isExtensible(target), getMessage(\"m035\")); if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId(); if (!name) name = \"ObservableObject@\" + getNextId(); var adm = new ObservableObjectAdministration(target, name); addHiddenFinalProp(target, \"$mobx\", adm); return adm; } function defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) { if (adm.values[propName]) { // already observable property invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\"); adm.target[propName] = descriptor.value; // the property setter will make 'value' reactive if needed. return; } // not yet observable property if (\"value\" in descriptor) { // not a computed value if (isModifierDescriptor(descriptor.value)) { // x : ref(someValue) var modifierDescriptor = descriptor.value; defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer); } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) { defineBoundAction(adm.target, propName, descriptor.value.originalFn); } else if (isComputedValue(descriptor.value)) { // x: computed(someExpr) defineComputedPropertyFromComputedValue(adm, propName, descriptor.value); } else { // x: someValue defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer); } } else { // get x() { return 3 } set x(v) { } defineComputedProperty(adm, propName, descriptor.get, descriptor.set, comparer.default, true); } } function defineObservableProperty(adm, propName, newValue, enhancer) { assertPropertyConfigurable(adm.target, propName); if (hasInterceptors(adm)) { var change = interceptChange(adm, { object: adm.target, name: propName, type: \"add\", newValue: newValue }); if (!change) return; newValue = change.newValue; } var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false); newValue = observable.value; // observableValue might have changed it Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName)); notifyPropertyAddition(adm, adm.target, propName, newValue); } function defineComputedProperty(adm, propName, getter, setter, equals, asInstanceProperty) { if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName); adm.values[propName] = new ComputedValue(getter, adm.target, equals, adm.name + \".\" + propName, setter); if (asInstanceProperty) { Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName)); } } function defineComputedPropertyFromComputedValue(adm, propName, computedValue) { var name = adm.name + \".\" + propName; computedValue.name = name; if (!computedValue.scope) computedValue.scope = adm.target; adm.values[propName] = computedValue; Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName)); } var observablePropertyConfigs = {}; var computedPropertyConfigs = {}; function generateObservablePropConfig(propName) { return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = { configurable: true, enumerable: true, get: function get() { return this.$mobx.values[propName].get(); }, set: function set(v) { setPropertyValue(this, propName, v); } }); } function generateComputedPropConfig(propName) { return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = { configurable: true, enumerable: false, get: function get() { return this.$mobx.values[propName].get(); }, set: function set(v) { return this.$mobx.values[propName].set(v); } }); } function setPropertyValue(instance, name, newValue) { var adm = instance.$mobx; var observable = adm.values[name]; // intercept if (hasInterceptors(adm)) { var change = interceptChange(adm, { type: \"update\", object: instance, name: name, newValue: newValue }); if (!change) return; newValue = change.newValue; } newValue = observable.prepareNewValue(newValue); // notify spy & observers if (newValue !== UNCHANGED) { var notify = hasListeners(adm); var notifySpy = isSpyEnabled(); var change = notify || notifySpy ? { type: \"update\", object: instance, oldValue: observable.value, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); observable.setNewValue(newValue); if (notify) notifyListeners(adm, change); if (notifySpy) spyReportEnd(); } } function notifyPropertyAddition(adm, object, name, newValue) { var notify = hasListeners(adm); var notifySpy = isSpyEnabled(); var change = notify || notifySpy ? { type: \"add\", object: object, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); if (notify) notifyListeners(adm, change); if (notifySpy) spyReportEnd(); } var isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration); function isObservableObject(thing) { if (isObject(thing)) { // Initializers run lazily when transpiling to babel, so make sure they are run... runLazyInitializers(thing); return isObservableObjectAdministration(thing.$mobx); } return false; } /** * Returns true if the provided value is reactive. * @param value object, function or array * @param property if property is specified, checks whether value.property is reactive. */ function isObservable(value, property) { if (value === null || value === undefined) return false; if (property !== undefined) { if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) { var o = value.$mobx; return o.values && !!o.values[property]; } return false; } // For first check, see #701 return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value); } function createDecoratorForEnhancer(enhancer) { invariant(!!enhancer, \":(\"); return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) { assertPropertyConfigurable(target, name); invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\")); var adm = asObservableObject(target, undefined); defineObservableProperty(adm, name, baseValue, enhancer); }, function (name) { var observable = this.$mobx.values[name]; if (observable === undefined) return undefined; return observable.get(); }, function (name, value) { setPropertyValue(this, name, value); }, true, false); } function extendObservable(target) { var properties = []; for (var _i = 1; _i < arguments.length; _i++) { properties[_i - 1] = arguments[_i]; } return extendObservableHelper(target, deepEnhancer, properties); } function extendShallowObservable(target) { var properties = []; for (var _i = 1; _i < arguments.length; _i++) { properties[_i - 1] = arguments[_i]; } return extendObservableHelper(target, referenceEnhancer, properties); } function extendObservableHelper(target, defaultEnhancer, properties) { invariant(arguments.length >= 2, getMessage(\"m014\")); invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\")); invariant(!isObservableMap(target), getMessage(\"m016\")); properties.forEach(function (propSet) { invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\")); invariant(!isObservable(propSet), getMessage(\"m018\")); }); var adm = asObservableObject(target); var definedProps = {}; // Note could be optimised if properties.length === 1 for (var i = properties.length - 1; i >= 0; i--) { var propSet = properties[i]; for (var key in propSet) { if (definedProps[key] !== true && hasOwnProperty(propSet, key)) { definedProps[key] = true; if (target === propSet && !isPropertyConfigurable(target, key)) continue; // see #111, skip non-configurable or non-writable props for `observable(object)`. var descriptor = Object.getOwnPropertyDescriptor(propSet, key); defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer); } } } return target; } var deepDecorator = createDecoratorForEnhancer(deepEnhancer); var shallowDecorator = createDecoratorForEnhancer(shallowEnhancer); var refDecorator = createDecoratorForEnhancer(referenceEnhancer); var deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer); var refStructDecorator = createDecoratorForEnhancer(refStructEnhancer); /** * Turns an object, array or function into a reactive structure. * @param v the value which should become observable. */ function createObservable(v) { if (v === void 0) { v = undefined; } // @observable someProp; if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments); invariant(arguments.length 2) incorrectlyUsedAsDecorator(\"box\"); return new ObservableValue(value, deepEnhancer, name); }; IObservableFactories.prototype.shallowBox = function (value, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\"); return new ObservableValue(value, referenceEnhancer, name); }; IObservableFactories.prototype.array = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\"); return new ObservableArray(initialValues, deepEnhancer, name); }; IObservableFactories.prototype.shallowArray = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\"); return new ObservableArray(initialValues, referenceEnhancer, name); }; IObservableFactories.prototype.map = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\"); return new ObservableMap(initialValues, deepEnhancer, name); }; IObservableFactories.prototype.shallowMap = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\"); return new ObservableMap(initialValues, referenceEnhancer, name); }; IObservableFactories.prototype.object = function (props, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\"); var res = {}; // convert to observable object asObservableObject(res, name); // add properties extendObservable(res, props); return res; }; IObservableFactories.prototype.shallowObject = function (props, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\"); var res = {}; asObservableObject(res, name); extendShallowObservable(res, props); return res; }; IObservableFactories.prototype.ref = function () { if (arguments.length < 2) { // although ref creates actually a modifier descriptor, the type of the resultig properties // of the object is `T` in the end, when the descriptors are interpreted return createModifierDescriptor(referenceEnhancer, arguments[0]); } else { return refDecorator.apply(null, arguments); } }; IObservableFactories.prototype.shallow = function () { if (arguments.length < 2) { // although ref creates actually a modifier descriptor, the type of the resultig properties // of the object is `T` in the end, when the descriptors are interpreted return createModifierDescriptor(shallowEnhancer, arguments[0]); } else { return shallowDecorator.apply(null, arguments); } }; IObservableFactories.prototype.deep = function () { if (arguments.length < 2) { // although ref creates actually a modifier descriptor, the type of the resultig properties // of the object is `T` in the end, when the descriptors are interpreted return createModifierDescriptor(deepEnhancer, arguments[0]); } else { return deepDecorator.apply(null, arguments); } }; IObservableFactories.prototype.struct = function () { if (arguments.length < 2) { // although ref creates actually a modifier descriptor, the type of the resultig properties // of the object is `T` in the end, when the descriptors are interpreted return createModifierDescriptor(deepStructEnhancer, arguments[0]); } else { return deepStructDecorator.apply(null, arguments); } }; return IObservableFactories; }(); var observable = createObservable; // weird trick to keep our typings nicely with our funcs, and still extend the observable function // ES6 class methods aren't enumerable, can't use Object.keys Object.getOwnPropertyNames(IObservableFactories.prototype).filter(function (name) { return name !== \"constructor\"; }).forEach(function (name) { return observable[name] = IObservableFactories.prototype[name]; }); observable.deep.struct = observable.struct; observable.ref.struct = function () { if (arguments.length < 2) { return createModifierDescriptor(refStructEnhancer, arguments[0]); } else { return refStructDecorator.apply(null, arguments); } }; function incorrectlyUsedAsDecorator(methodName) { fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\"); } function isModifierDescriptor(thing) { return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true; } function createModifierDescriptor(enhancer, initialValue) { invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\"); return { isMobxModifierDescriptor: true, initialValue: initialValue, enhancer: enhancer }; } function deepEnhancer(v, _, name) { if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\"); // it is an observable already, done if (isObservable(v)) return v; // something that can be converted and mutated? if (Array.isArray(v)) return observable.array(v, name); if (isPlainObject(v)) return observable.object(v, name); if (isES6Map(v)) return observable.map(v, name); return v; } function shallowEnhancer(v, _, name) { if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\"); if (v === undefined || v === null) return v; if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v; if (Array.isArray(v)) return observable.shallowArray(v, name); if (isPlainObject(v)) return observable.shallowObject(v, name); if (isES6Map(v)) return observable.shallowMap(v, name); return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\"); } function referenceEnhancer(newValue) { // never turn into an observable return newValue; } function deepStructEnhancer(v, oldValue, name) { // don't confuse structurally compare enhancer with ref enhancer! The latter is probably // more suited for immutable objects if (deepEqual(v, oldValue)) return oldValue; // it is an observable already, done if (isObservable(v)) return v; // something that can be converted and mutated? if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name); if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name); if (isPlainObject(v)) { var res = {}; asObservableObject(res, name); extendObservableHelper(res, deepStructEnhancer, [v]); return res; } return v; } function refStructEnhancer(v, oldValue, name) { if (deepEqual(v, oldValue)) return oldValue; return v; } /** * @deprecated * During a transaction no views are updated until the end of the transaction. * The transaction will be run synchronously nonetheless. * * Deprecated to simplify api; transactions offer no real benefit above actions. * * @param action a function that updates some reactive state * @returns any value that was returned by the 'action' parameter. */ function transaction(action, thisArg) { if (thisArg === void 0) { thisArg = undefined; } deprecated(getMessage(\"m023\")); return runInTransaction.apply(undefined, arguments); } function runInTransaction(action, thisArg) { if (thisArg === void 0) { thisArg = undefined; } return executeAction(\"\", action); } var ObservableMapMarker = {}; var ObservableMap = function () { function ObservableMap(initialData, enhancer, name) { if (enhancer === void 0) { enhancer = deepEnhancer; } if (name === void 0) { name = \"ObservableMap@\" + getNextId(); } this.enhancer = enhancer; this.name = name; this.$mobx = ObservableMapMarker; this._data = Object.create(null); this._hasMap = Object.create(null); // hasMap, not hashMap >-). this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true); this.interceptors = null; this.changeListeners = null; this.dehancer = undefined; this.merge(initialData); } ObservableMap.prototype._has = function (key) { return typeof this._data[key] !== \"undefined\"; }; ObservableMap.prototype.has = function (key) { if (!this.isValidKey(key)) return false; key = \"\" + key; if (this._hasMap[key]) return this._hasMap[key].get(); return this._updateHasMapEntry(key, false).get(); }; ObservableMap.prototype.set = function (key, value) { this.assertValidKey(key); key = \"\" + key; var hasKey = this._has(key); if (hasInterceptors(this)) { var change = interceptChange(this, { type: hasKey ? \"update\" : \"add\", object: this, newValue: value, name: key }); if (!change) return this; value = change.newValue; } if (hasKey) { this._updateValue(key, value); } else { this._addValue(key, value); } return this; }; ObservableMap.prototype.delete = function (key) { var _this = this; this.assertValidKey(key); key = \"\" + key; if (hasInterceptors(this)) { var change = interceptChange(this, { type: \"delete\", object: this, name: key }); if (!change) return false; } if (this._has(key)) { var notifySpy = isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { type: \"delete\", object: this, oldValue: this._data[key].value, name: key } : null; if (notifySpy) spyReportStart(change); runInTransaction(function () { _this._keys.remove(key); _this._updateHasMapEntry(key, false); var observable$$1 = _this._data[key]; observable$$1.setNewValue(undefined); _this._data[key] = undefined; }); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); return true; } return false; }; ObservableMap.prototype._updateHasMapEntry = function (key, value) { // optimization; don't fill the hasMap if we are not observing, or remove entry if there are no observers anymore var entry = this._hasMap[key]; if (entry) { entry.setNewValue(value); } else { entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false); } return entry; }; ObservableMap.prototype._updateValue = function (name, newValue) { var observable$$1 = this._data[name]; newValue = observable$$1.prepareNewValue(newValue); if (newValue !== UNCHANGED) { var notifySpy = isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { type: \"update\", object: this, oldValue: observable$$1.value, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); observable$$1.setNewValue(newValue); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); } }; ObservableMap.prototype._addValue = function (name, newValue) { var _this = this; runInTransaction(function () { var observable$$1 = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false); newValue = observable$$1.value; // value might have been changed _this._updateHasMapEntry(name, true); _this._keys.push(name); }); var notifySpy = isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { type: \"add\", object: this, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); }; ObservableMap.prototype.get = function (key) { key = \"\" + key; if (this.has(key)) return this.dehanceValue(this._data[key].get()); return this.dehanceValue(undefined); }; ObservableMap.prototype.dehanceValue = function (value) { if (this.dehancer !== undefined) { return this.dehancer(value); } return value; }; ObservableMap.prototype.keys = function () { return arrayAsIterator(this._keys.slice()); }; ObservableMap.prototype.values = function () { return arrayAsIterator(this._keys.map(this.get, this)); }; ObservableMap.prototype.entries = function () { var _this = this; return arrayAsIterator(this._keys.map(function (key) { return [key, _this.get(key)]; })); }; ObservableMap.prototype.forEach = function (callback, thisArg) { var _this = this; this.keys().forEach(function (key) { return callback.call(thisArg, _this.get(key), key, _this); }); }; /** Merge another object into this object, returns this. */ ObservableMap.prototype.merge = function (other) { var _this = this; if (isObservableMap(other)) { other = other.toJS(); } runInTransaction(function () { if (isPlainObject(other)) Object.keys(other).forEach(function (key) { return _this.set(key, other[key]); });else if (Array.isArray(other)) other.forEach(function (_a) { var key = _a[0], value = _a[1]; return _this.set(key, value); });else if (isES6Map(other)) other.forEach(function (value, key) { return _this.set(key, value); });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other); }); return this; }; ObservableMap.prototype.clear = function () { var _this = this; runInTransaction(function () { untracked(function () { _this.keys().forEach(_this.delete, _this); }); }); }; ObservableMap.prototype.replace = function (values) { var _this = this; runInTransaction(function () { _this.clear(); _this.merge(values); }); return this; }; Object.defineProperty(ObservableMap.prototype, \"size\", { get: function get() { return this._keys.length; }, enumerable: true, configurable: true }); /** * Returns a shallow non observable object clone of this map. * Note that the values migth still be observable. For a deep clone use mobx.toJS. */ ObservableMap.prototype.toJS = function () { var _this = this; var res = {}; this.keys().forEach(function (key) { return res[key] = _this.get(key); }); return res; }; ObservableMap.prototype.toJSON = function () { // Used by JSON.stringify return this.toJS(); }; ObservableMap.prototype.isValidKey = function (key) { if (key === null || key === undefined) return false; if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true; return false; }; ObservableMap.prototype.assertValidKey = function (key) { if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\"); }; ObservableMap.prototype.toString = function () { var _this = this; return this.name + \"[{ \" + this.keys().map(function (key) { return key + \": \" + (\"\" + _this.get(key)); }).join(\", \") + \" }]\"; }; /** * Observes this object. Triggers for the events 'add', 'update' and 'delete'. * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe * for callback details */ ObservableMap.prototype.observe = function (listener, fireImmediately) { invariant(fireImmediately !== true, getMessage(\"m033\")); return registerListener(this, listener); }; ObservableMap.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; return ObservableMap; }(); declareIterator(ObservableMap.prototype, function () { return this.entries(); }); function map(initialValues) { deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\"); return observable.map(initialValues); } /* 'var' fixes small-build issue */ var isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap); var EMPTY_ARRAY = []; Object.freeze(EMPTY_ARRAY); function getGlobal() { return global; } function getNextId() { return ++globalState.mobxGuid; } function fail(message, thing) { invariant(false, message, thing); throw \"X\"; // unreachable } function invariant(check, message, thing) { if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\")); } /** * Prints a deprecation message, but only one time. * Returns false if the deprecated message was already printed before */ var deprecatedMessages = []; function deprecated(msg) { if (deprecatedMessages.indexOf(msg) !== -1) return false; deprecatedMessages.push(msg); console.error(\"[mobx] Deprecated: \" + msg); return true; } /** * Makes sure that the provided function is invoked at most once. */ function once(func) { var invoked = false; return function () { if (invoked) return; invoked = true; return func.apply(this, arguments); }; } var noop = function noop() {}; function unique(list) { var res = []; list.forEach(function (item) { if (res.indexOf(item) === -1) res.push(item); }); return res; } function joinStrings(things, limit, separator) { if (limit === void 0) { limit = 100; } if (separator === void 0) { separator = \" - \"; } if (!things) return \"\"; var sliced = things.slice(0, limit); return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\"); } function isObject(value) { return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\"; } function isPlainObject(value) { if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false; var proto = Object.getPrototypeOf(value); return proto === Object.prototype || proto === null; } function objectAssign() { var res = arguments[0]; for (var i = 1, l = arguments.length; i < l; i++) { var source = arguments[i]; for (var key in source) { if (hasOwnProperty(source, key)) { res[key] = source[key]; } } } return res; } var prototypeHasOwnProperty = Object.prototype.hasOwnProperty; function hasOwnProperty(object, propName) { return prototypeHasOwnProperty.call(object, propName); } function makeNonEnumerable(object, propNames) { for (var i = 0; i < propNames.length; i++) { addHiddenProp(object, propNames[i], object[propNames[i]]); } } function addHiddenProp(object, propName, value) { Object.defineProperty(object, propName, { enumerable: false, writable: true, configurable: true, value: value }); } function addHiddenFinalProp(object, propName, value) { Object.defineProperty(object, propName, { enumerable: false, writable: false, configurable: true, value: value }); } function isPropertyConfigurable(object, prop) { var descriptor = Object.getOwnPropertyDescriptor(object, prop); return !descriptor || descriptor.configurable !== false && descriptor.writable !== false; } function assertPropertyConfigurable(object, prop) { invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\"); } function getEnumerableKeys(obj) { var res = []; for (var key in obj) { res.push(key); }return res; } /** * Naive deepEqual. Doesn't check for prototype, non-enumerable or out-of-range properties on arrays. * If you have such a case, you probably should use this function but something fancier :). */ function deepEqual(a, b) { if (a === null && b === null) return true; if (a === undefined && b === undefined) return true; if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b; var aIsArray = isArrayLike(a); var aIsMap = isMapLike(a); if (aIsArray !== isArrayLike(b)) { return false; } else if (aIsMap !== isMapLike(b)) { return false; } else if (aIsArray) { if (a.length !== b.length) return false; for (var i = a.length - 1; i >= 0; i--) { if (!deepEqual(a[i], b[i])) return false; }return true; } else if (aIsMap) { if (a.size !== b.size) return false; var equals_1 = true; a.forEach(function (value, key) { equals_1 = equals_1 && deepEqual(b.get(key), value); }); return equals_1; } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") { if (a === null || b === null) return false; if (isMapLike(a) && isMapLike(b)) { if (a.size !== b.size) return false; // Freaking inefficient.... Create PR if you run into this :) Much appreciated! return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries()); } if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false; for (var prop in a) { if (!(prop in b)) return false; if (!deepEqual(a[prop], b[prop])) return false; } return true; } return false; } function createInstanceofPredicate(name, clazz) { var propName = \"isMobX\" + name; clazz.prototype[propName] = true; return function (x) { return isObject(x) && x[propName] === true; }; } /** * Returns whether the argument is an array, disregarding observability. */ function isArrayLike(x) { return Array.isArray(x) || isObservableArray(x); } function isMapLike(x) { return isES6Map(x) || isObservableMap(x); } function isES6Map(thing) { if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true; return false; } function primitiveSymbol() { return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\"; } function toPrimitive(value) { return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value; } /** * These values will persist if global state is reset */ var persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"]; var MobXGlobals = function () { function MobXGlobals() { /** * MobXGlobals version. * MobX compatiblity with other versions loaded in memory as long as this version matches. * It indicates that the global state still stores similar information */ this.version = 5; /** * Currently running derivation */ this.trackingDerivation = null; /** * Are we running a computation currently? (not a reaction) */ this.computationDepth = 0; /** * Each time a derivation is tracked, it is assigned a unique run-id */ this.runId = 0; /** * 'guid' for general purpose. Will be persisted amongst resets. */ this.mobxGuid = 0; /** * Are we in a batch block? (and how many of them) */ this.inBatch = 0; /** * Observables that don't have observers anymore, and are about to be * suspended, unless somebody else accesses it in the same batch * * @type {IObservable[]} */ this.pendingUnobservations = []; /** * List of scheduled, not yet executed, reactions. */ this.pendingReactions = []; /** * Are we currently processing reactions? */ this.isRunningReactions = false; /** * Is it allowed to change observables at this point? * In general, MobX doesn't allow that when running computations and React.render. * To ensure that those functions stay pure. */ this.allowStateChanges = true; /** * If strict mode is enabled, state changes are by default not allowed */ this.strictMode = false; /** * Used by createTransformer to detect that the global state has been reset. */ this.resetId = 0; /** * Spy callbacks */ this.spyListeners = []; /** * Globally attached error handlers that react specifically to errors in reactions */ this.globalReactionErrorHandlers = []; } return MobXGlobals; }(); var globalState = new MobXGlobals(); var shareGlobalStateCalled = false; var runInIsolationCalled = false; var warnedAboutMultipleInstances = false; { var global_1 = getGlobal(); if (!global_1.__mobxInstanceCount) { global_1.__mobxInstanceCount = 1; } else { global_1.__mobxInstanceCount++; setTimeout(function () { if (!shareGlobalStateCalled && !runInIsolationCalled && !warnedAboutMultipleInstances) { warnedAboutMultipleInstances = true; console.warn(\"[mobx] Warning: there are multiple mobx instances active. This might lead to unexpected results. See https://github.com/mobxjs/mobx/issues/1082 for details.\"); } }); } } function isolateGlobalState() { runInIsolationCalled = true; getGlobal().__mobxInstanceCount--; } function shareGlobalState() { // TODO: remove in 4.0; just use peer dependencies instead. deprecated(\"Using `shareGlobalState` is not recommended, use peer dependencies instead. See https://github.com/mobxjs/mobx/issues/1082 for details.\"); shareGlobalStateCalled = true; var global = getGlobal(); var ownState = globalState; /** * Backward compatibility check */ if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\"); if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\"); if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState; } function getGlobalState() { return globalState; } /** * For testing purposes only; this will break the internal state of existing observables, * but can be used to get back at a stable state after throwing errors */ function resetGlobalState() { globalState.resetId++; var defaultGlobals = new MobXGlobals(); for (var key in defaultGlobals) { if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key]; }globalState.allowStateChanges = !globalState.strictMode; } function hasObservers(observable) { return observable.observers && observable.observers.length > 0; } function getObservers(observable) { return observable.observers; } function addObserver(observable, node) { // invariant(node.dependenciesState !== -1, \"INTERNAL ERROR, can add only dependenciesState !== -1\"); // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR add already added node\"); // invariantObservers(observable); var l = observable.observers.length; if (l) { observable.observersIndexes[node.__mapid] = l; } observable.observers[l] = node; if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState; // invariantObservers(observable); // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR didnt add node\"); } function removeObserver(observable, node) { // invariant(globalState.inBatch > 0, \"INTERNAL ERROR, remove should be called only inside batch\"); // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR remove already removed node\"); // invariantObservers(observable); if (observable.observers.length === 1) { // deleting last observer observable.observers.length = 0; queueForUnobservation(observable); } else { // deleting from _observersIndexes is straight forward, to delete from _observers, let's swap `node` with last element var list = observable.observers; var map = observable.observersIndexes; var filler = list.pop(); // get last element, which should fill the place of `node`, so the array doesnt have holes if (filler !== node) { var index = map[node.__mapid] || 0; // getting index of `node`. this is the only place we actually use map. if (index) { map[filler.__mapid] = index; } else { delete map[filler.__mapid]; } list[index] = filler; } delete map[node.__mapid]; } // invariantObservers(observable); // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR remove already removed node2\"); } function queueForUnobservation(observable) { if (!observable.isPendingUnobservation) { // invariant(globalState.inBatch > 0, \"INTERNAL ERROR, remove should be called only inside batch\"); // invariant(observable._observers.length === 0, \"INTERNAL ERROR, shuold only queue for unobservation unobserved observables\"); observable.isPendingUnobservation = true; globalState.pendingUnobservations.push(observable); } } /** * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does. * During a batch `onBecomeUnobserved` will be called at most once per observable. * Avoids unnecessary recalculations. */ function startBatch() { globalState.inBatch++; } function endBatch() { if (--globalState.inBatch === 0) { runReactions(); // the batch is actually about to finish, all unobserving should happen here. var list = globalState.pendingUnobservations; for (var i = 0; i < list.length; i++) { var observable = list[i]; observable.isPendingUnobservation = false; if (observable.observers.length === 0) { observable.onBecomeUnobserved(); // NOTE: onBecomeUnobserved might push to `pendingUnobservations` } } globalState.pendingUnobservations = []; } } function reportObserved(observable) { var derivation = globalState.trackingDerivation; if (derivation !== null) { /** * Simple optimization, give each derivation run an unique id (runId) * Check if last time this observable was accessed the same runId is used * if this is the case, the relation is already known */ if (derivation.runId !== observable.lastAccessedBy) { observable.lastAccessedBy = derivation.runId; derivation.newObserving[derivation.unboundDepsCount++] = observable; } } else if (observable.observers.length === 0) { queueForUnobservation(observable); } } /** * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly * It will propagate changes to observers from previous run * It's hard or maybe impossible (with reasonable perf) to get it right with current approach * Hopefully self reruning autoruns aren't a feature people should depend on * Also most basic use cases should be ok */ // Called by Atom when its value changes function propagateChanged(observable) { // invariantLOS(observable, \"changed start\"); if (observable.lowestObserverState === IDerivationState.STALE) return; observable.lowestObserverState = IDerivationState.STALE; var observers = observable.observers; var i = observers.length; while (i--) { var d = observers[i]; if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale(); d.dependenciesState = IDerivationState.STALE; } // invariantLOS(observable, \"changed end\"); } // Called by ComputedValue when it recalculate and its value changed function propagateChangeConfirmed(observable) { // invariantLOS(observable, \"confirmed start\"); if (observable.lowestObserverState === IDerivationState.STALE) return; observable.lowestObserverState = IDerivationState.STALE; var observers = observable.observers; var i = observers.length; while (i--) { var d = observers[i]; if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE; } // invariantLOS(observable, \"confirmed end\"); } // Used by computed when its dependency changed, but we don't wan't to immediately recompute. function propagateMaybeChanged(observable) { // invariantLOS(observable, \"maybe start\"); if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return; observable.lowestObserverState = IDerivationState.POSSIBLY_STALE; var observers = observable.observers; var i = observers.length; while (i--) { var d = observers[i]; if (d.dependenciesState === IDerivationState.UP_TO_DATE) { d.dependenciesState = IDerivationState.POSSIBLY_STALE; d.onBecomeStale(); } } // invariantLOS(observable, \"maybe end\"); } var IDerivationState; (function (IDerivationState) { // before being run or (outside batch and not being observed) // at this point derivation is not holding any data about dependency tree IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\"; // no shallow dependency changed since last computation // won't recalculate derivation // this is what makes mobx fast IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\"; // some deep dependency changed, but don't know if shallow dependency changed // will require to check first if UP_TO_DATE or POSSIBLY_STALE // currently only ComputedValue will propagate POSSIBLY_STALE // // having this state is second big optimization: // don't have to recompute on every dependency change, but only when it's needed IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\"; // shallow dependency changed // will need to recompute when it's needed IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\"; })(IDerivationState || (exports.IDerivationState = IDerivationState = {})); var CaughtException = function () { function CaughtException(cause) { this.cause = cause; // Empty } return CaughtException; }(); function isCaughtException(e) { return e instanceof CaughtException; } /** * Finds out whether any dependency of the derivation has actually changed. * If dependenciesState is 1 then it will recalculate dependencies, * if any dependency changed it will propagate it by changing dependenciesState to 2. * * By iterating over the dependencies in the same order that they were reported and * stopping on the first change, all the recalculations are only called for ComputedValues * that will be tracked by derivation. That is because we assume that if the first x * dependencies of the derivation doesn't change then the derivation should run the same way * up until accessing x-th dependency. */ function shouldCompute(derivation) { switch (derivation.dependenciesState) { case IDerivationState.UP_TO_DATE: return false; case IDerivationState.NOT_TRACKING: case IDerivationState.STALE: return true; case IDerivationState.POSSIBLY_STALE: { var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction. var obs = derivation.observing, l = obs.length; for (var i = 0; i < l; i++) { var obj = obs[i]; if (isComputedValue(obj)) { try { obj.get(); } catch (e) { // we are not interested in the value *or* exception at this moment, but if there is one, notify all untrackedEnd(prevUntracked); return true; } // if ComputedValue `obj` actually changed it will be computed and propagated to its observers. // and `derivation` is an observer of `obj` if (derivation.dependenciesState === IDerivationState.STALE) { untrackedEnd(prevUntracked); return true; } } } changeDependenciesStateTo0(derivation); untrackedEnd(prevUntracked); return false; } } } function isComputingDerivation() { return globalState.trackingDerivation !== null; // filter out actions inside computations } function checkIfStateModificationsAreAllowed(atom) { var hasObservers$$1 = atom.observers.length > 0; // Should never be possible to change an observed observable from inside computed, see #798 if (globalState.computationDepth > 0 && hasObservers$$1) fail(getMessage(\"m031\") + atom.name); // Should not be possible to change observed state outside strict mode, except during initialization, see #563 if (!globalState.allowStateChanges && hasObservers$$1) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name); } /** * Executes the provided function `f` and tracks which observables are being accessed. * The tracking information is stored on the `derivation` object and the derivation is registered * as observer of any of the accessed observables. */ function trackDerivedFunction(derivation, f, context) { // pre allocate array allocation + room for variation in deps // array will be trimmed by bindDependencies changeDependenciesStateTo0(derivation); derivation.newObserving = new Array(derivation.observing.length + 100); derivation.unboundDepsCount = 0; derivation.runId = ++globalState.runId; var prevTracking = globalState.trackingDerivation; globalState.trackingDerivation = derivation; var result; try { result = f.call(context); } catch (e) { result = new CaughtException(e); } globalState.trackingDerivation = prevTracking; bindDependencies(derivation); return result; } /** * diffs newObserving with observing. * update observing to be newObserving with unique observables * notify observers that become observed/unobserved */ function bindDependencies(derivation) { // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, \"INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1\"); var prevObserving = derivation.observing; var observing = derivation.observing = derivation.newObserving; var lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE; derivation.newObserving = null; // newObserving shouldn't be needed outside tracking // Go through all new observables and check diffValue: (this list can contain duplicates): // 0: first occurrence, change to 1 and keep it // 1: extra occurrence, drop it var i0 = 0, l = derivation.unboundDepsCount; for (var i = 0; i < l; i++) { var dep = observing[i]; if (dep.diffValue === 0) { dep.diffValue = 1; if (i0 !== i) observing[i0] = dep; i0++; } // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined, // not hitting the condition if (dep.dependenciesState > lowestNewObservingDerivationState) { lowestNewObservingDerivationState = dep.dependenciesState; } } observing.length = i0; // Go through all old observables and check diffValue: (it is unique after last bindDependencies) // 0: it's not in new observables, unobserve it // 1: it keeps being observed, don't want to notify it. change to 0 l = prevObserving.length; while (l--) { var dep = prevObserving[l]; if (dep.diffValue === 0) { removeObserver(dep, derivation); } dep.diffValue = 0; } // Go through all new observables and check diffValue: (now it should be unique) // 0: it was set to 0 in last loop. don't need to do anything. // 1: it wasn't observed, let's observe it. set back to 0 while (i0--) { var dep = observing[i0]; if (dep.diffValue === 1) { dep.diffValue = 0; addObserver(dep, derivation); } } // Some new observed derivations might become stale during this derivation computation // so say had no chance to propagate staleness (#916) if (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) { derivation.dependenciesState = lowestNewObservingDerivationState; derivation.onBecomeStale(); } } function clearObserving(derivation) { // invariant(globalState.inBatch > 0, \"INTERNAL ERROR clearObserving should be called only inside batch\"); var obs = derivation.observing; derivation.observing = []; var i = obs.length; while (i--) { removeObserver(obs[i], derivation); }derivation.dependenciesState = IDerivationState.NOT_TRACKING; } function untracked(action) { var prev = untrackedStart(); var res = action(); untrackedEnd(prev); return res; } function untrackedStart() { var prev = globalState.trackingDerivation; globalState.trackingDerivation = null; return prev; } function untrackedEnd(prev) { globalState.trackingDerivation = prev; } /** * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0 * */ function changeDependenciesStateTo0(derivation) { if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return; derivation.dependenciesState = IDerivationState.UP_TO_DATE; var obs = derivation.observing; var i = obs.length; while (i--) { obs[i].lowestObserverState = IDerivationState.UP_TO_DATE; } } var Reaction = function () { function Reaction(name, onInvalidate) { if (name === void 0) { name = \"Reaction@\" + getNextId(); } this.name = name; this.onInvalidate = onInvalidate; this.observing = []; // nodes we are looking at. Our value depends on these nodes this.newObserving = []; this.dependenciesState = IDerivationState.NOT_TRACKING; this.diffValue = 0; this.runId = 0; this.unboundDepsCount = 0; this.__mapid = \"#\" + getNextId(); this.isDisposed = false; this._isScheduled = false; this._isTrackPending = false; this._isRunning = false; } Reaction.prototype.onBecomeStale = function () { this.schedule(); }; Reaction.prototype.schedule = function () { if (!this._isScheduled) { this._isScheduled = true; globalState.pendingReactions.push(this); runReactions(); } }; Reaction.prototype.isScheduled = function () { return this._isScheduled; }; /** * internal, use schedule() if you intend to kick off a reaction */ Reaction.prototype.runReaction = function () { if (!this.isDisposed) { startBatch(); this._isScheduled = false; if (shouldCompute(this)) { this._isTrackPending = true; this.onInvalidate(); if (this._isTrackPending && isSpyEnabled()) { // onInvalidate didn't trigger track right away.. spyReport({ object: this, type: \"scheduled-reaction\" }); } } endBatch(); } }; Reaction.prototype.track = function (fn) { startBatch(); var notify = isSpyEnabled(); var startTime; if (notify) { startTime = Date.now(); spyReportStart({ object: this, type: \"reaction\", fn: fn }); } this._isRunning = true; var result = trackDerivedFunction(this, fn, undefined); this._isRunning = false; this._isTrackPending = false; if (this.isDisposed) { // disposed during last run. Clean up everything that was bound after the dispose call. clearObserving(this); } if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause); if (notify) { spyReportEnd({ time: Date.now() - startTime }); } endBatch(); }; Reaction.prototype.reportExceptionInDerivation = function (error) { var _this = this; if (this.errorHandler) { this.errorHandler(error, this); return; } var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this; var messageToUser = getMessage(\"m037\"); console.error(message || messageToUser /* latter will not be true, make sure uglify doesn't remove */, error); /** If debugging brought you here, please, read the above message :-). Tnx! */ if (isSpyEnabled()) { spyReport({ type: \"error\", message: message, error: error, object: this }); } globalState.globalReactionErrorHandlers.forEach(function (f) { return f(error, _this); }); }; Reaction.prototype.dispose = function () { if (!this.isDisposed) { this.isDisposed = true; if (!this._isRunning) { startBatch(); clearObserving(this); // if disposed while running, clean up later. Maybe not optimal, but rare case endBatch(); } } }; Reaction.prototype.getDisposer = function () { var r = this.dispose.bind(this); r.$mobx = this; r.onError = registerErrorHandler; return r; }; Reaction.prototype.toString = function () { return \"Reaction[\" + this.name + \"]\"; }; Reaction.prototype.whyRun = function () { var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) { return dep.name; }); return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n \" + joinStrings(observing) + \"\\n \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\"; }; return Reaction; }(); function registerErrorHandler(handler) { invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\"); invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\"); this.$mobx.errorHandler = handler; } function onReactionError(handler) { globalState.globalReactionErrorHandlers.push(handler); return function () { var idx = globalState.globalReactionErrorHandlers.indexOf(handler); if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1); }; } /** * Magic number alert! * Defines within how many times a reaction is allowed to re-trigger itself * until it is assumed that this is gonna be a never ending loop... */ var MAX_REACTION_ITERATIONS = 100; var reactionScheduler = function reactionScheduler(f) { return f(); }; function runReactions() { // Trampolining, if runReactions are already running, new reactions will be picked up if (globalState.inBatch > 0 || globalState.isRunningReactions) return; reactionScheduler(runReactionsHelper); } function runReactionsHelper() { globalState.isRunningReactions = true; var allReactions = globalState.pendingReactions; var iterations = 0; // While running reactions, new reactions might be triggered. // Hence we work with two variables and check whether // we converge to no remaining reactions after a while. while (allReactions.length > 0) { if (++iterations === MAX_REACTION_ITERATIONS) { console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0])); allReactions.splice(0); // clear reactions } var remainingReactions = allReactions.splice(0); for (var i = 0, l = remainingReactions.length; i < l; i++) { remainingReactions[i].runReaction(); } } globalState.isRunningReactions = false; } var isReaction = createInstanceofPredicate(\"Reaction\", Reaction); function setReactionScheduler(fn) { var baseScheduler = reactionScheduler; reactionScheduler = function reactionScheduler(f) { return fn(function () { return baseScheduler(f); }); }; } function asReference(value) { deprecated(\"asReference is deprecated, use observable.ref instead\"); return observable.ref(value); } function asStructure(value) { deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\"); return observable.struct(value); } function asFlat(value) { deprecated(\"asFlat is deprecated, use observable.shallow instead\"); return observable.shallow(value); } function asMap(data) { deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\"); return observable.map(data || {}); } function createComputedDecorator(equals) { return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) { invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\")); invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\")); var adm = asObservableObject(target, \"\"); defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, equals, false); }, function (name) { var observable = this.$mobx.values[name]; if (observable === undefined) return undefined; return observable.get(); }, function (name, value) { this.$mobx.values[name].set(value); }, false, false); } var computedDecorator = createComputedDecorator(comparer.default); var computedStructDecorator = createComputedDecorator(comparer.structural); /** * Decorator for class properties: @computed get value() { return expr; }. * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`; */ var computed = function computed(arg1, arg2, arg3) { if (typeof arg2 === \"string\") { return computedDecorator.apply(null, arguments); } invariant(typeof arg1 === \"function\", getMessage(\"m011\")); invariant(arguments.length < 3, getMessage(\"m012\")); var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {}; opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter; var equals = opts.equals ? opts.equals : opts.compareStructural || opts.struct ? comparer.structural : comparer.default; return new ComputedValue(arg1, opts.context, equals, opts.name || arg1.name || \"\", opts.setter); }; computed.struct = computedStructDecorator; computed.equals = createComputedDecorator; function getAtom(thing, property) { if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) { if (isObservableArray(thing)) { invariant(property === undefined, getMessage(\"m036\")); return thing.$mobx.atom; } if (isObservableMap(thing)) { var anyThing = thing; if (property === undefined) return getAtom(anyThing._keys); var observable = anyThing._data[property] || anyThing._hasMap[property]; invariant(!!observable, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\"); return observable; } // Initializers run lazily when transpiling to babel, so make sure they are run... runLazyInitializers(thing); if (property && !thing.$mobx) thing[property]; // See #1072 // TODO: remove in 4.0 if (isObservableObject(thing)) { if (!property) return fail(\"please specify a property\"); var observable = thing.$mobx.values[property]; invariant(!!observable, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\"); return observable; } if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) { return thing; } } else if (typeof thing === \"function\") { if (isReaction(thing.$mobx)) { // disposer function return thing.$mobx; } } return fail(\"Cannot obtain atom from \" + thing); } function getAdministration(thing, property) { invariant(thing, \"Expecting some object\"); if (property !== undefined) return getAdministration(getAtom(thing, property)); if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing; if (isObservableMap(thing)) return thing; // Initializers run lazily when transpiling to babel, so make sure they are run... runLazyInitializers(thing); if (thing.$mobx) return thing.$mobx; invariant(false, \"Cannot obtain administration from \" + thing); } function getDebugName(thing, property) { var named; if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing); // valid for arrays as well return named.name; } function isComputed(value, property) { if (value === null || value === undefined) return false; if (property !== undefined) { if (isObservableObject(value) === false) return false; var atom = getAtom(value, property); return isComputedValue(atom); } return isComputedValue(value); } function observe(thing, propOrCb, cbOrFire, fireImmediately) { if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire); } function observeObservable(thing, listener, fireImmediately) { return getAdministration(thing).observe(listener, fireImmediately); } function observeObservableProperty(thing, property, listener, fireImmediately) { return getAdministration(thing, property).observe(listener, fireImmediately); } function intercept(thing, propOrHandler, handler) { if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler); } function interceptInterceptable(thing, handler) { return getAdministration(thing).intercept(handler); } function interceptProperty(thing, property, handler) { return getAdministration(thing, property).intercept(handler); } /** * expr can be used to create temporarily views inside views. * This can be improved to improve performance if a value changes often, but usually doesn't affect the outcome of an expression. * * In the following example the expression prevents that a component is rerender _each time_ the selection changes; * instead it will only rerenders when the current todo is (de)selected. * * reactiveComponent((props) => { * const todo = props.todo; * const isSelected = mobx.expr(() => props.viewState.selection === todo); * return {todo.title} * }); * */ function expr(expr, scope) { if (!isComputingDerivation()) console.warn(getMessage(\"m013\")); // optimization: would be more efficient if the expr itself wouldn't be evaluated first on the next change, but just a 'changed' signal would be fired return computed(expr, { context: scope }).get(); } function toJS(source, detectCycles, __alreadySeen) { if (detectCycles === void 0) { detectCycles = true; } if (__alreadySeen === void 0) { __alreadySeen = []; } // optimization: using ES6 map would be more efficient! // optimization: lift this function outside toJS, this makes recursion expensive function cache(value) { if (detectCycles) __alreadySeen.push([source, value]); return value; } if (isObservable(source)) { if (detectCycles && __alreadySeen === null) __alreadySeen = []; if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") { for (var i = 0, l = __alreadySeen.length; i < l; i++) { if (__alreadySeen[i][0] === source) return __alreadySeen[i][1]; } } if (isObservableArray(source)) { var res = cache([]); var toAdd = source.map(function (value) { return toJS(value, detectCycles, __alreadySeen); }); res.length = toAdd.length; for (var i = 0, l = toAdd.length; i < l; i++) { res[i] = toAdd[i]; }return res; } if (isObservableObject(source)) { var res = cache({}); for (var key in source) { res[key] = toJS(source[key], detectCycles, __alreadySeen); }return res; } if (isObservableMap(source)) { var res_1 = cache({}); source.forEach(function (value, key) { return res_1[key] = toJS(value, detectCycles, __alreadySeen); }); return res_1; } if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen); } return source; } function createTransformer(transformer, onCleanup) { invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\"); // Memoizes: object id -> reactive view that applies transformer to the object var objectCache = {}; // If the resetId changes, we will clear the object cache, see #163 // This construction is used to avoid leaking refs to the objectCache directly var resetId = globalState.resetId; // Local transformer class specifically for this transformer var Transformer = function (_super) { __extends(Transformer, _super); function Transformer(sourceIdentifier, sourceObject) { var _this = _super.call(this, function () { return transformer(sourceObject); }, undefined, comparer.default, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this; _this.sourceIdentifier = sourceIdentifier; _this.sourceObject = sourceObject; return _this; } Transformer.prototype.onBecomeUnobserved = function () { var lastValue = this.value; _super.prototype.onBecomeUnobserved.call(this); delete objectCache[this.sourceIdentifier]; if (onCleanup) onCleanup(lastValue, this.sourceObject); }; return Transformer; }(ComputedValue); return function (object) { if (resetId !== globalState.resetId) { objectCache = {}; resetId = globalState.resetId; } var identifier = getMemoizationId(object); var reactiveTransformer = objectCache[identifier]; if (reactiveTransformer) return reactiveTransformer.get(); // Not in cache; create a reactive view reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object); return reactiveTransformer.get(); }; } function getMemoizationId(object) { if (typeof object === 'string' || typeof object === 'number') return object; if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object or primitive value, got: \" + object); var tid = object.$transformId; if (tid === undefined) { tid = getNextId(); addHiddenProp(object, \"$transformId\", tid); } return tid; } function log(msg) { console.log(msg); return msg; } function whyRun(thing, prop) { switch (arguments.length) { case 0: thing = globalState.trackingDerivation; if (!thing) return log(getMessage(\"m024\")); break; case 2: thing = getAtom(thing, prop); break; } thing = getAtom(thing); if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun()); return fail(getMessage(\"m025\")); } function getDependencyTree(thing, property) { return nodeToDependencyTree(getAtom(thing, property)); } function nodeToDependencyTree(node) { var result = { name: node.name }; if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree); return result; } function getObserverTree(thing, property) { return nodeToObserverTree(getAtom(thing, property)); } function nodeToObserverTree(node) { var result = { name: node.name }; if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree); return result; } function interceptReads(thing, propOrHandler, handler) { var target; if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) { target = getAdministration(thing); } else if (isObservableObject(thing)) { if (typeof propOrHandler !== \"string\") return fail(\"InterceptReads can only be used with a specific property, not with an object in general\"); target = getAdministration(thing, propOrHandler); } else { return fail(\"Expected observable map, object or array as first array\"); } if (target.dehancer !== undefined) return fail(\"An intercept reader was already established\"); target.dehancer = typeof propOrHandler === \"function\" ? propOrHandler : handler; return function () { target.dehancer = undefined; }; } /** * (c) Michel Weststrate 2015 - 2016 * MIT Licensed * * Welcome to the mobx sources! To get an global overview of how MobX internally works, * this is a good place to start: * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74 * * Source folders: * =============== * * - api/ Most of the public static methods exposed by the module can be found here. * - core/ Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here. * - types/ All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`. * - utils/ Utility stuff. * */ var extras = { allowStateChanges: allowStateChanges, deepEqual: deepEqual, getAtom: getAtom, getDebugName: getDebugName, getDependencyTree: getDependencyTree, getAdministration: getAdministration, getGlobalState: getGlobalState, getObserverTree: getObserverTree, interceptReads: interceptReads, isComputingDerivation: isComputingDerivation, isSpyEnabled: isSpyEnabled, onReactionError: onReactionError, reserveArrayBuffer: reserveArrayBuffer, resetGlobalState: resetGlobalState, isolateGlobalState: isolateGlobalState, shareGlobalState: shareGlobalState, spyReport: spyReport, spyReportEnd: spyReportEnd, spyReportStart: spyReportStart, setReactionScheduler: setReactionScheduler }; var everything = { Reaction: Reaction, untracked: untracked, Atom: Atom, BaseAtom: BaseAtom, useStrict: useStrict, isStrictModeEnabled: isStrictModeEnabled, spy: spy, comparer: comparer, asReference: asReference, asFlat: asFlat, asStructure: asStructure, asMap: asMap, isModifierDescriptor: isModifierDescriptor, isObservableObject: isObservableObject, isBoxedObservable: isObservableValue, isObservableArray: isObservableArray, ObservableMap: ObservableMap, isObservableMap: isObservableMap, map: map, transaction: transaction, observable: observable, computed: computed, isObservable: isObservable, isComputed: isComputed, extendObservable: extendObservable, extendShallowObservable: extendShallowObservable, observe: observe, intercept: intercept, autorun: autorun, autorunAsync: autorunAsync, when: when, reaction: reaction, action: action, isAction: isAction, runInAction: runInAction, expr: expr, toJS: toJS, createTransformer: createTransformer, whyRun: whyRun, isArrayLike: isArrayLike, extras: extras }; var warnedAboutDefaultExport = false; var _loop_1 = function _loop_1(p) { var val = everything[p]; Object.defineProperty(everything, p, { get: function get() { if (!warnedAboutDefaultExport) { warnedAboutDefaultExport = true; console.warn('Using default export (`import mobx from \\'mobx\\'`) is deprecated ' + 'and won’t work in mobx@4.0.0\\n' + 'Use `import * as mobx from \\'mobx\\'` instead'); } return val; } }); }; for (var p in everything) { _loop_1(p); } if ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") { __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({ spy: spy, extras: extras }); } exports.extras = extras; exports.Reaction = Reaction; exports.untracked = untracked; exports.IDerivationState = IDerivationState; exports.Atom = Atom; exports.BaseAtom = BaseAtom; exports.useStrict = useStrict; exports.isStrictModeEnabled = isStrictModeEnabled; exports.spy = spy; exports.comparer = comparer; exports.asReference = asReference; exports.asFlat = asFlat; exports.asStructure = asStructure; exports.asMap = asMap; exports.isModifierDescriptor = isModifierDescriptor; exports.isObservableObject = isObservableObject; exports.isBoxedObservable = isObservableValue; exports.isObservableArray = isObservableArray; exports.ObservableMap = ObservableMap; exports.isObservableMap = isObservableMap; exports.map = map; exports.transaction = transaction; exports.observable = observable; exports.IObservableFactories = IObservableFactories; exports.computed = computed; exports.isObservable = isObservable; exports.isComputed = isComputed; exports.extendObservable = extendObservable; exports.extendShallowObservable = extendShallowObservable; exports.observe = observe; exports.intercept = intercept; exports.autorun = autorun; exports.autorunAsync = autorunAsync; exports.when = when; exports.reaction = reaction; exports.action = action; exports.isAction = isAction; exports.runInAction = runInAction; exports.expr = expr; exports.toJS = toJS; exports.createTransformer = createTransformer; exports.whyRun = whyRun; exports.isArrayLike = isArrayLike; exports.default = everything; /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4))) /***/ }), /* 2 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); var _icons = __webpack_require__(6); var _constants = __webpack_require__(0); var _translator = __webpack_require__(7); var translator = _interopRequireWildcard(_translator); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } var culture = /^([^-]{1,3})(-|$)/; var $ = function $(x) { return (0, translator.default)(x); }; function renderHeader(_ref, instance) { var meta = _ref.meta, user = _ref.user, reactions = _ref.reactions; var container = document.createElement('div'); container.lang = culture.test(instance.lang) ? instance.lang : \"en-US\"; container.className = 'gitment-container gitment-header-container'; var likeButton = document.createElement('span'); var likedReaction = reactions.find(function (reaction) { return reaction.content === 'heart' && reaction.user.login === user.login; }); likeButton.className = 'gitment-header-like-btn'; likeButton.innerHTML = '\\n ' + _icons.heart + '\\n ' + (likedReaction ? 'Unlike' : 'Like') + '\\n ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 ' + meta.reactions.heart + ' Liked' : '') + '\\n '; if (likedReaction) { likeButton.classList.add('liked'); likeButton.onclick = function () { return instance.unlike(); }; } else { likeButton.classList.remove('liked'); likeButton.onclick = function () { return instance.like(); }; } container.appendChild(likeButton); var commentsCount = document.createElement('span'); commentsCount.innerHTML = '\\n ' + (meta.comments ? ' \\u2022 ' + meta.comments + ' Comments' : '') + '\\n '; container.appendChild(commentsCount); var issueLink = document.createElement('a'); issueLink.className = 'gitment-header-issue-link'; issueLink.href = meta.html_url || \"javascript:void(0)\"; issueLink.target = '_blank'; issueLink.innerText = $('Issue Page'); container.appendChild(issueLink); return container; } function renderComments(_ref2, instance) { var meta = _ref2.meta, comments = _ref2.comments, commentReactions = _ref2.commentReactions, currentPage = _ref2.currentPage, user = _ref2.user, error = _ref2.error; var container = document.createElement('div'); container.lang = culture.test(instance.lang) ? instance.lang : \"en-US\"; container.className = 'gitment-container gitment-comments-container'; if (error) { var errorBlock = document.createElement('div'); errorBlock.className = 'gitment-comments-error'; if (error === _constants.NOT_INITIALIZED_ERROR && user.login && ~(instance.admin || [instance.owner]).map(function (x) { return x.toLowerCase(); }).indexOf(user.login.toLowerCase())) { // && user.login.toLowerCase() === instance.owner.toLowerCase()) { var initHint = document.createElement('div'); var initButton = document.createElement('button'); initButton.className = 'gitment-comments-init-btn'; initButton.onclick = function () { initButton.setAttribute('disabled', true); instance.init().catch(function (e) { initButton.removeAttribute('disabled'); alert(e); }); }; initButton.innerText = $('Initialize Comments'); initHint.appendChild(initButton); errorBlock.appendChild(initHint); } else { errorBlock.innerText = $(error); } container.appendChild(errorBlock); return container; } else if (comments === undefined) { var loading = document.createElement('div'); loading.innerText = $('Loading comments...'); loading.className = 'gitment-comments-loading'; container.appendChild(loading); return container; } else if (!comments.length) { var emptyBlock = document.createElement('div'); emptyBlock.className = 'gitment-comments-empty'; emptyBlock.innerText = $('No Comment Yet'); container.appendChild(emptyBlock); return container; } var commentsList = document.createElement('ul'); commentsList.className = 'gitment-comments-list'; comments.forEach(function (comment) { var createDate = new Date(comment.created_at); var updateDate = new Date(comment.updated_at); var commentItem = document.createElement('li'); commentItem.className = 'gitment-comment'; commentItem.innerHTML = '\\n \\n \\n \\n \\n \\n \\n ' + comment.user.login + '\\n \\n commented on\\n ' + createDate.toDateString() + '\\n ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 edited' : '') + '\\n ' + _icons.heart + ' ' + (comment.reactions.heart || '') + '\\n \\n ' + comment.body_html + '\\n \\n '; var likeButton = commentItem.querySelector('.gitment-comment-like-btn'); var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) { return reaction.content === 'heart' && reaction.user.login === user.login; }); if (likedReaction) { likeButton.classList.add('liked'); likeButton.onclick = function () { return instance.unlikeAComment(comment.id); }; } else { likeButton.classList.remove('liked'); likeButton.onclick = function () { return instance.likeAComment(comment.id); }; } // dirty // use a blank image to trigger height calculating when element rendered var imgTrigger = document.createElement('img'); var markdownBody = commentItem.querySelector('.gitment-comment-body'); imgTrigger.className = 'gitment-hidden'; imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"; imgTrigger.onload = function () { if (markdownBody.clientHeight > instance.maxCommentHeight) { markdownBody.classList.add('gitment-comment-body-folded'); markdownBody.style.maxHeight = instance.maxCommentHeight + 'px'; markdownBody.title = 'Click to Expand'; markdownBody.onclick = function () { markdownBody.classList.remove('gitment-comment-body-folded'); markdownBody.style.maxHeight = ''; markdownBody.title = ''; markdownBody.onclick = null; }; } }; commentItem.appendChild(imgTrigger); commentsList.appendChild(commentItem); }); container.appendChild(commentsList); if (meta) { var pageCount = Math.ceil(meta.comments / instance.perPage); if (pageCount > 1) { var pagination = document.createElement('ul'); pagination.className = 'gitment-comments-pagination'; if (currentPage > 1) { var previousButton = document.createElement('li'); previousButton.className = 'gitment-comments-page-item'; previousButton.innerText = $('Previous'); previousButton.onclick = function () { return instance.goto(currentPage - 1); }; pagination.appendChild(previousButton); } var _loop = function _loop(i) { var pageItem = document.createElement('li'); pageItem.className = 'gitment-comments-page-item'; pageItem.innerText = i; pageItem.onclick = function () { return instance.goto(i); }; if (currentPage === i) pageItem.classList.add('gitment-selected'); pagination.appendChild(pageItem); }; for (var i = 1; i 1 && arguments[1] !== undefined ? arguments[1] : '?'; var queryString = Object.keys(query).map(function (key) { return key + '=' + encodeURIComponent(query[key] || ''); }).join('&'); return queryString ? prefix + queryString : ''; } }; function ajaxFactory(method) { return function (apiPath) { var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com'; var req = new XMLHttpRequest(); var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY); if (base !== 'https://api.github.com') token = null; var url = '' + base + apiPath; var body = null; if (method === 'GET' || method === 'DELETE') { url += isString(data) ? data : Query.stringify(data); } var p = new Promise(function (resolve, reject) { req.addEventListener('load', function () { var contentType = req.getResponseHeader('content-type'); var res = req.responseText; var data = res; if (/urlencoded/.test(contentType)) { data = req.responseText ? Query.parse(res) : {}; if (data.error) return reject(new Error(data.error_description)); } else if (/json/.test(contentType)) { data = req.responseText ? JSON.parse(res) : {}; if (data.message) return reject(new Error(data.message)); } resolve(data); }); req.addEventListener('error', function (error) { return reject(error); }); }); req.open(method, url, true); req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json, application/x-www-form-urlencoded'); if (token) { req.setRequestHeader('Authorization', 'token ' + token); } if (method !== 'GET' && method !== 'DELETE') { if (isString(data)) { body = data; req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); } else { body = JSON.stringify(data); req.setRequestHeader('Content-Type', 'application/json'); } } req.send(body); return p; }; } var http = exports.http = { get: ajaxFactory('GET'), post: ajaxFactory('POST'), delete: ajaxFactory('DELETE'), put: ajaxFactory('PUT') }; /***/ }), /* 4 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; var g; // This works in non-strict mode g = function () { return this; }(); try { // This works if eval is allowed (see CSP) g = g || Function(\"return this\")() || (1, eval)(\"this\"); } catch (e) { // This works if the window reference is available if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window; } // g can still be undefined, but nothing to do about it... // We return undefined, instead of nothing here, so it's // easier to handle this case. if(!global) { ...} module.exports = g; /***/ }), /* 5 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _mobx = __webpack_require__(1); var _constants = __webpack_require__(0); var _utils = __webpack_require__(3); var _default = __webpack_require__(2); var _default2 = _interopRequireDefault(_default); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } // @see: https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/about-scopes-for-oauth-apps var scope = 'public_repo'; // Github setting of 'Authorization callback URL' in your OAuth application var force_redirect_protocol = '$&'; // A RegExp to match protocol and domain var rx_url_with_protocol = /^((https?:\\/\\/+){0,1}[^\\/]*)(.*)/; function extendRenderer(instance, renderer) { instance[renderer] = function (container) { var targetContainer = (0, _utils.getTargetContainer)(container); var render = instance.theme[renderer] || instance.defaultTheme[renderer]; (0, _mobx.autorun)(function () { var e = render(instance.state, instance); if (e) { if (targetContainer.firstChild) { targetContainer.replaceChild(e, targetContainer.firstChild); } else { targetContainer.appendChild(e); } } }); return targetContainer; }; } var Gitment = function () { _createClass(Gitment, [{ key: 'accessToken', get: function get() { return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY); }, set: function set(token) { localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token); } }, { key: 'loginLink', get: function get() { var oauthUri = 'https://github.com/login/oauth/authorize'; var redirect_uri = this.oauth.redirect_uri || window.location.href.replace(/^https?/i, this.oauth.redirect_protocol || force_redirect_protocol); var oauthParams = Object.assign({ scope: scope, redirect_uri: redirect_uri }, this.oauth); return '' + oauthUri + _utils.Query.stringify(oauthParams); } }]); function Gitment() { var _this = this; var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, Gitment); this.defaultTheme = _default2.default; this.useTheme(_default2.default); var internalId; Object.defineProperties(this, { 'updateCount': { value: new Function(), writable: true }, 'id': { get: function get() { return internalId; }, set: function set(id) { return internalId = id !== window.location.href ? id : '' + window.location.origin + window.location.pathname + window.location.search; } } }); Object.assign(this, { id: window.location.href, title: window.document.title, link: window.location.href, desc: '', labels: [], theme: _default2.default, oauth: {}, perPage: 20, maxCommentHeight: 250 }, options); this.useTheme(this.theme); var user = {}; try { var userInfo = localStorage.getItem(_constants.LS_USER_KEY); if (this.accessToken && userInfo) { Object.assign(user, JSON.parse(userInfo), { fromCache: true }); } } catch (e) { localStorage.removeItem(_constants.LS_USER_KEY); } this.state = (0, _mobx.observable)({ user: user, error: null, meta: {}, comments: undefined, reactions: [], commentReactions: {}, currentPage: 1 }); // NOTE: the proxy_gateway accept form-urlencoded only!!! // - PHP implement at https://github.com/aimingoo/intersect var query = _utils.Query.parse(); if (query.code) { var _oauth = this.oauth, client_id = _oauth.client_id, client_secret = _oauth.client_secret, proxy_gateway = _oauth.proxy_gateway; var code = query.code; delete query.code; var search = _utils.Query.stringify(query); var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash; history.replaceState({}, '', replacedUrl); Object.assign(this, { id: replacedUrl, link: replacedUrl }, options); this.state.user.isLoggingIn = true; var logging = !proxy_gateway ? _utils.http.post('https://gh-oauth.imsun.net', { code: code, client_id: client_id, client_secret: client_secret }, '') : _utils.http.post('/login/oauth/access_token', 'code=' + code + '&client_id=' + client_id, proxy_gateway); logging.then(function (data) { _this.accessToken = data.access_token; _this.update(); }).catch(function (e) { _this.state.user.isLoggingIn = false; alert(e); }); } else { this.update(); } } _createClass(Gitment, [{ key: 'init', value: function init() { var _this2 = this; return this.createIssue().then(function () { return _this2.loadComments(); }).then(function (comments) { _this2.state.error = null; return comments; }); } }, { key: 'useTheme', value: function useTheme() { var _this3 = this; var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; this.theme = theme; var renderers = Object.keys(this.theme); renderers.forEach(function (renderer) { return extendRenderer(_this3, renderer); }); } }, { key: 'update', value: function update() { var _this4 = this; return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () { return Promise.all([_this4.loadComments().then(function () { return _this4.loadCommentReactions(); }), _this4.loadReactions()]); }).catch(function (e) { return _this4.state.error = e; }); } }, { key: 'markdown', value: function markdown(text) { return _utils.http.post('/markdown', { text: text, mode: 'gfm' }); } }, { key: 'createIssue', value: function createIssue() { var _this5 = this; var id = this.id, owner = this.owner, repo = this.repo, title = this.title, link = this.link, desc = this.desc, labels = this.labels; return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', { title: title, labels: labels.concat(['gitment', id]), body: link + '\\n\\n' + desc }).then(function (meta) { _this5.state.meta = meta; return meta; }); } }, { key: 'getIssue', value: function getIssue() { if (this.state.meta.id) return Promise.resolve(this.state.meta); return this.loadMeta(); } }, { key: 'post', value: function post(body) { var _this6 = this; return this.getIssue().then(function (issue) { var matched = issue.comments_url.match(rx_url_with_protocol); return _utils.http.post(matched[3], { body: body }, matched[1] || undefined); }).then(function (data) { _this6.state.meta.comments++; _this6.updateCount(); var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage); if (_this6.state.currentPage === pageCount) { _this6.state.comments.push(data); } return data; }); } }, { key: 'loadMeta', value: function loadMeta() { var _this7 = this; var id = this.id, owner = this.owner, admin = this.admin, repo = this.repo; return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', { labels: id }).then(function (issues) { if (issues.length) { // recheck creator for organization // - or check 'issue.user.login and issue.user.site_admin' ? var allowed = (admin || [owner]).map(function (x) { return x.toLowerCase(); }); issues = issues.filter(function (issue) { return ~allowed.indexOf(issue.user.login.toLowerCase()); }).sort(function (left, right) { return new Date(left.created_at) - new Date(right.created_at); }); } if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR); _this7.state.meta = issues[0]; _this7.updateCount(); return issues[0]; }); } }, { key: 'loadComments', value: function loadComments() { var _this8 = this; var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage; return this.getIssue().then(function (issue) { var matched = issue.comments_url.match(rx_url_with_protocol); return _utils.http.get(matched[3], { page: page, per_page: _this8.perPage }, matched[1] || undefined); }).then(function (comments) { _this8.state.comments = comments; return comments; }); } }, { key: 'loadUserInfo', value: function loadUserInfo() { var _this9 = this; if (!this.accessToken) { this.logout(); return Promise.resolve({}); } return _utils.http.get('/user').then(function (user) { _this9.state.user = user; localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user)); return user; }); } }, { key: 'loadReactions', value: function loadReactions() { var _this10 = this; if (!this.accessToken) { this.state.reactions = []; return Promise.resolve([]); } return this.getIssue().then(function (issue) { if (!issue.reactions.total_count) return []; return _utils.http.get(issue.reactions.url, {}, ''); }).then(function (reactions) { _this10.state.reactions = reactions; return reactions; }); } }, { key: 'loadCommentReactions', value: function loadCommentReactions() { var _this11 = this; if (!this.accessToken) { this.state.commentReactions = {}; return Promise.resolve([]); } var comments = this.state.comments; var comentReactions = {}; return Promise.all(comments.map(function (comment) { if (!comment.reactions.total_count) return []; var owner = _this11.owner, repo = _this11.repo; return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {}); })).then(function (reactionsArray) { comments.forEach(function (comment, index) { comentReactions[comment.id] = reactionsArray[index]; }); _this11.state.commentReactions = comentReactions; return comentReactions; }); } }, { key: 'login', value: function login() { window.location.href = this.loginLink; } }, { key: 'logout', value: function logout() { localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY); localStorage.removeItem(_constants.LS_USER_KEY); this.state.user = {}; } }, { key: 'goto', value: function goto(page) { this.state.currentPage = page; this.state.comments = undefined; return this.loadComments(page); } }, { key: 'like', value: function like() { var _this12 = this; if (!this.accessToken) { alert('Login to Like'); return Promise.reject(); } var owner = this.owner, repo = this.repo; return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', { content: 'heart' }).then(function (reaction) { _this12.state.reactions.push(reaction); _this12.state.meta.reactions.heart++; }); } }, { key: 'unlike', value: function unlike() { var _this13 = this; if (!this.accessToken) return Promise.reject(); var _state = this.state, user = _state.user, reactions = _state.reactions; var index = reactions.findIndex(function (reaction) { return reaction.user.login === user.login; }); return _utils.http.delete('/reactions/' + reactions[index].id).then(function () { reactions.splice(index, 1); _this13.state.meta.reactions.heart--; }); } }, { key: 'likeAComment', value: function likeAComment(commentId) { var _this14 = this; if (!this.accessToken) { alert('Login to Like'); return Promise.reject(); } var owner = this.owner, repo = this.repo; var comment = this.state.comments.find(function (comment) { return comment.id === commentId; }); return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', { content: 'heart' }).then(function (reaction) { _this14.state.commentReactions[commentId].push(reaction); comment.reactions.heart++; }); } }, { key: 'unlikeAComment', value: function unlikeAComment(commentId) { if (!this.accessToken) return Promise.reject(); var reactions = this.state.commentReactions[commentId]; var comment = this.state.comments.find(function (comment) { return comment.id === commentId; }); var user = this.state.user; var index = reactions.findIndex(function (reaction) { return reaction.user.login === user.login; }); return _utils.http.delete('/reactions/' + reactions[index].id).then(function () { reactions.splice(index, 1); comment.reactions.heart--; }); } }]); return Gitment; }(); module.exports = Gitment; /***/ }), /* 6 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); /** * Modified from https://github.com/evil-icons/evil-icons */ var close = exports.close = ''; var github = exports.github = ''; var heart = exports.heart = ''; var spinner = exports.spinner = ''; /***/ }), /* 7 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); exports.english = english; exports.chinese = chinese; exports.chineseTraditional = chineseTraditional; exports.fromLanguageCode = fromLanguageCode; function english(Text) { return Text; } function chinese(Text) { return { 'Issue Page': '所有评论', 'Initialize Comments': '初始化本文的评论页', 'Loading comments...': '加载评论...', 'Error: Comments Not Initialized': '(未开放评论)', 'No Comment Yet': '(还没有评论)', 'Previous': '上一页', 'Next': '下一页', 'Nothing to preview': '（没有预览）', 'Loading preview...': '加载预览...', 'Submitting...': '正在提交评论...', 'Comment': '发送', 'Write': '评论', 'Preview': '预览', 'Logging in...': '登入中...', 'Login to Comment': '请登入以发表评论', 'Leave a comment': '(发表评论)', 'Login': '登入', 'Logout': '退出' }[Text] || Text; } function chineseTraditional(Text) { return { 'Issue Page': '所有評論', 'Initialize Comments': '初始化本文的評論頁', 'Loading comments...': '加載評論...', 'Error: Comments Not Initialized': '(未開放評論)', 'No Comment Yet': '(還沒有評論)', 'Previous': '上一頁', 'Next': '下一頁', 'Nothing to preview': '（沒有預覽）', 'Loading preview...': '加載預覽...', 'Submitting...': '正在提交評論...', 'Comment': '發送', 'Write': '評論', 'Preview': '預覽', 'Logging in...': '登入中...', 'Login to Comment': '請登入以發表評論', 'Leave a comment': '(發表評論)', 'Login': '登入', 'Logout': '登出' }[Text] || Text; } // @see: // https://www.w3.org/TR/1999/REC-html401-19991224/struct/dirlang.html#h-8.1.1 // https://gist.github.com/JamieMason/3748498 function fromLanguageCode(code) { var culture = /^([^-]+)-/; return { 'en': english, 'zh': chinese, 'zh-CN': chinese, 'zh-CHS': chinese, 'zh-TW': chineseTraditional, 'zh-HK': chineseTraditional, 'zh-CHT': chineseTraditional, 'en-US': english }[code] || culture.test(code) && fromLanguageCode(code.match(culture)[1]) || english; } exports.default = english; /***/ }) /******/ ]); //# sourceMappingURL=gitmint.browser.js.map"},{"title":"关于","date":"2023-08-30T01:59:32.888Z","updated":"2023-08-30T01:59:32.888Z","comments":true,"path":"about/index.html","permalink":"https://lchml.com/about/index.html","excerpt":"","text":"Nickname: 九歌 Email: licheng_xd@163.com Github: @licheng-xd 微博: @李城LC 秦时明月，罗小黑战记，刺客伍六七，天行九歌，我的三体，灵笼，一人之下，不良人，雾山五行"},{"title":"","date":"2022-05-12T00:55:13.375Z","updated":"2018-10-25T09:29:27.000Z","comments":true,"path":"gitmint.default.css","permalink":"https://lchml.com/gitmint.default.css","excerpt":"","text":".gitment-container { font-family: sans-serif; font-size: 14px; line-height: 1.5; color: #333; word-wrap: break-word; } .gitment-container * { box-sizing: border-box; } .gitment-container *:disabled { cursor: not-allowed; } .gitment-container a, .gitment-container a:visited { cursor: pointer; text-decoration: none; } .gitment-container a:hover { text-decoration: underline; } .gitment-container .gitment-hidden { display: none; } .gitment-container .gitment-spinner-icon { fill: #333; -webkit-animation: gitment-spin 1s steps(12) infinite; animation: gitment-spin 1s steps(12) infinite; } @-webkit-keyframes gitment-spin { 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg) } } @keyframes gitment-spin { 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg) } } .gitment-root-container { margin: 19px 0; } .gitment-header-container { margin: 19px 0; } .gitment-header-like-btn, .gitment-comment-like-btn { cursor: pointer; } .gitment-comment-like-btn { float: right; } .gitment-comment-like-btn.liked { color: #F44336; } .gitment-header-like-btn svg { vertical-align: middle; height: 30px; } .gitment-comment-like-btn svg { vertical-align: middle; height: 20px; } .gitment-header-like-btn.liked svg, .gitment-comment-like-btn.liked svg { fill: #F44336; } a.gitment-header-issue-link, a.gitment-header-issue-link:visited { float: right; line-height: 30px; color: #666; } a.gitment-header-issue-link:hover { color: #666; } .gitment-comments-loading, .gitment-comments-error, .gitment-comments-empty { text-align: center; margin: 50px 0; } .gitment-comments-list { list-style: none; padding-left: 0; margin: 0 0 38px; } .gitment-comment, .gitment-editor-container { position: relative; min-height: 60px; padding-left: 60px; margin: 19px 0; } .gitment-comment-avatar, .gitment-editor-avatar { float: left; margin-left: -60px; } .gitment-comment-avatar, .gitment-comment-avatar-img, .gitment-comment-avatar, .gitment-editor-avatar-img, .gitment-editor-avatar svg { width: 44px; height: 44px; border-radius: 3px; } .gitment-editor-avatar .gitment-github-icon { fill: #fff; background-color: #333; } .gitment-comment-main, .gitment-editor-main { position: relative; border: 1px solid #CFD8DC; border-radius: 0; } .gitment-editor-main::before, .gitment-editor-main::after, .gitment-comment-main::before, .gitment-comment-main::after { position: absolute; top: 11px; left: -16px; display: block; width: 0; height: 0; pointer-events: none; content: \"\"; border-color: transparent; border-style: solid solid outset; } .gitment-editor-main::before, .gitment-comment-main::before { border-width: 8px; border-right-color: #CFD8DC; } .gitment-editor-main::after, .gitment-comment-main::after { margin-top: 1px; margin-left: 2px; border-width: 7px; border-right-color: #fff; } .gitment-comment-header { margin: 12px 15px; color: #666; background-color: #fff; border-radius: 3px; } .gitment-editor-header { padding: 0; margin: 0; border-bottom: 1px solid #CFD8DC; } a.gitment-comment-name, a.gitment-comment-name:visited { font-weight: 600; color: #666; } .gitment-editor-tabs { margin-bottom: -1px; margin-left: -1px; } .gitment-editor-tab { display: inline-block; padding: 11px 12px; font-size: 14px; line-height: 20px; color: #666; text-decoration: none; background-color: transparent; border-width: 0 1px; border-style: solid; border-color: transparent; border-radius: 0; white-space: nowrap; cursor: pointer; user-select: none; outline: none; } .gitment-editor-tab.gitment-selected { color: #333; background-color: #fff; border-color: #CFD8DC; } .gitment-editor-login { float: right; margin-top: -30px; margin-right: 15px; } a.gitment-footer-project-link, a.gitment-footer-project-link:visited, a.gitment-editor-login-link, a.gitment-editor-login-link:visited { color: #2196F3; } a.gitment-editor-logout-link, a.gitment-editor-logout-link:visited { color: #666; } a.gitment-editor-logout-link:hover { color: #2196F3; text-decoration: none; } .gitment-comment-body { position: relative; margin: 12px 15px; overflow: hidden; border-radius: 3px; } .gitment-comment-body-folded { cursor: pointer; } .gitment-comment-body-folded::before { display: block !important; content: \"\"; position: absolute; width: 100%; left: 0; top: 0; bottom: 50px; pointer-events: none; background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9)); background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9)); } .gitment-comment-body-folded::after { display: block !important; content: \"Click to Expand\" !important; text-align: center; color: #666; position: absolute; width: 100%; height: 50px; line-height: 50px; left: 0; bottom: 0; pointer-events: none; background: rgba(255, 255, 255, .9); } .gitment-editor-body { margin: 0; } .gitment-comment-body > *:first-child, .gitment-editor-preview > *:first-child { margin-top: 0 !important; } .gitment-comment-body > *:last-child, .gitment-editor-preview > *:last-child { margin-bottom: 0 !important; } .gitment-editor-body textarea { display: block; width: 100%; min-height: 150px; max-height: 500px; padding: 16px; resize: vertical; max-width: 100%; margin: 0; font-size: 14px; line-height: 1.6; background-color: #fff; color: #333; vertical-align: middle; border: none; border-radius: 0; outline: none; box-shadow: none; overflow: visible; } .gitment-editor-body textarea:focus { background-color: #fff; } .gitment-editor-preview { min-height: 150px; padding: 16px; background-color: transparent; width: 100%; font-size: 14px; line-height: 1.5; word-wrap: break-word; } .gitment-editor-footer { padding: 0; margin-top: 10px; } .gitment-editor-footer::after { display: table; clear: both; content: \"\"; } a.gitment-editor-footer-tip { display: inline-block; padding-top: 10px; font-size: 12px; color: #666; } a.gitment-editor-footer-tip:hover { color: #2196F3; text-decoration: none; } .gitment-comments-pagination { list-style: none; text-align: right; border-radius: 0; margin: -19px 0 19px 0; } .gitment-comments-page-item { display: inline-block; cursor: pointer; border: 1px solid #CFD8DC; margin-left: -1px; padding: .25rem .5rem; } .gitment-comments-page-item:hover { background-color: #f5f5f5; } .gitment-comments-page-item.gitment-selected { background-color: #f5f5f5; } .gitment-editor-submit, .gitment-comments-init-btn { color: #fff; background-color: #00BCD4; position: relative; display: inline-block; padding: 7px 13px; font-size: 14px; font-weight: 600; line-height: 20px; white-space: nowrap; vertical-align: middle; cursor: pointer; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; background-size: 110% 110%; border: none; -webkit-appearance: none; -moz-appearance: none; appearance: none; } .gitment-editor-submit:hover, .gitment-comments-init-btn:hover { background-color: #00ACC1; } .gitment-comments-init-btn:disabled, .gitment-editor-submit:disabled { color: rgba(255,255,255,0.75); background-color: #4DD0E1; box-shadow: none; } .gitment-editor-submit { float: right; } .gitment-footer-container { margin-top: 30px; margin-bottom: 20px; text-align: right; font-size: 12px; } /* * Markdown CSS * Copied from https://github.com/sindresorhus/github-markdown-css */ .gitment-markdown { -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; line-height: 1.5; color: #333; font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; font-size: 16px; line-height: 1.5; word-wrap: break-word; } .gitment-markdown .pl-c { color: #969896; } .gitment-markdown .pl-c1, .gitment-markdown .pl-s .pl-v { color: #0086b3; } .gitment-markdown .pl-e, .gitment-markdown .pl-en { color: #795da3; } .gitment-markdown .pl-smi, .gitment-markdown .pl-s .pl-s1 { color: #333; } .gitment-markdown .pl-ent { color: #63a35c; } .gitment-markdown .pl-k { color: #a71d5d; } .gitment-markdown .pl-s, .gitment-markdown .pl-pds, .gitment-markdown .pl-s .pl-pse .pl-s1, .gitment-markdown .pl-sr, .gitment-markdown .pl-sr .pl-cce, .gitment-markdown .pl-sr .pl-sre, .gitment-markdown .pl-sr .pl-sra { color: #183691; } .gitment-markdown .pl-v, .gitment-markdown .pl-smw { color: #ed6a43; } .gitment-markdown .pl-bu { color: #b52a1d; } .gitment-markdown .pl-ii { color: #f8f8f8; background-color: #b52a1d; } .gitment-markdown .pl-c2 { color: #f8f8f8; background-color: #b52a1d; } .gitment-markdown .pl-c2::before { content: \"^M\"; } .gitment-markdown .pl-sr .pl-cce { font-weight: bold; color: #63a35c; } .gitment-markdown .pl-ml { color: #693a17; } .gitment-markdown .pl-mh, .gitment-markdown .pl-mh .pl-en, .gitment-markdown .pl-ms { font-weight: bold; color: #1d3e81; } .gitment-markdown .pl-mq { color: #008080; } .gitment-markdown .pl-mi { font-style: italic; color: #333; } .gitment-markdown .pl-mb { font-weight: bold; color: #333; } .gitment-markdown .pl-md { color: #bd2c00; background-color: #ffecec; } .gitment-markdown .pl-mi1 { color: #55a532; background-color: #eaffea; } .gitment-markdown .pl-mc { color: #ef9700; background-color: #ffe3b4; } .gitment-markdown .pl-mi2 { color: #d8d8d8; background-color: #808080; } .gitment-markdown .pl-mdr { font-weight: bold; color: #795da3; } .gitment-markdown .pl-mo { color: #1d3e81; } .gitment-markdown .pl-ba { color: #595e62; } .gitment-markdown .pl-sg { color: #c0c0c0; } .gitment-markdown .pl-corl { text-decoration: underline; color: #183691; } .gitment-markdown .octicon { display: inline-block; vertical-align: text-top; fill: currentColor; } .gitment-markdown a { background-color: transparent; -webkit-text-decoration-skip: objects; } .gitment-markdown a:active, .gitment-markdown a:hover { outline-width: 0; } .gitment-markdown strong { font-weight: inherit; } .gitment-markdown strong { font-weight: bolder; } .gitment-markdown h1 { font-size: 2em; margin: 0.67em 0; } .gitment-markdown img { border-style: none; } .gitment-markdown svg:not(:root) { overflow: hidden; } .gitment-markdown code, .gitment-markdown kbd, .gitment-markdown pre { font-family: monospace, monospace; font-size: 1em; } .gitment-markdown hr { box-sizing: content-box; height: 0; overflow: visible; } .gitment-markdown input { font: inherit; margin: 0; } .gitment-markdown input { overflow: visible; } .gitment-markdown [type=\"checkbox\"] { box-sizing: border-box; padding: 0; } .gitment-markdown * { box-sizing: border-box; } .gitment-markdown input { font-family: inherit; font-size: inherit; line-height: inherit; } .gitment-markdown a { color: #0366d6; text-decoration: none; } .gitment-markdown a:hover { text-decoration: underline; } .gitment-markdown strong { font-weight: 600; } .gitment-markdown hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #dfe2e5; } .gitment-markdown hr::before { display: table; content: \"\"; } .gitment-markdown hr::after { display: table; clear: both; content: \"\"; } .gitment-markdown table { border-spacing: 0; border-collapse: collapse; } .gitment-markdown td, .gitment-markdown th { padding: 0; } .gitment-markdown h1, .gitment-markdown h2, .gitment-markdown h3, .gitment-markdown h4, .gitment-markdown h5, .gitment-markdown h6 { margin-top: 0; margin-bottom: 0; } .gitment-markdown h1 { font-size: 32px; font-weight: 600; } .gitment-markdown h2 { font-size: 24px; font-weight: 600; } .gitment-markdown h3 { font-size: 20px; font-weight: 600; } .gitment-markdown h4 { font-size: 16px; font-weight: 600; } .gitment-markdown h5 { font-size: 14px; font-weight: 600; } .gitment-markdown h6 { font-size: 12px; font-weight: 600; } .gitment-markdown p { margin-top: 0; margin-bottom: 10px; } .gitment-markdown blockquote { margin: 0; } .gitment-markdown ul, .gitment-markdown ol { padding-left: 0; margin-top: 0; margin-bottom: 0; } .gitment-markdown ol ol, .gitment-markdown ul ol { list-style-type: lower-roman; } .gitment-markdown ul ul ol, .gitment-markdown ul ol ol, .gitment-markdown ol ul ol, .gitment-markdown ol ol ol { list-style-type: lower-alpha; } .gitment-markdown dd { margin-left: 0; } .gitment-markdown code { font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; font-size: 12px; } .gitment-markdown pre { margin-top: 0; margin-bottom: 0; font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; } .gitment-markdown .octicon { vertical-align: text-bottom; } .gitment-markdown .pl-0 { padding-left: 0 !important; } .gitment-markdown .pl-1 { padding-left: 4px !important; } .gitment-markdown .pl-2 { padding-left: 8px !important; } .gitment-markdown .pl-3 { padding-left: 16px !important; } .gitment-markdown .pl-4 { padding-left: 24px !important; } .gitment-markdown .pl-5 { padding-left: 32px !important; } .gitment-markdown .pl-6 { padding-left: 40px !important; } .gitment-markdown::before { display: table; content: \"\"; } .gitment-markdown::after { display: table; clear: both; content: \"\"; } .gitment-markdown>*:first-child { margin-top: 0 !important; } .gitment-markdown>*:last-child { margin-bottom: 0 !important; } .gitment-markdown a:not([href]) { color: inherit; text-decoration: none; } .gitment-markdown .anchor { float: left; padding-right: 4px; margin-left: -20px; line-height: 1; } .gitment-markdown .anchor:focus { outline: none; } .gitment-markdown p, .gitment-markdown blockquote, .gitment-markdown ul, .gitment-markdown ol, .gitment-markdown dl, .gitment-markdown table, .gitment-markdown pre { margin-top: 0; margin-bottom: 16px; } .gitment-markdown hr { height: 0.25em; padding: 0; margin: 24px 0; background-color: #e1e4e8; border: 0; } .gitment-markdown blockquote { padding: 0 1em; color: #6a737d; border-left: 0.25em solid #dfe2e5; } .gitment-markdown blockquote>:first-child { margin-top: 0; } .gitment-markdown blockquote>:last-child { margin-bottom: 0; } .gitment-markdown kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: #444d56; vertical-align: middle; background-color: #fafbfc; border: solid 1px #c6cbd1; border-bottom-color: #959da5; border-radius: 0; box-shadow: inset 0 -1px 0 #959da5; } .gitment-markdown h1, .gitment-markdown h2, .gitment-markdown h3, .gitment-markdown h4, .gitment-markdown h5, .gitment-markdown h6 { margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; } .gitment-markdown h1 .octicon-link, .gitment-markdown h2 .octicon-link, .gitment-markdown h3 .octicon-link, .gitment-markdown h4 .octicon-link, .gitment-markdown h5 .octicon-link, .gitment-markdown h6 .octicon-link { color: #1b1f23; vertical-align: middle; visibility: hidden; } .gitment-markdown h1:hover .anchor, .gitment-markdown h2:hover .anchor, .gitment-markdown h3:hover .anchor, .gitment-markdown h4:hover .anchor, .gitment-markdown h5:hover .anchor, .gitment-markdown h6:hover .anchor { text-decoration: none; } .gitment-markdown h1:hover .anchor .octicon-link, .gitment-markdown h2:hover .anchor .octicon-link, .gitment-markdown h3:hover .anchor .octicon-link, .gitment-markdown h4:hover .anchor .octicon-link, .gitment-markdown h5:hover .anchor .octicon-link, .gitment-markdown h6:hover .anchor .octicon-link { visibility: visible; } .gitment-markdown h1 { padding-bottom: 0.3em; font-size: 2em; border-bottom: 1px solid #eaecef; } .gitment-markdown h2 { padding-bottom: 0.3em; font-size: 1.5em; border-bottom: 1px solid #eaecef; } .gitment-markdown h3 { font-size: 1.25em; } .gitment-markdown h4 { font-size: 1em; } .gitment-markdown h5 { font-size: 0.875em; } .gitment-markdown h6 { font-size: 0.85em; color: #6a737d; } .gitment-markdown ul, .gitment-markdown ol { padding-left: 2em; } .gitment-markdown ul ul, .gitment-markdown ul ol, .gitment-markdown ol ol, .gitment-markdown ol ul { margin-top: 0; margin-bottom: 0; } .gitment-markdown li>p { margin-top: 16px; } .gitment-markdown li+li { margin-top: 0.25em; } .gitment-markdown dl { padding: 0; } .gitment-markdown dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: 600; } .gitment-markdown dl dd { padding: 0 16px; margin-bottom: 16px; } .gitment-markdown table { display: block; width: 100%; overflow: auto; } .gitment-markdown table th { font-weight: 600; } .gitment-markdown table th, .gitment-markdown table td { padding: 6px 13px; border: 1px solid #dfe2e5; } .gitment-markdown table tr { background-color: #fff; border-top: 1px solid #c6cbd1; } .gitment-markdown table tr:nth-child(2n) { background-color: #f5f5f5; } .gitment-markdown img { max-width: 100%; box-sizing: content-box; background-color: #fff; } .gitment-markdown code { padding: 0; padding-top: 0.2em; padding-bottom: 0.2em; margin: 0; font-size: 85%; background-color: rgba(27,31,35,0.05); border-radius: 0; } .gitment-markdown code::before, .gitment-markdown code::after { letter-spacing: -0.2em; content: \"\\00a0\"; } .gitment-markdown pre { word-wrap: normal; } .gitment-markdown pre>code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } .gitment-markdown .highlight { margin-bottom: 16px; } .gitment-markdown .highlight pre { margin-bottom: 0; word-break: normal; } .gitment-markdown .highlight pre, .gitment-markdown pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f5f5f5; border-radius: 0; } .gitment-markdown pre code { display: inline; max-width: auto; padding: 0; margin: 0; overflow: visible; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; } .gitment-markdown pre code::before, .gitment-markdown pre code::after { content: normal; } .gitment-markdown .full-commit .btn-outline:not(:disabled):hover { color: #005cc5; border-color: #005cc5; } .gitment-markdown kbd { display: inline-block; padding: 3px 5px; font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; line-height: 10px; color: #444d56; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #c6cbd1; border-bottom-color: #959da5; border-radius: 0; box-shadow: inset 0 -1px 0 #959da5; } .gitment-markdown :checked+.radio-label { position: relative; z-index: 1; border-color: #0366d6; } .gitment-markdown .task-list-item { list-style-type: none; } .gitment-markdown .task-list-item+.task-list-item { margin-top: 3px; } .gitment-markdown .task-list-item input { margin: 0 0.2em 0.25em -1.6em; vertical-align: middle; } .gitment-markdown hr { border-bottom-color: #eee; }"},{"title":"categories","date":"2018-07-19T06:41:43.000Z","updated":"2018-07-19T06:41:58.000Z","comments":true,"path":"categories/index.html","permalink":"https://lchml.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-12T00:55:13.369Z","updated":"2018-10-25T09:29:51.000Z","comments":true,"path":"gitmint.browser.js","permalink":"https://lchml.com/gitmint.browser.js","excerpt":"","text":"var Gitmint = /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) { /******/ return installedModules[moduleId].exports; /******/ } /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ i: moduleId, /******/ l: false, /******/ exports: {} /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.l = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // identity function for calling harmony imports with the correct context /******/ __webpack_require__.i = function(value) { return value; }; /******/ /******/ // define getter function for harmony exports /******/ __webpack_require__.d = function(exports, name, getter) { /******/ if(!__webpack_require__.o(exports, name)) { /******/ Object.defineProperty(exports, name, { /******/ configurable: false, /******/ enumerable: true, /******/ get: getter /******/ }); /******/ } /******/ }; /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules /******/ __webpack_require__.n = function(module) { /******/ var getter = module && module.__esModule ? /******/ function getDefault() { return module['default']; } : /******/ function getModuleExports() { return module; }; /******/ __webpack_require__.d(getter, 'a', getter); /******/ return getter; /******/ }; /******/ /******/ // Object.prototype.hasOwnProperty.call /******/ __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(__webpack_require__.s = 5); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); var LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token'; var LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info'; var NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized'); /***/ }), /* 1 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; /* WEBPACK VAR INJECTION */(function(global) { Object.defineProperty(exports, \"__esModule\", { value: true }); var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /** MobX - (c) Michel Weststrate 2015, 2016 - MIT Licensed */ /*! ***************************************************************************** Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. See the Apache Version 2.0 License for specific language governing permissions and limitations under the License. ***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; } || function (d, b) { for (var p in b) { if (b.hasOwnProperty(p)) d[p] = b[p]; } }; function __extends(d, b) { extendStatics(d, b); function __() { this.constructor = d; } d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __()); } /** * Anything that can be used to _store_ state is an Atom in mobx. Atoms have two important jobs * * 1) detect when they are being _used_ and report this (using reportObserved). This allows mobx to make the connection between running functions and the data they used * 2) they should notify mobx whenever they have _changed_. This way mobx can re-run any functions (derivations) that are using this atom. */ var BaseAtom = function () { /** * Create a new atom. For debugging purposes it is recommended to give it a name. * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management. */ function BaseAtom(name) { if (name === void 0) { name = \"Atom@\" + getNextId(); } this.name = name; this.isPendingUnobservation = true; // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed this.observers = []; this.observersIndexes = {}; this.diffValue = 0; this.lastAccessedBy = 0; this.lowestObserverState = IDerivationState.NOT_TRACKING; } BaseAtom.prototype.onBecomeUnobserved = function () { // noop }; /** * Invoke this method to notify mobx that your atom has been used somehow. */ BaseAtom.prototype.reportObserved = function () { reportObserved(this); }; /** * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate. */ BaseAtom.prototype.reportChanged = function () { startBatch(); propagateChanged(this); endBatch(); }; BaseAtom.prototype.toString = function () { return this.name; }; return BaseAtom; }(); var Atom = function (_super) { __extends(Atom, _super); /** * Create a new atom. For debugging purposes it is recommended to give it a name. * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management. */ function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) { if (name === void 0) { name = \"Atom@\" + getNextId(); } if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; } if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; } var _this = _super.call(this, name) || this; _this.name = name; _this.onBecomeObservedHandler = onBecomeObservedHandler; _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler; _this.isPendingUnobservation = false; // for effective unobserving. _this.isBeingTracked = false; return _this; } Atom.prototype.reportObserved = function () { startBatch(); _super.prototype.reportObserved.call(this); if (!this.isBeingTracked) { this.isBeingTracked = true; this.onBecomeObservedHandler(); } endBatch(); return !!globalState.trackingDerivation; // return doesn't really give useful info, because it can be as well calling computed which calls atom (no reactions) // also it could not trigger when calculating reaction dependent on Atom because Atom's value was cached by computed called by given reaction. }; Atom.prototype.onBecomeUnobserved = function () { this.isBeingTracked = false; this.onBecomeUnobservedHandler(); }; return Atom; }(BaseAtom); var isAtom = createInstanceofPredicate(\"Atom\", BaseAtom); function hasInterceptors(interceptable) { return interceptable.interceptors && interceptable.interceptors.length > 0; } function registerInterceptor(interceptable, handler) { var interceptors = interceptable.interceptors || (interceptable.interceptors = []); interceptors.push(handler); return once(function () { var idx = interceptors.indexOf(handler); if (idx !== -1) interceptors.splice(idx, 1); }); } function interceptChange(interceptable, change) { var prevU = untrackedStart(); try { var interceptors = interceptable.interceptors; if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) { change = interceptors[i](change); invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\"); if (!change) break; } return change; } finally { untrackedEnd(prevU); } } function hasListeners(listenable) { return listenable.changeListeners && listenable.changeListeners.length > 0; } function registerListener(listenable, handler) { var listeners = listenable.changeListeners || (listenable.changeListeners = []); listeners.push(handler); return once(function () { var idx = listeners.indexOf(handler); if (idx !== -1) listeners.splice(idx, 1); }); } function notifyListeners(listenable, change) { var prevU = untrackedStart(); var listeners = listenable.changeListeners; if (!listeners) return; listeners = listeners.slice(); for (var i = 0, l = listeners.length; i < l; i++) { listeners[i](change); } untrackedEnd(prevU); } function isSpyEnabled() { return !!globalState.spyListeners.length; } function spyReport(event) { if (!globalState.spyListeners.length) return; var listeners = globalState.spyListeners; for (var i = 0, l = listeners.length; i < l; i++) { listeners[i](event); } } function spyReportStart(event) { var change = objectAssign({}, event, { spyReportStart: true }); spyReport(change); } var END_EVENT = { spyReportEnd: true }; function spyReportEnd(change) { if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT); } function spy(listener) { globalState.spyListeners.push(listener); return once(function () { var idx = globalState.spyListeners.indexOf(listener); if (idx !== -1) globalState.spyListeners.splice(idx, 1); }); } function iteratorSymbol() { return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\"; } var IS_ITERATING_MARKER = \"__$$iterating\"; function arrayAsIterator(array) { // returning an array for entries(), values() etc for maps was a mis-interpretation of the specs.., // yet it is quite convenient to be able to use the response both as array directly and as iterator // it is suboptimal, but alas... invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\"); addHiddenFinalProp(array, IS_ITERATING_MARKER, true); var idx = -1; addHiddenFinalProp(array, \"next\", function next() { idx++; return { done: idx >= this.length, value: idx < this.length ? this[idx] : undefined }; }); return array; } function declareIterator(prototType, iteratorFactory) { addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory); } var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859 // Detects bug in safari 9.1.1 (or iOS 9 safari mobile). See #364 var safariPrototypeSetterInheritanceBug = function () { var v = false; var p = {}; Object.defineProperty(p, \"0\", { set: function set() { v = true; } }); Object.create(p)[\"0\"] = 1; return v === false; }(); /** * This array buffer contains two lists of properties, so that all arrays * can recycle their property definitions, which significantly improves performance of creating * properties on the fly. */ var OBSERVABLE_ARRAY_BUFFER_SIZE = 0; // Typescript workaround to make sure ObservableArray extends Array var StubArray = function () { function StubArray() {} return StubArray; }(); function inherit(ctor, proto) { if (typeof Object[\"setPrototypeOf\"] !== \"undefined\") { Object[\"setPrototypeOf\"](ctor.prototype, proto); } else if (typeof ctor.prototype.__proto__ !== \"undefined\") { ctor.prototype.__proto__ = proto; } else { ctor[\"prototype\"] = proto; } } inherit(StubArray, Array.prototype); var ObservableArrayAdministration = function () { function ObservableArrayAdministration(name, enhancer, array, owned) { this.array = array; this.owned = owned; this.values = []; this.lastKnownLength = 0; this.interceptors = null; this.changeListeners = null; this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId()); this.enhancer = function (newV, oldV) { return enhancer(newV, oldV, name + \"[..]\"); }; } ObservableArrayAdministration.prototype.dehanceValue = function (value) { if (this.dehancer !== undefined) return this.dehancer(value); return value; }; ObservableArrayAdministration.prototype.dehanceValues = function (values) { if (this.dehancer !== undefined) return values.map(this.dehancer); return values; }; ObservableArrayAdministration.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) { if (fireImmediately === void 0) { fireImmediately = false; } if (fireImmediately) { listener({ object: this.array, type: \"splice\", index: 0, added: this.values.slice(), addedCount: this.values.length, removed: [], removedCount: 0 }); } return registerListener(this, listener); }; ObservableArrayAdministration.prototype.getArrayLength = function () { this.atom.reportObserved(); return this.values.length; }; ObservableArrayAdministration.prototype.setArrayLength = function (newLength) { if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength); var currentLength = this.values.length; if (newLength === currentLength) return;else if (newLength > currentLength) { var newItems = new Array(newLength - currentLength); for (var i = 0; i < newLength - currentLength; i++) { newItems[i] = undefined; } // No Array.fill everywhere... this.spliceWithArray(currentLength, 0, newItems); } else this.spliceWithArray(newLength, currentLength - newLength); }; // adds / removes the necessary numeric properties to this object ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) { if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\"); this.lastKnownLength += delta; if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1); }; ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) { var _this = this; checkIfStateModificationsAreAllowed(this.atom); var length = this.values.length; if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index); if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index)); if (newItems === undefined) newItems = []; if (hasInterceptors(this)) { var change = interceptChange(this, { object: this.array, type: \"splice\", index: index, removedCount: deleteCount, added: newItems }); if (!change) return EMPTY_ARRAY; deleteCount = change.removedCount; newItems = change.added; } newItems = newItems.map(function (v) { return _this.enhancer(v, undefined); }); var lengthDelta = newItems.length - deleteCount; this.updateArrayLength(length, lengthDelta); // create or remove new entries var res = this.spliceItemsIntoValues(index, deleteCount, newItems); if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res); return this.dehanceValues(res); }; ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) { if (newItems.length < MAX_SPLICE_SIZE) { return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems)); } else { var res = this.values.slice(index, index + deleteCount); this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount)); return res; } var _a; }; ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) { var notifySpy = !this.owned && isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { object: this.array, type: \"update\", index: index, newValue: newValue, oldValue: oldValue } : null; if (notifySpy) spyReportStart(change); this.atom.reportChanged(); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); }; ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) { var notifySpy = !this.owned && isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { object: this.array, type: \"splice\", index: index, removed: removed, added: added, removedCount: removed.length, addedCount: added.length } : null; if (notifySpy) spyReportStart(change); this.atom.reportChanged(); // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); }; return ObservableArrayAdministration; }(); var ObservableArray = function (_super) { __extends(ObservableArray, _super); function ObservableArray(initialValues, enhancer, name, owned) { if (name === void 0) { name = \"ObservableArray@\" + getNextId(); } if (owned === void 0) { owned = false; } var _this = _super.call(this) || this; var adm = new ObservableArrayAdministration(name, enhancer, _this, owned); addHiddenFinalProp(_this, \"$mobx\", adm); if (initialValues && initialValues.length) { _this.spliceWithArray(0, 0, initialValues); } if (safariPrototypeSetterInheritanceBug) { // Seems that Safari won't use numeric prototype setter untill any * numeric property is // defined on the instance. After that it works fine, even if this property is deleted. Object.defineProperty(adm.array, \"0\", ENTRY_0); } return _this; } ObservableArray.prototype.intercept = function (handler) { return this.$mobx.intercept(handler); }; ObservableArray.prototype.observe = function (listener, fireImmediately) { if (fireImmediately === void 0) { fireImmediately = false; } return this.$mobx.observe(listener, fireImmediately); }; ObservableArray.prototype.clear = function () { return this.splice(0); }; ObservableArray.prototype.concat = function () { var arrays = []; for (var _i = 0; _i < arguments.length; _i++) { arrays[_i] = arguments[_i]; } this.$mobx.atom.reportObserved(); return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) { return isObservableArray(a) ? a.peek() : a; })); }; ObservableArray.prototype.replace = function (newItems) { return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems); }; /** * Converts this array back to a (shallow) javascript structure. * For a deep clone use mobx.toJS */ ObservableArray.prototype.toJS = function () { return this.slice(); }; ObservableArray.prototype.toJSON = function () { // Used by JSON.stringify return this.toJS(); }; ObservableArray.prototype.peek = function () { this.$mobx.atom.reportObserved(); return this.$mobx.dehanceValues(this.$mobx.values); }; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) { if (fromIndex === void 0) { fromIndex = 0; } var idx = this.findIndex.apply(this, arguments); return idx === -1 ? undefined : this.get(idx); }; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex ObservableArray.prototype.findIndex = function (predicate, thisArg, fromIndex) { if (fromIndex === void 0) { fromIndex = 0; } var items = this.peek(), l = items.length; for (var i = fromIndex; i < l; i++) { if (predicate.call(thisArg, items[i], i, this)) return i; }return -1; }; /* functions that do alter the internal structure of the array, (based on lib.es6.d.ts) since these functions alter the inner structure of the array, the have side effects. Because the have side effects, they should not be used in computed function, and for that reason the do not call dependencyState.notifyObserved */ ObservableArray.prototype.splice = function (index, deleteCount) { var newItems = []; for (var _i = 2; _i < arguments.length; _i++) { newItems[_i - 2] = arguments[_i]; } switch (arguments.length) { case 0: return []; case 1: return this.$mobx.spliceWithArray(index); case 2: return this.$mobx.spliceWithArray(index, deleteCount); } return this.$mobx.spliceWithArray(index, deleteCount, newItems); }; ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) { return this.$mobx.spliceWithArray(index, deleteCount, newItems); }; ObservableArray.prototype.push = function () { var items = []; for (var _i = 0; _i < arguments.length; _i++) { items[_i] = arguments[_i]; } var adm = this.$mobx; adm.spliceWithArray(adm.values.length, 0, items); return adm.values.length; }; ObservableArray.prototype.pop = function () { return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0]; }; ObservableArray.prototype.shift = function () { return this.splice(0, 1)[0]; }; ObservableArray.prototype.unshift = function () { var items = []; for (var _i = 0; _i < arguments.length; _i++) { items[_i] = arguments[_i]; } var adm = this.$mobx; adm.spliceWithArray(0, 0, items); return adm.values.length; }; ObservableArray.prototype.reverse = function () { // reverse by default mutates in place before returning the result // which makes it both a 'derivation' and a 'mutation'. // so we deviate from the default and just make it an dervitation var clone = this.slice(); return clone.reverse.apply(clone, arguments); }; ObservableArray.prototype.sort = function (compareFn) { // sort by default mutates in place before returning the result // which goes against all good practices. Let's not change the array in place! var clone = this.slice(); return clone.sort.apply(clone, arguments); }; ObservableArray.prototype.remove = function (value) { var idx = this.$mobx.dehanceValues(this.$mobx.values).indexOf(value); if (idx > -1) { this.splice(idx, 1); return true; } return false; }; ObservableArray.prototype.move = function (fromIndex, toIndex) { function checkIndex(index) { if (index < 0) { throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\"); } var length = this.$mobx.values.length; if (index >= length) { throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length); } } checkIndex.call(this, fromIndex); checkIndex.call(this, toIndex); if (fromIndex === toIndex) { return; } var oldItems = this.$mobx.values; var newItems; if (fromIndex < toIndex) { newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1)); } else { newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1)); } this.replace(newItems); }; // See #734, in case property accessors are unreliable... ObservableArray.prototype.get = function (index) { var impl = this.$mobx; if (impl) { if (index < impl.values.length) { impl.atom.reportObserved(); return impl.dehanceValue(impl.values[index]); } console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\"); } return undefined; }; // See #734, in case property accessors are unreliable... ObservableArray.prototype.set = function (index, newValue) { var adm = this.$mobx; var values = adm.values; if (index < values.length) { // update at index in range checkIfStateModificationsAreAllowed(adm.atom); var oldValue = values[index]; if (hasInterceptors(adm)) { var change = interceptChange(adm, { type: \"update\", object: this, index: index, newValue: newValue }); if (!change) return; newValue = change.newValue; } newValue = adm.enhancer(newValue, oldValue); var changed = newValue !== oldValue; if (changed) { values[index] = newValue; adm.notifyArrayChildUpdate(index, newValue, oldValue); } } else if (index === values.length) { // add a new item adm.spliceWithArray(index, 0, [newValue]); } else { // out of bounds throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length); } }; return ObservableArray; }(StubArray); declareIterator(ObservableArray.prototype, function () { return arrayAsIterator(this.slice()); }); Object.defineProperty(ObservableArray.prototype, \"length\", { enumerable: false, configurable: true, get: function get() { return this.$mobx.getArrayLength(); }, set: function set(newLength) { this.$mobx.setArrayLength(newLength); } }); /** * Wrap function from prototype */ [\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\", \"toString\", \"toLocaleString\"].forEach(function (funcName) { var baseFunc = Array.prototype[funcName]; invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\"); addHiddenProp(ObservableArray.prototype, funcName, function () { return baseFunc.apply(this.peek(), arguments); }); }); /** * We don't want those to show up in `for (const key in ar)` ... */ makeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"get\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"findIndex\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"set\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]); // See #364 var ENTRY_0 = createArrayEntryDescriptor(0); function createArrayEntryDescriptor(index) { return { enumerable: false, configurable: false, get: function get() { // TODO: Check `this`?, see #752? return this.get(index); }, set: function set(value) { this.set(index, value); } }; } function createArrayBufferItem(index) { Object.defineProperty(ObservableArray.prototype, \"\" + index, createArrayEntryDescriptor(index)); } function reserveArrayBuffer(max) { for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) { createArrayBufferItem(index); }OBSERVABLE_ARRAY_BUFFER_SIZE = max; } reserveArrayBuffer(1000); var isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration); function isObservableArray(thing) { return isObject(thing) && isObservableArrayAdministration(thing.$mobx); } var UNCHANGED = {}; var ObservableValue = function (_super) { __extends(ObservableValue, _super); function ObservableValue(value, enhancer, name, notifySpy) { if (name === void 0) { name = \"ObservableValue@\" + getNextId(); } if (notifySpy === void 0) { notifySpy = true; } var _this = _super.call(this, name) || this; _this.enhancer = enhancer; _this.hasUnreportedChange = false; _this.dehancer = undefined; _this.value = enhancer(value, undefined, name); if (notifySpy && isSpyEnabled()) { // only notify spy if this is a stand-alone observable spyReport({ type: \"create\", object: _this, newValue: _this.value }); } return _this; } ObservableValue.prototype.dehanceValue = function (value) { if (this.dehancer !== undefined) return this.dehancer(value); return value; }; ObservableValue.prototype.set = function (newValue) { var oldValue = this.value; newValue = this.prepareNewValue(newValue); if (newValue !== UNCHANGED) { var notifySpy = isSpyEnabled(); if (notifySpy) { spyReportStart({ type: \"update\", object: this, newValue: newValue, oldValue: oldValue }); } this.setNewValue(newValue); if (notifySpy) spyReportEnd(); } }; ObservableValue.prototype.prepareNewValue = function (newValue) { checkIfStateModificationsAreAllowed(this); if (hasInterceptors(this)) { var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue }); if (!change) return UNCHANGED; newValue = change.newValue; } // apply modifier newValue = this.enhancer(newValue, this.value, this.name); return this.value !== newValue ? newValue : UNCHANGED; }; ObservableValue.prototype.setNewValue = function (newValue) { var oldValue = this.value; this.value = newValue; this.reportChanged(); if (hasListeners(this)) { notifyListeners(this, { type: \"update\", object: this, newValue: newValue, oldValue: oldValue }); } }; ObservableValue.prototype.get = function () { this.reportObserved(); return this.dehanceValue(this.value); }; ObservableValue.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; ObservableValue.prototype.observe = function (listener, fireImmediately) { if (fireImmediately) listener({ object: this, type: \"update\", newValue: this.value, oldValue: undefined }); return registerListener(this, listener); }; ObservableValue.prototype.toJSON = function () { return this.get(); }; ObservableValue.prototype.toString = function () { return this.name + \"[\" + this.value + \"]\"; }; ObservableValue.prototype.valueOf = function () { return toPrimitive(this.get()); }; return ObservableValue; }(BaseAtom); ObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf; var isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue); var messages = { \"m001\": \"It is not allowed to assign new values to @action fields\", \"m002\": \"`runInAction` expects a function\", \"m003\": \"`runInAction` expects a function without arguments\", \"m004\": \"autorun expects a function\", \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\", \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\", \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\", \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\", \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\", \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\", \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\", \"m012\": \"computed takes one or two arguments if used as function\", \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\", \"m014\": \"extendObservable expected 2 or more arguments\", \"m015\": \"extendObservable expects an object as first argument\", \"m016\": \"extendObservable should not be used on maps, use map.merge instead\", \"m017\": \"all arguments of extendObservable should be objects\", \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\", \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\", \"m020\": \"modifiers can only be used for individual object properties\", \"m021\": \"observable expects zero or one arguments\", \"m022\": \"@observable can not be used on getters, use @computed instead\", \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\", \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\", \"m025\": \"whyRun can only be used on reactions and computed values\", \"m026\": \"`action` can only be invoked on functions\", \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\", \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\", \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \", \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \", \"m031\": \"Computed values are not allowed to cause side effects by changing observables that are already being observed. Tried to modify: \", \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n Didn't expect this computation to be suspended at this point?\\n 1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n 2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\", \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\", \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\", \"m035\": \"Cannot make the designated object observable; it is not extensible\", \"m036\": \"It is not possible to get index atoms from arrays\", \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\", \"m038\": \"Missing items in this list?\\n 1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n 2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\" }; function getMessage(id) { return messages[id]; } function createAction(actionName, fn) { invariant(typeof fn === \"function\", getMessage(\"m026\")); invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\"); var res = function res() { return executeAction(actionName, fn, this, arguments); }; res.originalFn = fn; res.isMobxAction = true; return res; } function executeAction(actionName, fn, scope, args) { var runInfo = startAction(actionName, fn, scope, args); try { return fn.apply(scope, args); } finally { endAction(runInfo); } } function startAction(actionName, fn, scope, args) { var notifySpy = isSpyEnabled() && !!actionName; var startTime = 0; if (notifySpy) { startTime = Date.now(); var l = args && args.length || 0; var flattendArgs = new Array(l); if (l > 0) for (var i = 0; i < l; i++) { flattendArgs[i] = args[i]; }spyReportStart({ type: \"action\", name: actionName, fn: fn, object: scope, arguments: flattendArgs }); } var prevDerivation = untrackedStart(); startBatch(); var prevAllowStateChanges = allowStateChangesStart(true); return { prevDerivation: prevDerivation, prevAllowStateChanges: prevAllowStateChanges, notifySpy: notifySpy, startTime: startTime }; } function endAction(runInfo) { allowStateChangesEnd(runInfo.prevAllowStateChanges); endBatch(); untrackedEnd(runInfo.prevDerivation); if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime }); } function useStrict(strict) { invariant(globalState.trackingDerivation === null, getMessage(\"m028\")); globalState.strictMode = strict; globalState.allowStateChanges = !strict; } function isStrictModeEnabled() { return globalState.strictMode; } function allowStateChanges(allowStateChanges, func) { // TODO: deprecate / refactor this function in next major // Currently only used by `@observer` // Proposed change: remove first param, rename to `forbidStateChanges`, // require error callback instead of the hardcoded error message now used // Use `inAction` instead of allowStateChanges in derivation.ts to check strictMode var prev = allowStateChangesStart(allowStateChanges); var res; try { res = func(); } finally { allowStateChangesEnd(prev); } return res; } function allowStateChangesStart(allowStateChanges) { var prev = globalState.allowStateChanges; globalState.allowStateChanges = allowStateChanges; return prev; } function allowStateChangesEnd(prev) { globalState.allowStateChanges = prev; } /** * Constructs a decorator, that normalizes the differences between * TypeScript and Babel. Mainly caused by the fact that legacy-decorator cannot assign * values during instance creation to properties that have a getter setter. * * - Sigh - * * Also takes care of the difference between @decorator field and @decorator(args) field, and different forms of values. * For performance (cpu and mem) reasons the properties are always defined on the prototype (at least initially). * This means that these properties despite being enumerable might not show up in Object.keys() (but they will show up in for...in loops). */ function createClassPropertyDecorator( /** * This function is invoked once, when the property is added to a new instance. * When this happens is not strictly determined due to differences in TS and Babel: * Typescript: Usually when constructing the new instance * Babel, sometimes Typescript: during the first get / set * Both: when calling `runLazyInitializers(instance)` */ onInitialize, _get, _set, enumerable, /** * Can this decorator invoked with arguments? e.g. @decorator(args) */ allowCustomArguments) { function classPropertyDecorator(target, key, descriptor, customArgs, argLen) { if (argLen === void 0) { argLen = 0; } invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\"); if (!descriptor) { // typescript (except for getter / setters) var newDescriptor = { enumerable: enumerable, configurable: true, get: function get() { if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor); return _get.call(this, key); }, set: function set(v) { if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) { typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor); } else { _set.call(this, key, v); } } }; if (arguments.length < 3 || arguments.length === 5 && argLen < 3) { // Typescript target is ES3, so it won't define property for us // or using Reflect.decorate polyfill, which will return no descriptor // (see https://github.com/mobxjs/mobx/issues/333) Object.defineProperty(target, key, newDescriptor); } return newDescriptor; } else { // babel and typescript getter / setter props if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) { addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || [] // support inheritance ); } var value_1 = descriptor.value, initializer_1 = descriptor.initializer; target.__mobxLazyInitializers.push(function (instance) { onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor); }); return { enumerable: enumerable, configurable: true, get: function get() { if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this); return _get.call(this, key); }, set: function set(v) { if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this); _set.call(this, key, v); } }; } } if (allowCustomArguments) { /** If custom arguments are allowed, we should return a function that returns a decorator */ return function () { /** Direct invocation: @decorator bla */ if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments); /** Indirect invocation: @decorator(args) bla */ var outerArgs = arguments; var argLen = arguments.length; return function (target, key, descriptor) { return classPropertyDecorator(target, key, descriptor, outerArgs, argLen); }; }; } return classPropertyDecorator; } function typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) { if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {}); instance.__mobxInitializedProps[key] = true; onInitialize(instance, key, v, customArgs, baseDescriptor); } function runLazyInitializers(instance) { if (instance.__mobxDidRunLazyInitializers === true) return; if (instance.__mobxLazyInitializers) { addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true); instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) { return initializer(instance); }); } } function quacksLikeADecorator(args) { return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\"; } var actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) { var actionName = args && args.length === 1 ? args[0] : value.name || key || \"\"; var wrappedAction = action(actionName, value); addHiddenProp(target, key, wrappedAction); }, function (key) { return this[key]; }, function () { invariant(false, getMessage(\"m001\")); }, false, true); var boundActionDecorator = createClassPropertyDecorator(function (target, key, value) { defineBoundAction(target, key, value); }, function (key) { return this[key]; }, function () { invariant(false, getMessage(\"m001\")); }, false, false); var action = function action(arg1, arg2, arg3, arg4) { if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"\", arg1); if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2); if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1); return namedActionDecorator(arg2).apply(null, arguments); }; action.bound = function boundAction(arg1, arg2, arg3) { if (typeof arg1 === \"function\") { var action_1 = createAction(\"\", arg1); action_1.autoBind = true; return action_1; } return boundActionDecorator.apply(null, arguments); }; function namedActionDecorator(name) { return function (target, prop, descriptor) { if (descriptor && typeof descriptor.value === \"function\") { // TypeScript @action method() { }. Defined on proto before being decorated // Don't use the field decorator if we are just decorating a method descriptor.value = createAction(name, descriptor.value); descriptor.enumerable = false; descriptor.configurable = true; return descriptor; } // bound instance methods return actionFieldDecorator(name).apply(this, arguments); }; } function runInAction(arg1, arg2, arg3) { var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"\"; var fn = typeof arg1 === \"function\" ? arg1 : arg2; var scope = typeof arg1 === \"function\" ? arg2 : arg3; invariant(typeof fn === \"function\", getMessage(\"m002\")); invariant(fn.length === 0, getMessage(\"m003\")); invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\"); return executeAction(actionName, fn, scope, undefined); } function isAction(thing) { return typeof thing === \"function\" && thing.isMobxAction === true; } function defineBoundAction(target, propertyName, fn) { var res = function res() { return executeAction(propertyName, fn, target, arguments); }; res.isMobxAction = true; addHiddenProp(target, propertyName, res); } function identityComparer(a, b) { return a === b; } function structuralComparer(a, b) { if (typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b)) { return true; } return deepEqual(a, b); } function defaultComparer(a, b) { if (typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b)) { return true; } return identityComparer(a, b); } var comparer = { identity: identityComparer, structural: structuralComparer, default: defaultComparer }; function autorun(arg1, arg2, arg3) { var name, view, scope; if (typeof arg1 === \"string\") { name = arg1; view = arg2; scope = arg3; } else { name = arg1.name || \"Autorun@\" + getNextId(); view = arg1; scope = arg2; } invariant(typeof view === \"function\", getMessage(\"m004\")); invariant(isAction(view) === false, getMessage(\"m005\")); if (scope) view = view.bind(scope); var reaction = new Reaction(name, function () { this.track(reactionRunner); }); function reactionRunner() { view(reaction); } reaction.schedule(); return reaction.getDisposer(); } function when(arg1, arg2, arg3, arg4) { var name, predicate, effect, scope; if (typeof arg1 === \"string\") { name = arg1; predicate = arg2; effect = arg3; scope = arg4; } else { name = \"When@\" + getNextId(); predicate = arg1; effect = arg2; scope = arg3; } var disposer = autorun(name, function (r) { if (predicate.call(scope)) { r.dispose(); var prevUntracked = untrackedStart(); effect.call(scope); untrackedEnd(prevUntracked); } }); return disposer; } function autorunAsync(arg1, arg2, arg3, arg4) { var name, func, delay, scope; if (typeof arg1 === \"string\") { name = arg1; func = arg2; delay = arg3; scope = arg4; } else { name = arg1.name || \"AutorunAsync@\" + getNextId(); func = arg1; delay = arg2; scope = arg3; } invariant(isAction(func) === false, getMessage(\"m006\")); if (delay === void 0) delay = 1; if (scope) func = func.bind(scope); var isScheduled = false; var r = new Reaction(name, function () { if (!isScheduled) { isScheduled = true; setTimeout(function () { isScheduled = false; if (!r.isDisposed) r.track(reactionRunner); }, delay); } }); function reactionRunner() { func(r); } r.schedule(); return r.getDisposer(); } function reaction(expression, effect, arg3) { if (arguments.length > 3) { fail(getMessage(\"m007\")); } if (isModifierDescriptor(expression)) { fail(getMessage(\"m008\")); } var opts; if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") { opts = arg3; } else { opts = {}; } opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId(); opts.fireImmediately = arg3 === true || opts.fireImmediately === true; opts.delay = opts.delay || 0; opts.compareStructural = opts.compareStructural || opts.struct || false; effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect); if (opts.context) { expression = expression.bind(opts.context); } var firstTime = true; var isScheduled = false; var value; var equals = opts.equals ? opts.equals : opts.compareStructural || opts.struct ? comparer.structural : comparer.default; var r = new Reaction(opts.name, function () { if (firstTime || opts.delay < 1) { reactionRunner(); } else if (!isScheduled) { isScheduled = true; setTimeout(function () { isScheduled = false; reactionRunner(); }, opts.delay); } }); function reactionRunner() { if (r.isDisposed) return; var changed = false; r.track(function () { var nextValue = expression(r); changed = firstTime || !equals(value, nextValue); value = nextValue; }); if (firstTime && opts.fireImmediately) effect(value, r); if (!firstTime && changed === true) effect(value, r); if (firstTime) firstTime = false; } r.schedule(); return r.getDisposer(); } /** * A node in the state dependency root that observes other nodes, and can be observed itself. * * ComputedValue will remember result of the computation for duration of a batch, or being observed * During this time it will recompute only when one of its direct dependencies changed, * but only when it is being accessed with `ComputedValue.get()`. * * Implementation description: * 1. First time it's being accessed it will compute and remember result * give back remembered result until 2. happens * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3. * 3. When it's being accessed, recompute if any shallow dependency changed. * if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step. * go to step 2. either way * * If at any point it's outside batch and it isn't observed: reset everything and go to 1. */ var ComputedValue = function () { /** * Create a new computed value based on a function expression. * * The `name` property is for debug purposes only. * * The `equals` property specifies the comparer function to use to determine if a newly produced * value differs from the previous value. Two comparers are provided in the library; `defaultComparer` * compares based on identity comparison (===), and `structualComparer` deeply compares the structure. * Structural comparison can be convenient if you always produce an new aggregated object and * don't want to notify observers if it is structurally the same. * This is useful for working with vectors, mouse coordinates etc. */ function ComputedValue(derivation, scope, equals, name, setter) { this.derivation = derivation; this.scope = scope; this.equals = equals; this.dependenciesState = IDerivationState.NOT_TRACKING; this.observing = []; // nodes we are looking at. Our value depends on these nodes this.newObserving = null; // during tracking it's an array with new observed observers this.isPendingUnobservation = false; this.observers = []; this.observersIndexes = {}; this.diffValue = 0; this.runId = 0; this.lastAccessedBy = 0; this.lowestObserverState = IDerivationState.UP_TO_DATE; this.unboundDepsCount = 0; this.__mapid = \"#\" + getNextId(); this.value = new CaughtException(null); this.isComputing = false; // to check for cycles this.isRunningSetter = false; this.name = name || \"ComputedValue@\" + getNextId(); if (setter) this.setter = createAction(name + \"-setter\", setter); } ComputedValue.prototype.onBecomeStale = function () { propagateMaybeChanged(this); }; ComputedValue.prototype.onBecomeUnobserved = function () { clearObserving(this); this.value = undefined; }; /** * Returns the current value of this computed value. * Will evaluate its computation first if needed. */ ComputedValue.prototype.get = function () { invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation); if (globalState.inBatch === 0) { // This is an minor optimization which could be omitted to simplify the code // The computedValue is accessed outside of any mobx stuff. Batch observing should be enough and don't need // tracking as it will never be called again inside this batch. startBatch(); if (shouldCompute(this)) this.value = this.computeValue(false); endBatch(); } else { reportObserved(this); if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this); } var result = this.value; if (isCaughtException(result)) throw result.cause; return result; }; ComputedValue.prototype.peek = function () { var res = this.computeValue(false); if (isCaughtException(res)) throw res.cause; return res; }; ComputedValue.prototype.set = function (value) { if (this.setter) { invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\"); this.isRunningSetter = true; try { this.setter.call(this.scope, value); } finally { this.isRunningSetter = false; } } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\"); }; ComputedValue.prototype.trackAndCompute = function () { if (isSpyEnabled()) { spyReport({ object: this.scope, type: \"compute\", fn: this.derivation }); } var oldValue = this.value; var newValue = this.value = this.computeValue(true); return isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals(oldValue, newValue); }; ComputedValue.prototype.computeValue = function (track) { this.isComputing = true; globalState.computationDepth++; var res; if (track) { res = trackDerivedFunction(this, this.derivation, this.scope); } else { try { res = this.derivation.call(this.scope); } catch (e) { res = new CaughtException(e); } } globalState.computationDepth--; this.isComputing = false; return res; }; ComputedValue.prototype.observe = function (listener, fireImmediately) { var _this = this; var firstTime = true; var prevValue = undefined; return autorun(function () { var newValue = _this.get(); if (!firstTime || fireImmediately) { var prevU = untrackedStart(); listener({ type: \"update\", object: _this, newValue: newValue, oldValue: prevValue }); untrackedEnd(prevU); } firstTime = false; prevValue = newValue; }); }; ComputedValue.prototype.toJSON = function () { return this.get(); }; ComputedValue.prototype.toString = function () { return this.name + \"[\" + this.derivation.toString() + \"]\"; }; ComputedValue.prototype.valueOf = function () { return toPrimitive(this.get()); }; ComputedValue.prototype.whyRun = function () { var isTracking = Boolean(globalState.trackingDerivation); var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) { return dep.name; }); var observers = unique(getObservers(this).map(function (dep) { return dep.name; })); return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n \" + joinStrings(observing) + \"\\n \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n * If the outcome of this computation changes, the following observers will be re-run:\\n \" + joinStrings(observers) + \"\\n\"); }; return ComputedValue; }(); ComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf; var isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue); var ObservableObjectAdministration = function () { function ObservableObjectAdministration(target, name) { this.target = target; this.name = name; this.values = {}; this.changeListeners = null; this.interceptors = null; } /** * Observes this object. Triggers for the events 'add', 'update' and 'delete'. * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe * for callback details */ ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) { invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\"); return registerListener(this, callback); }; ObservableObjectAdministration.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; return ObservableObjectAdministration; }(); function asObservableObject(target, name) { if (isObservableObject(target)) return target.$mobx; invariant(Object.isExtensible(target), getMessage(\"m035\")); if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId(); if (!name) name = \"ObservableObject@\" + getNextId(); var adm = new ObservableObjectAdministration(target, name); addHiddenFinalProp(target, \"$mobx\", adm); return adm; } function defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) { if (adm.values[propName]) { // already observable property invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\"); adm.target[propName] = descriptor.value; // the property setter will make 'value' reactive if needed. return; } // not yet observable property if (\"value\" in descriptor) { // not a computed value if (isModifierDescriptor(descriptor.value)) { // x : ref(someValue) var modifierDescriptor = descriptor.value; defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer); } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) { defineBoundAction(adm.target, propName, descriptor.value.originalFn); } else if (isComputedValue(descriptor.value)) { // x: computed(someExpr) defineComputedPropertyFromComputedValue(adm, propName, descriptor.value); } else { // x: someValue defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer); } } else { // get x() { return 3 } set x(v) { } defineComputedProperty(adm, propName, descriptor.get, descriptor.set, comparer.default, true); } } function defineObservableProperty(adm, propName, newValue, enhancer) { assertPropertyConfigurable(adm.target, propName); if (hasInterceptors(adm)) { var change = interceptChange(adm, { object: adm.target, name: propName, type: \"add\", newValue: newValue }); if (!change) return; newValue = change.newValue; } var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false); newValue = observable.value; // observableValue might have changed it Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName)); notifyPropertyAddition(adm, adm.target, propName, newValue); } function defineComputedProperty(adm, propName, getter, setter, equals, asInstanceProperty) { if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName); adm.values[propName] = new ComputedValue(getter, adm.target, equals, adm.name + \".\" + propName, setter); if (asInstanceProperty) { Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName)); } } function defineComputedPropertyFromComputedValue(adm, propName, computedValue) { var name = adm.name + \".\" + propName; computedValue.name = name; if (!computedValue.scope) computedValue.scope = adm.target; adm.values[propName] = computedValue; Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName)); } var observablePropertyConfigs = {}; var computedPropertyConfigs = {}; function generateObservablePropConfig(propName) { return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = { configurable: true, enumerable: true, get: function get() { return this.$mobx.values[propName].get(); }, set: function set(v) { setPropertyValue(this, propName, v); } }); } function generateComputedPropConfig(propName) { return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = { configurable: true, enumerable: false, get: function get() { return this.$mobx.values[propName].get(); }, set: function set(v) { return this.$mobx.values[propName].set(v); } }); } function setPropertyValue(instance, name, newValue) { var adm = instance.$mobx; var observable = adm.values[name]; // intercept if (hasInterceptors(adm)) { var change = interceptChange(adm, { type: \"update\", object: instance, name: name, newValue: newValue }); if (!change) return; newValue = change.newValue; } newValue = observable.prepareNewValue(newValue); // notify spy & observers if (newValue !== UNCHANGED) { var notify = hasListeners(adm); var notifySpy = isSpyEnabled(); var change = notify || notifySpy ? { type: \"update\", object: instance, oldValue: observable.value, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); observable.setNewValue(newValue); if (notify) notifyListeners(adm, change); if (notifySpy) spyReportEnd(); } } function notifyPropertyAddition(adm, object, name, newValue) { var notify = hasListeners(adm); var notifySpy = isSpyEnabled(); var change = notify || notifySpy ? { type: \"add\", object: object, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); if (notify) notifyListeners(adm, change); if (notifySpy) spyReportEnd(); } var isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration); function isObservableObject(thing) { if (isObject(thing)) { // Initializers run lazily when transpiling to babel, so make sure they are run... runLazyInitializers(thing); return isObservableObjectAdministration(thing.$mobx); } return false; } /** * Returns true if the provided value is reactive. * @param value object, function or array * @param property if property is specified, checks whether value.property is reactive. */ function isObservable(value, property) { if (value === null || value === undefined) return false; if (property !== undefined) { if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) { var o = value.$mobx; return o.values && !!o.values[property]; } return false; } // For first check, see #701 return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value); } function createDecoratorForEnhancer(enhancer) { invariant(!!enhancer, \":(\"); return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) { assertPropertyConfigurable(target, name); invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\")); var adm = asObservableObject(target, undefined); defineObservableProperty(adm, name, baseValue, enhancer); }, function (name) { var observable = this.$mobx.values[name]; if (observable === undefined) return undefined; return observable.get(); }, function (name, value) { setPropertyValue(this, name, value); }, true, false); } function extendObservable(target) { var properties = []; for (var _i = 1; _i < arguments.length; _i++) { properties[_i - 1] = arguments[_i]; } return extendObservableHelper(target, deepEnhancer, properties); } function extendShallowObservable(target) { var properties = []; for (var _i = 1; _i < arguments.length; _i++) { properties[_i - 1] = arguments[_i]; } return extendObservableHelper(target, referenceEnhancer, properties); } function extendObservableHelper(target, defaultEnhancer, properties) { invariant(arguments.length >= 2, getMessage(\"m014\")); invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\")); invariant(!isObservableMap(target), getMessage(\"m016\")); properties.forEach(function (propSet) { invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\")); invariant(!isObservable(propSet), getMessage(\"m018\")); }); var adm = asObservableObject(target); var definedProps = {}; // Note could be optimised if properties.length === 1 for (var i = properties.length - 1; i >= 0; i--) { var propSet = properties[i]; for (var key in propSet) { if (definedProps[key] !== true && hasOwnProperty(propSet, key)) { definedProps[key] = true; if (target === propSet && !isPropertyConfigurable(target, key)) continue; // see #111, skip non-configurable or non-writable props for `observable(object)`. var descriptor = Object.getOwnPropertyDescriptor(propSet, key); defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer); } } } return target; } var deepDecorator = createDecoratorForEnhancer(deepEnhancer); var shallowDecorator = createDecoratorForEnhancer(shallowEnhancer); var refDecorator = createDecoratorForEnhancer(referenceEnhancer); var deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer); var refStructDecorator = createDecoratorForEnhancer(refStructEnhancer); /** * Turns an object, array or function into a reactive structure. * @param v the value which should become observable. */ function createObservable(v) { if (v === void 0) { v = undefined; } // @observable someProp; if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments); invariant(arguments.length 2) incorrectlyUsedAsDecorator(\"box\"); return new ObservableValue(value, deepEnhancer, name); }; IObservableFactories.prototype.shallowBox = function (value, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\"); return new ObservableValue(value, referenceEnhancer, name); }; IObservableFactories.prototype.array = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\"); return new ObservableArray(initialValues, deepEnhancer, name); }; IObservableFactories.prototype.shallowArray = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\"); return new ObservableArray(initialValues, referenceEnhancer, name); }; IObservableFactories.prototype.map = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\"); return new ObservableMap(initialValues, deepEnhancer, name); }; IObservableFactories.prototype.shallowMap = function (initialValues, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\"); return new ObservableMap(initialValues, referenceEnhancer, name); }; IObservableFactories.prototype.object = function (props, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\"); var res = {}; // convert to observable object asObservableObject(res, name); // add properties extendObservable(res, props); return res; }; IObservableFactories.prototype.shallowObject = function (props, name) { if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\"); var res = {}; asObservableObject(res, name); extendShallowObservable(res, props); return res; }; IObservableFactories.prototype.ref = function () { if (arguments.length < 2) { // although ref creates actually a modifier descriptor, the type of the resultig properties // of the object is `T` in the end, when the descriptors are interpreted return createModifierDescriptor(referenceEnhancer, arguments[0]); } else { return refDecorator.apply(null, arguments); } }; IObservableFactories.prototype.shallow = function () { if (arguments.length < 2) { // although ref creates actually a modifier descriptor, the type of the resultig properties // of the object is `T` in the end, when the descriptors are interpreted return createModifierDescriptor(shallowEnhancer, arguments[0]); } else { return shallowDecorator.apply(null, arguments); } }; IObservableFactories.prototype.deep = function () { if (arguments.length < 2) { // although ref creates actually a modifier descriptor, the type of the resultig properties // of the object is `T` in the end, when the descriptors are interpreted return createModifierDescriptor(deepEnhancer, arguments[0]); } else { return deepDecorator.apply(null, arguments); } }; IObservableFactories.prototype.struct = function () { if (arguments.length < 2) { // although ref creates actually a modifier descriptor, the type of the resultig properties // of the object is `T` in the end, when the descriptors are interpreted return createModifierDescriptor(deepStructEnhancer, arguments[0]); } else { return deepStructDecorator.apply(null, arguments); } }; return IObservableFactories; }(); var observable = createObservable; // weird trick to keep our typings nicely with our funcs, and still extend the observable function // ES6 class methods aren't enumerable, can't use Object.keys Object.getOwnPropertyNames(IObservableFactories.prototype).filter(function (name) { return name !== \"constructor\"; }).forEach(function (name) { return observable[name] = IObservableFactories.prototype[name]; }); observable.deep.struct = observable.struct; observable.ref.struct = function () { if (arguments.length < 2) { return createModifierDescriptor(refStructEnhancer, arguments[0]); } else { return refStructDecorator.apply(null, arguments); } }; function incorrectlyUsedAsDecorator(methodName) { fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\"); } function isModifierDescriptor(thing) { return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true; } function createModifierDescriptor(enhancer, initialValue) { invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\"); return { isMobxModifierDescriptor: true, initialValue: initialValue, enhancer: enhancer }; } function deepEnhancer(v, _, name) { if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\"); // it is an observable already, done if (isObservable(v)) return v; // something that can be converted and mutated? if (Array.isArray(v)) return observable.array(v, name); if (isPlainObject(v)) return observable.object(v, name); if (isES6Map(v)) return observable.map(v, name); return v; } function shallowEnhancer(v, _, name) { if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\"); if (v === undefined || v === null) return v; if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v; if (Array.isArray(v)) return observable.shallowArray(v, name); if (isPlainObject(v)) return observable.shallowObject(v, name); if (isES6Map(v)) return observable.shallowMap(v, name); return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\"); } function referenceEnhancer(newValue) { // never turn into an observable return newValue; } function deepStructEnhancer(v, oldValue, name) { // don't confuse structurally compare enhancer with ref enhancer! The latter is probably // more suited for immutable objects if (deepEqual(v, oldValue)) return oldValue; // it is an observable already, done if (isObservable(v)) return v; // something that can be converted and mutated? if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name); if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name); if (isPlainObject(v)) { var res = {}; asObservableObject(res, name); extendObservableHelper(res, deepStructEnhancer, [v]); return res; } return v; } function refStructEnhancer(v, oldValue, name) { if (deepEqual(v, oldValue)) return oldValue; return v; } /** * @deprecated * During a transaction no views are updated until the end of the transaction. * The transaction will be run synchronously nonetheless. * * Deprecated to simplify api; transactions offer no real benefit above actions. * * @param action a function that updates some reactive state * @returns any value that was returned by the 'action' parameter. */ function transaction(action, thisArg) { if (thisArg === void 0) { thisArg = undefined; } deprecated(getMessage(\"m023\")); return runInTransaction.apply(undefined, arguments); } function runInTransaction(action, thisArg) { if (thisArg === void 0) { thisArg = undefined; } return executeAction(\"\", action); } var ObservableMapMarker = {}; var ObservableMap = function () { function ObservableMap(initialData, enhancer, name) { if (enhancer === void 0) { enhancer = deepEnhancer; } if (name === void 0) { name = \"ObservableMap@\" + getNextId(); } this.enhancer = enhancer; this.name = name; this.$mobx = ObservableMapMarker; this._data = Object.create(null); this._hasMap = Object.create(null); // hasMap, not hashMap >-). this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true); this.interceptors = null; this.changeListeners = null; this.dehancer = undefined; this.merge(initialData); } ObservableMap.prototype._has = function (key) { return typeof this._data[key] !== \"undefined\"; }; ObservableMap.prototype.has = function (key) { if (!this.isValidKey(key)) return false; key = \"\" + key; if (this._hasMap[key]) return this._hasMap[key].get(); return this._updateHasMapEntry(key, false).get(); }; ObservableMap.prototype.set = function (key, value) { this.assertValidKey(key); key = \"\" + key; var hasKey = this._has(key); if (hasInterceptors(this)) { var change = interceptChange(this, { type: hasKey ? \"update\" : \"add\", object: this, newValue: value, name: key }); if (!change) return this; value = change.newValue; } if (hasKey) { this._updateValue(key, value); } else { this._addValue(key, value); } return this; }; ObservableMap.prototype.delete = function (key) { var _this = this; this.assertValidKey(key); key = \"\" + key; if (hasInterceptors(this)) { var change = interceptChange(this, { type: \"delete\", object: this, name: key }); if (!change) return false; } if (this._has(key)) { var notifySpy = isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { type: \"delete\", object: this, oldValue: this._data[key].value, name: key } : null; if (notifySpy) spyReportStart(change); runInTransaction(function () { _this._keys.remove(key); _this._updateHasMapEntry(key, false); var observable$$1 = _this._data[key]; observable$$1.setNewValue(undefined); _this._data[key] = undefined; }); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); return true; } return false; }; ObservableMap.prototype._updateHasMapEntry = function (key, value) { // optimization; don't fill the hasMap if we are not observing, or remove entry if there are no observers anymore var entry = this._hasMap[key]; if (entry) { entry.setNewValue(value); } else { entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false); } return entry; }; ObservableMap.prototype._updateValue = function (name, newValue) { var observable$$1 = this._data[name]; newValue = observable$$1.prepareNewValue(newValue); if (newValue !== UNCHANGED) { var notifySpy = isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { type: \"update\", object: this, oldValue: observable$$1.value, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); observable$$1.setNewValue(newValue); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); } }; ObservableMap.prototype._addValue = function (name, newValue) { var _this = this; runInTransaction(function () { var observable$$1 = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false); newValue = observable$$1.value; // value might have been changed _this._updateHasMapEntry(name, true); _this._keys.push(name); }); var notifySpy = isSpyEnabled(); var notify = hasListeners(this); var change = notify || notifySpy ? { type: \"add\", object: this, name: name, newValue: newValue } : null; if (notifySpy) spyReportStart(change); if (notify) notifyListeners(this, change); if (notifySpy) spyReportEnd(); }; ObservableMap.prototype.get = function (key) { key = \"\" + key; if (this.has(key)) return this.dehanceValue(this._data[key].get()); return this.dehanceValue(undefined); }; ObservableMap.prototype.dehanceValue = function (value) { if (this.dehancer !== undefined) { return this.dehancer(value); } return value; }; ObservableMap.prototype.keys = function () { return arrayAsIterator(this._keys.slice()); }; ObservableMap.prototype.values = function () { return arrayAsIterator(this._keys.map(this.get, this)); }; ObservableMap.prototype.entries = function () { var _this = this; return arrayAsIterator(this._keys.map(function (key) { return [key, _this.get(key)]; })); }; ObservableMap.prototype.forEach = function (callback, thisArg) { var _this = this; this.keys().forEach(function (key) { return callback.call(thisArg, _this.get(key), key, _this); }); }; /** Merge another object into this object, returns this. */ ObservableMap.prototype.merge = function (other) { var _this = this; if (isObservableMap(other)) { other = other.toJS(); } runInTransaction(function () { if (isPlainObject(other)) Object.keys(other).forEach(function (key) { return _this.set(key, other[key]); });else if (Array.isArray(other)) other.forEach(function (_a) { var key = _a[0], value = _a[1]; return _this.set(key, value); });else if (isES6Map(other)) other.forEach(function (value, key) { return _this.set(key, value); });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other); }); return this; }; ObservableMap.prototype.clear = function () { var _this = this; runInTransaction(function () { untracked(function () { _this.keys().forEach(_this.delete, _this); }); }); }; ObservableMap.prototype.replace = function (values) { var _this = this; runInTransaction(function () { _this.clear(); _this.merge(values); }); return this; }; Object.defineProperty(ObservableMap.prototype, \"size\", { get: function get() { return this._keys.length; }, enumerable: true, configurable: true }); /** * Returns a shallow non observable object clone of this map. * Note that the values migth still be observable. For a deep clone use mobx.toJS. */ ObservableMap.prototype.toJS = function () { var _this = this; var res = {}; this.keys().forEach(function (key) { return res[key] = _this.get(key); }); return res; }; ObservableMap.prototype.toJSON = function () { // Used by JSON.stringify return this.toJS(); }; ObservableMap.prototype.isValidKey = function (key) { if (key === null || key === undefined) return false; if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true; return false; }; ObservableMap.prototype.assertValidKey = function (key) { if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\"); }; ObservableMap.prototype.toString = function () { var _this = this; return this.name + \"[{ \" + this.keys().map(function (key) { return key + \": \" + (\"\" + _this.get(key)); }).join(\", \") + \" }]\"; }; /** * Observes this object. Triggers for the events 'add', 'update' and 'delete'. * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe * for callback details */ ObservableMap.prototype.observe = function (listener, fireImmediately) { invariant(fireImmediately !== true, getMessage(\"m033\")); return registerListener(this, listener); }; ObservableMap.prototype.intercept = function (handler) { return registerInterceptor(this, handler); }; return ObservableMap; }(); declareIterator(ObservableMap.prototype, function () { return this.entries(); }); function map(initialValues) { deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\"); return observable.map(initialValues); } /* 'var' fixes small-build issue */ var isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap); var EMPTY_ARRAY = []; Object.freeze(EMPTY_ARRAY); function getGlobal() { return global; } function getNextId() { return ++globalState.mobxGuid; } function fail(message, thing) { invariant(false, message, thing); throw \"X\"; // unreachable } function invariant(check, message, thing) { if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\")); } /** * Prints a deprecation message, but only one time. * Returns false if the deprecated message was already printed before */ var deprecatedMessages = []; function deprecated(msg) { if (deprecatedMessages.indexOf(msg) !== -1) return false; deprecatedMessages.push(msg); console.error(\"[mobx] Deprecated: \" + msg); return true; } /** * Makes sure that the provided function is invoked at most once. */ function once(func) { var invoked = false; return function () { if (invoked) return; invoked = true; return func.apply(this, arguments); }; } var noop = function noop() {}; function unique(list) { var res = []; list.forEach(function (item) { if (res.indexOf(item) === -1) res.push(item); }); return res; } function joinStrings(things, limit, separator) { if (limit === void 0) { limit = 100; } if (separator === void 0) { separator = \" - \"; } if (!things) return \"\"; var sliced = things.slice(0, limit); return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\"); } function isObject(value) { return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\"; } function isPlainObject(value) { if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false; var proto = Object.getPrototypeOf(value); return proto === Object.prototype || proto === null; } function objectAssign() { var res = arguments[0]; for (var i = 1, l = arguments.length; i < l; i++) { var source = arguments[i]; for (var key in source) { if (hasOwnProperty(source, key)) { res[key] = source[key]; } } } return res; } var prototypeHasOwnProperty = Object.prototype.hasOwnProperty; function hasOwnProperty(object, propName) { return prototypeHasOwnProperty.call(object, propName); } function makeNonEnumerable(object, propNames) { for (var i = 0; i < propNames.length; i++) { addHiddenProp(object, propNames[i], object[propNames[i]]); } } function addHiddenProp(object, propName, value) { Object.defineProperty(object, propName, { enumerable: false, writable: true, configurable: true, value: value }); } function addHiddenFinalProp(object, propName, value) { Object.defineProperty(object, propName, { enumerable: false, writable: false, configurable: true, value: value }); } function isPropertyConfigurable(object, prop) { var descriptor = Object.getOwnPropertyDescriptor(object, prop); return !descriptor || descriptor.configurable !== false && descriptor.writable !== false; } function assertPropertyConfigurable(object, prop) { invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\"); } function getEnumerableKeys(obj) { var res = []; for (var key in obj) { res.push(key); }return res; } /** * Naive deepEqual. Doesn't check for prototype, non-enumerable or out-of-range properties on arrays. * If you have such a case, you probably should use this function but something fancier :). */ function deepEqual(a, b) { if (a === null && b === null) return true; if (a === undefined && b === undefined) return true; if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b; var aIsArray = isArrayLike(a); var aIsMap = isMapLike(a); if (aIsArray !== isArrayLike(b)) { return false; } else if (aIsMap !== isMapLike(b)) { return false; } else if (aIsArray) { if (a.length !== b.length) return false; for (var i = a.length - 1; i >= 0; i--) { if (!deepEqual(a[i], b[i])) return false; }return true; } else if (aIsMap) { if (a.size !== b.size) return false; var equals_1 = true; a.forEach(function (value, key) { equals_1 = equals_1 && deepEqual(b.get(key), value); }); return equals_1; } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") { if (a === null || b === null) return false; if (isMapLike(a) && isMapLike(b)) { if (a.size !== b.size) return false; // Freaking inefficient.... Create PR if you run into this :) Much appreciated! return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries()); } if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false; for (var prop in a) { if (!(prop in b)) return false; if (!deepEqual(a[prop], b[prop])) return false; } return true; } return false; } function createInstanceofPredicate(name, clazz) { var propName = \"isMobX\" + name; clazz.prototype[propName] = true; return function (x) { return isObject(x) && x[propName] === true; }; } /** * Returns whether the argument is an array, disregarding observability. */ function isArrayLike(x) { return Array.isArray(x) || isObservableArray(x); } function isMapLike(x) { return isES6Map(x) || isObservableMap(x); } function isES6Map(thing) { if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true; return false; } function primitiveSymbol() { return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\"; } function toPrimitive(value) { return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value; } /** * These values will persist if global state is reset */ var persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"]; var MobXGlobals = function () { function MobXGlobals() { /** * MobXGlobals version. * MobX compatiblity with other versions loaded in memory as long as this version matches. * It indicates that the global state still stores similar information */ this.version = 5; /** * Currently running derivation */ this.trackingDerivation = null; /** * Are we running a computation currently? (not a reaction) */ this.computationDepth = 0; /** * Each time a derivation is tracked, it is assigned a unique run-id */ this.runId = 0; /** * 'guid' for general purpose. Will be persisted amongst resets. */ this.mobxGuid = 0; /** * Are we in a batch block? (and how many of them) */ this.inBatch = 0; /** * Observables that don't have observers anymore, and are about to be * suspended, unless somebody else accesses it in the same batch * * @type {IObservable[]} */ this.pendingUnobservations = []; /** * List of scheduled, not yet executed, reactions. */ this.pendingReactions = []; /** * Are we currently processing reactions? */ this.isRunningReactions = false; /** * Is it allowed to change observables at this point? * In general, MobX doesn't allow that when running computations and React.render. * To ensure that those functions stay pure. */ this.allowStateChanges = true; /** * If strict mode is enabled, state changes are by default not allowed */ this.strictMode = false; /** * Used by createTransformer to detect that the global state has been reset. */ this.resetId = 0; /** * Spy callbacks */ this.spyListeners = []; /** * Globally attached error handlers that react specifically to errors in reactions */ this.globalReactionErrorHandlers = []; } return MobXGlobals; }(); var globalState = new MobXGlobals(); var shareGlobalStateCalled = false; var runInIsolationCalled = false; var warnedAboutMultipleInstances = false; { var global_1 = getGlobal(); if (!global_1.__mobxInstanceCount) { global_1.__mobxInstanceCount = 1; } else { global_1.__mobxInstanceCount++; setTimeout(function () { if (!shareGlobalStateCalled && !runInIsolationCalled && !warnedAboutMultipleInstances) { warnedAboutMultipleInstances = true; console.warn(\"[mobx] Warning: there are multiple mobx instances active. This might lead to unexpected results. See https://github.com/mobxjs/mobx/issues/1082 for details.\"); } }); } } function isolateGlobalState() { runInIsolationCalled = true; getGlobal().__mobxInstanceCount--; } function shareGlobalState() { // TODO: remove in 4.0; just use peer dependencies instead. deprecated(\"Using `shareGlobalState` is not recommended, use peer dependencies instead. See https://github.com/mobxjs/mobx/issues/1082 for details.\"); shareGlobalStateCalled = true; var global = getGlobal(); var ownState = globalState; /** * Backward compatibility check */ if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\"); if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\"); if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState; } function getGlobalState() { return globalState; } /** * For testing purposes only; this will break the internal state of existing observables, * but can be used to get back at a stable state after throwing errors */ function resetGlobalState() { globalState.resetId++; var defaultGlobals = new MobXGlobals(); for (var key in defaultGlobals) { if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key]; }globalState.allowStateChanges = !globalState.strictMode; } function hasObservers(observable) { return observable.observers && observable.observers.length > 0; } function getObservers(observable) { return observable.observers; } function addObserver(observable, node) { // invariant(node.dependenciesState !== -1, \"INTERNAL ERROR, can add only dependenciesState !== -1\"); // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR add already added node\"); // invariantObservers(observable); var l = observable.observers.length; if (l) { observable.observersIndexes[node.__mapid] = l; } observable.observers[l] = node; if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState; // invariantObservers(observable); // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR didnt add node\"); } function removeObserver(observable, node) { // invariant(globalState.inBatch > 0, \"INTERNAL ERROR, remove should be called only inside batch\"); // invariant(observable._observers.indexOf(node) !== -1, \"INTERNAL ERROR remove already removed node\"); // invariantObservers(observable); if (observable.observers.length === 1) { // deleting last observer observable.observers.length = 0; queueForUnobservation(observable); } else { // deleting from _observersIndexes is straight forward, to delete from _observers, let's swap `node` with last element var list = observable.observers; var map = observable.observersIndexes; var filler = list.pop(); // get last element, which should fill the place of `node`, so the array doesnt have holes if (filler !== node) { var index = map[node.__mapid] || 0; // getting index of `node`. this is the only place we actually use map. if (index) { map[filler.__mapid] = index; } else { delete map[filler.__mapid]; } list[index] = filler; } delete map[node.__mapid]; } // invariantObservers(observable); // invariant(observable._observers.indexOf(node) === -1, \"INTERNAL ERROR remove already removed node2\"); } function queueForUnobservation(observable) { if (!observable.isPendingUnobservation) { // invariant(globalState.inBatch > 0, \"INTERNAL ERROR, remove should be called only inside batch\"); // invariant(observable._observers.length === 0, \"INTERNAL ERROR, shuold only queue for unobservation unobserved observables\"); observable.isPendingUnobservation = true; globalState.pendingUnobservations.push(observable); } } /** * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does. * During a batch `onBecomeUnobserved` will be called at most once per observable. * Avoids unnecessary recalculations. */ function startBatch() { globalState.inBatch++; } function endBatch() { if (--globalState.inBatch === 0) { runReactions(); // the batch is actually about to finish, all unobserving should happen here. var list = globalState.pendingUnobservations; for (var i = 0; i < list.length; i++) { var observable = list[i]; observable.isPendingUnobservation = false; if (observable.observers.length === 0) { observable.onBecomeUnobserved(); // NOTE: onBecomeUnobserved might push to `pendingUnobservations` } } globalState.pendingUnobservations = []; } } function reportObserved(observable) { var derivation = globalState.trackingDerivation; if (derivation !== null) { /** * Simple optimization, give each derivation run an unique id (runId) * Check if last time this observable was accessed the same runId is used * if this is the case, the relation is already known */ if (derivation.runId !== observable.lastAccessedBy) { observable.lastAccessedBy = derivation.runId; derivation.newObserving[derivation.unboundDepsCount++] = observable; } } else if (observable.observers.length === 0) { queueForUnobservation(observable); } } /** * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly * It will propagate changes to observers from previous run * It's hard or maybe impossible (with reasonable perf) to get it right with current approach * Hopefully self reruning autoruns aren't a feature people should depend on * Also most basic use cases should be ok */ // Called by Atom when its value changes function propagateChanged(observable) { // invariantLOS(observable, \"changed start\"); if (observable.lowestObserverState === IDerivationState.STALE) return; observable.lowestObserverState = IDerivationState.STALE; var observers = observable.observers; var i = observers.length; while (i--) { var d = observers[i]; if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale(); d.dependenciesState = IDerivationState.STALE; } // invariantLOS(observable, \"changed end\"); } // Called by ComputedValue when it recalculate and its value changed function propagateChangeConfirmed(observable) { // invariantLOS(observable, \"confirmed start\"); if (observable.lowestObserverState === IDerivationState.STALE) return; observable.lowestObserverState = IDerivationState.STALE; var observers = observable.observers; var i = observers.length; while (i--) { var d = observers[i]; if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE; } // invariantLOS(observable, \"confirmed end\"); } // Used by computed when its dependency changed, but we don't wan't to immediately recompute. function propagateMaybeChanged(observable) { // invariantLOS(observable, \"maybe start\"); if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return; observable.lowestObserverState = IDerivationState.POSSIBLY_STALE; var observers = observable.observers; var i = observers.length; while (i--) { var d = observers[i]; if (d.dependenciesState === IDerivationState.UP_TO_DATE) { d.dependenciesState = IDerivationState.POSSIBLY_STALE; d.onBecomeStale(); } } // invariantLOS(observable, \"maybe end\"); } var IDerivationState; (function (IDerivationState) { // before being run or (outside batch and not being observed) // at this point derivation is not holding any data about dependency tree IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\"; // no shallow dependency changed since last computation // won't recalculate derivation // this is what makes mobx fast IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\"; // some deep dependency changed, but don't know if shallow dependency changed // will require to check first if UP_TO_DATE or POSSIBLY_STALE // currently only ComputedValue will propagate POSSIBLY_STALE // // having this state is second big optimization: // don't have to recompute on every dependency change, but only when it's needed IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\"; // shallow dependency changed // will need to recompute when it's needed IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\"; })(IDerivationState || (exports.IDerivationState = IDerivationState = {})); var CaughtException = function () { function CaughtException(cause) { this.cause = cause; // Empty } return CaughtException; }(); function isCaughtException(e) { return e instanceof CaughtException; } /** * Finds out whether any dependency of the derivation has actually changed. * If dependenciesState is 1 then it will recalculate dependencies, * if any dependency changed it will propagate it by changing dependenciesState to 2. * * By iterating over the dependencies in the same order that they were reported and * stopping on the first change, all the recalculations are only called for ComputedValues * that will be tracked by derivation. That is because we assume that if the first x * dependencies of the derivation doesn't change then the derivation should run the same way * up until accessing x-th dependency. */ function shouldCompute(derivation) { switch (derivation.dependenciesState) { case IDerivationState.UP_TO_DATE: return false; case IDerivationState.NOT_TRACKING: case IDerivationState.STALE: return true; case IDerivationState.POSSIBLY_STALE: { var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction. var obs = derivation.observing, l = obs.length; for (var i = 0; i < l; i++) { var obj = obs[i]; if (isComputedValue(obj)) { try { obj.get(); } catch (e) { // we are not interested in the value *or* exception at this moment, but if there is one, notify all untrackedEnd(prevUntracked); return true; } // if ComputedValue `obj` actually changed it will be computed and propagated to its observers. // and `derivation` is an observer of `obj` if (derivation.dependenciesState === IDerivationState.STALE) { untrackedEnd(prevUntracked); return true; } } } changeDependenciesStateTo0(derivation); untrackedEnd(prevUntracked); return false; } } } function isComputingDerivation() { return globalState.trackingDerivation !== null; // filter out actions inside computations } function checkIfStateModificationsAreAllowed(atom) { var hasObservers$$1 = atom.observers.length > 0; // Should never be possible to change an observed observable from inside computed, see #798 if (globalState.computationDepth > 0 && hasObservers$$1) fail(getMessage(\"m031\") + atom.name); // Should not be possible to change observed state outside strict mode, except during initialization, see #563 if (!globalState.allowStateChanges && hasObservers$$1) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name); } /** * Executes the provided function `f` and tracks which observables are being accessed. * The tracking information is stored on the `derivation` object and the derivation is registered * as observer of any of the accessed observables. */ function trackDerivedFunction(derivation, f, context) { // pre allocate array allocation + room for variation in deps // array will be trimmed by bindDependencies changeDependenciesStateTo0(derivation); derivation.newObserving = new Array(derivation.observing.length + 100); derivation.unboundDepsCount = 0; derivation.runId = ++globalState.runId; var prevTracking = globalState.trackingDerivation; globalState.trackingDerivation = derivation; var result; try { result = f.call(context); } catch (e) { result = new CaughtException(e); } globalState.trackingDerivation = prevTracking; bindDependencies(derivation); return result; } /** * diffs newObserving with observing. * update observing to be newObserving with unique observables * notify observers that become observed/unobserved */ function bindDependencies(derivation) { // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, \"INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1\"); var prevObserving = derivation.observing; var observing = derivation.observing = derivation.newObserving; var lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE; derivation.newObserving = null; // newObserving shouldn't be needed outside tracking // Go through all new observables and check diffValue: (this list can contain duplicates): // 0: first occurrence, change to 1 and keep it // 1: extra occurrence, drop it var i0 = 0, l = derivation.unboundDepsCount; for (var i = 0; i < l; i++) { var dep = observing[i]; if (dep.diffValue === 0) { dep.diffValue = 1; if (i0 !== i) observing[i0] = dep; i0++; } // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined, // not hitting the condition if (dep.dependenciesState > lowestNewObservingDerivationState) { lowestNewObservingDerivationState = dep.dependenciesState; } } observing.length = i0; // Go through all old observables and check diffValue: (it is unique after last bindDependencies) // 0: it's not in new observables, unobserve it // 1: it keeps being observed, don't want to notify it. change to 0 l = prevObserving.length; while (l--) { var dep = prevObserving[l]; if (dep.diffValue === 0) { removeObserver(dep, derivation); } dep.diffValue = 0; } // Go through all new observables and check diffValue: (now it should be unique) // 0: it was set to 0 in last loop. don't need to do anything. // 1: it wasn't observed, let's observe it. set back to 0 while (i0--) { var dep = observing[i0]; if (dep.diffValue === 1) { dep.diffValue = 0; addObserver(dep, derivation); } } // Some new observed derivations might become stale during this derivation computation // so say had no chance to propagate staleness (#916) if (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) { derivation.dependenciesState = lowestNewObservingDerivationState; derivation.onBecomeStale(); } } function clearObserving(derivation) { // invariant(globalState.inBatch > 0, \"INTERNAL ERROR clearObserving should be called only inside batch\"); var obs = derivation.observing; derivation.observing = []; var i = obs.length; while (i--) { removeObserver(obs[i], derivation); }derivation.dependenciesState = IDerivationState.NOT_TRACKING; } function untracked(action) { var prev = untrackedStart(); var res = action(); untrackedEnd(prev); return res; } function untrackedStart() { var prev = globalState.trackingDerivation; globalState.trackingDerivation = null; return prev; } function untrackedEnd(prev) { globalState.trackingDerivation = prev; } /** * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0 * */ function changeDependenciesStateTo0(derivation) { if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return; derivation.dependenciesState = IDerivationState.UP_TO_DATE; var obs = derivation.observing; var i = obs.length; while (i--) { obs[i].lowestObserverState = IDerivationState.UP_TO_DATE; } } var Reaction = function () { function Reaction(name, onInvalidate) { if (name === void 0) { name = \"Reaction@\" + getNextId(); } this.name = name; this.onInvalidate = onInvalidate; this.observing = []; // nodes we are looking at. Our value depends on these nodes this.newObserving = []; this.dependenciesState = IDerivationState.NOT_TRACKING; this.diffValue = 0; this.runId = 0; this.unboundDepsCount = 0; this.__mapid = \"#\" + getNextId(); this.isDisposed = false; this._isScheduled = false; this._isTrackPending = false; this._isRunning = false; } Reaction.prototype.onBecomeStale = function () { this.schedule(); }; Reaction.prototype.schedule = function () { if (!this._isScheduled) { this._isScheduled = true; globalState.pendingReactions.push(this); runReactions(); } }; Reaction.prototype.isScheduled = function () { return this._isScheduled; }; /** * internal, use schedule() if you intend to kick off a reaction */ Reaction.prototype.runReaction = function () { if (!this.isDisposed) { startBatch(); this._isScheduled = false; if (shouldCompute(this)) { this._isTrackPending = true; this.onInvalidate(); if (this._isTrackPending && isSpyEnabled()) { // onInvalidate didn't trigger track right away.. spyReport({ object: this, type: \"scheduled-reaction\" }); } } endBatch(); } }; Reaction.prototype.track = function (fn) { startBatch(); var notify = isSpyEnabled(); var startTime; if (notify) { startTime = Date.now(); spyReportStart({ object: this, type: \"reaction\", fn: fn }); } this._isRunning = true; var result = trackDerivedFunction(this, fn, undefined); this._isRunning = false; this._isTrackPending = false; if (this.isDisposed) { // disposed during last run. Clean up everything that was bound after the dispose call. clearObserving(this); } if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause); if (notify) { spyReportEnd({ time: Date.now() - startTime }); } endBatch(); }; Reaction.prototype.reportExceptionInDerivation = function (error) { var _this = this; if (this.errorHandler) { this.errorHandler(error, this); return; } var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this; var messageToUser = getMessage(\"m037\"); console.error(message || messageToUser /* latter will not be true, make sure uglify doesn't remove */, error); /** If debugging brought you here, please, read the above message :-). Tnx! */ if (isSpyEnabled()) { spyReport({ type: \"error\", message: message, error: error, object: this }); } globalState.globalReactionErrorHandlers.forEach(function (f) { return f(error, _this); }); }; Reaction.prototype.dispose = function () { if (!this.isDisposed) { this.isDisposed = true; if (!this._isRunning) { startBatch(); clearObserving(this); // if disposed while running, clean up later. Maybe not optimal, but rare case endBatch(); } } }; Reaction.prototype.getDisposer = function () { var r = this.dispose.bind(this); r.$mobx = this; r.onError = registerErrorHandler; return r; }; Reaction.prototype.toString = function () { return \"Reaction[\" + this.name + \"]\"; }; Reaction.prototype.whyRun = function () { var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) { return dep.name; }); return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n \" + joinStrings(observing) + \"\\n \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\"; }; return Reaction; }(); function registerErrorHandler(handler) { invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\"); invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\"); this.$mobx.errorHandler = handler; } function onReactionError(handler) { globalState.globalReactionErrorHandlers.push(handler); return function () { var idx = globalState.globalReactionErrorHandlers.indexOf(handler); if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1); }; } /** * Magic number alert! * Defines within how many times a reaction is allowed to re-trigger itself * until it is assumed that this is gonna be a never ending loop... */ var MAX_REACTION_ITERATIONS = 100; var reactionScheduler = function reactionScheduler(f) { return f(); }; function runReactions() { // Trampolining, if runReactions are already running, new reactions will be picked up if (globalState.inBatch > 0 || globalState.isRunningReactions) return; reactionScheduler(runReactionsHelper); } function runReactionsHelper() { globalState.isRunningReactions = true; var allReactions = globalState.pendingReactions; var iterations = 0; // While running reactions, new reactions might be triggered. // Hence we work with two variables and check whether // we converge to no remaining reactions after a while. while (allReactions.length > 0) { if (++iterations === MAX_REACTION_ITERATIONS) { console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0])); allReactions.splice(0); // clear reactions } var remainingReactions = allReactions.splice(0); for (var i = 0, l = remainingReactions.length; i < l; i++) { remainingReactions[i].runReaction(); } } globalState.isRunningReactions = false; } var isReaction = createInstanceofPredicate(\"Reaction\", Reaction); function setReactionScheduler(fn) { var baseScheduler = reactionScheduler; reactionScheduler = function reactionScheduler(f) { return fn(function () { return baseScheduler(f); }); }; } function asReference(value) { deprecated(\"asReference is deprecated, use observable.ref instead\"); return observable.ref(value); } function asStructure(value) { deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\"); return observable.struct(value); } function asFlat(value) { deprecated(\"asFlat is deprecated, use observable.shallow instead\"); return observable.shallow(value); } function asMap(data) { deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\"); return observable.map(data || {}); } function createComputedDecorator(equals) { return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) { invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\")); invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\")); var adm = asObservableObject(target, \"\"); defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, equals, false); }, function (name) { var observable = this.$mobx.values[name]; if (observable === undefined) return undefined; return observable.get(); }, function (name, value) { this.$mobx.values[name].set(value); }, false, false); } var computedDecorator = createComputedDecorator(comparer.default); var computedStructDecorator = createComputedDecorator(comparer.structural); /** * Decorator for class properties: @computed get value() { return expr; }. * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`; */ var computed = function computed(arg1, arg2, arg3) { if (typeof arg2 === \"string\") { return computedDecorator.apply(null, arguments); } invariant(typeof arg1 === \"function\", getMessage(\"m011\")); invariant(arguments.length < 3, getMessage(\"m012\")); var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {}; opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter; var equals = opts.equals ? opts.equals : opts.compareStructural || opts.struct ? comparer.structural : comparer.default; return new ComputedValue(arg1, opts.context, equals, opts.name || arg1.name || \"\", opts.setter); }; computed.struct = computedStructDecorator; computed.equals = createComputedDecorator; function getAtom(thing, property) { if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) { if (isObservableArray(thing)) { invariant(property === undefined, getMessage(\"m036\")); return thing.$mobx.atom; } if (isObservableMap(thing)) { var anyThing = thing; if (property === undefined) return getAtom(anyThing._keys); var observable = anyThing._data[property] || anyThing._hasMap[property]; invariant(!!observable, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\"); return observable; } // Initializers run lazily when transpiling to babel, so make sure they are run... runLazyInitializers(thing); if (property && !thing.$mobx) thing[property]; // See #1072 // TODO: remove in 4.0 if (isObservableObject(thing)) { if (!property) return fail(\"please specify a property\"); var observable = thing.$mobx.values[property]; invariant(!!observable, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\"); return observable; } if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) { return thing; } } else if (typeof thing === \"function\") { if (isReaction(thing.$mobx)) { // disposer function return thing.$mobx; } } return fail(\"Cannot obtain atom from \" + thing); } function getAdministration(thing, property) { invariant(thing, \"Expecting some object\"); if (property !== undefined) return getAdministration(getAtom(thing, property)); if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing; if (isObservableMap(thing)) return thing; // Initializers run lazily when transpiling to babel, so make sure they are run... runLazyInitializers(thing); if (thing.$mobx) return thing.$mobx; invariant(false, \"Cannot obtain administration from \" + thing); } function getDebugName(thing, property) { var named; if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing); // valid for arrays as well return named.name; } function isComputed(value, property) { if (value === null || value === undefined) return false; if (property !== undefined) { if (isObservableObject(value) === false) return false; var atom = getAtom(value, property); return isComputedValue(atom); } return isComputedValue(value); } function observe(thing, propOrCb, cbOrFire, fireImmediately) { if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire); } function observeObservable(thing, listener, fireImmediately) { return getAdministration(thing).observe(listener, fireImmediately); } function observeObservableProperty(thing, property, listener, fireImmediately) { return getAdministration(thing, property).observe(listener, fireImmediately); } function intercept(thing, propOrHandler, handler) { if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler); } function interceptInterceptable(thing, handler) { return getAdministration(thing).intercept(handler); } function interceptProperty(thing, property, handler) { return getAdministration(thing, property).intercept(handler); } /** * expr can be used to create temporarily views inside views. * This can be improved to improve performance if a value changes often, but usually doesn't affect the outcome of an expression. * * In the following example the expression prevents that a component is rerender _each time_ the selection changes; * instead it will only rerenders when the current todo is (de)selected. * * reactiveComponent((props) => { * const todo = props.todo; * const isSelected = mobx.expr(() => props.viewState.selection === todo); * return {todo.title} * }); * */ function expr(expr, scope) { if (!isComputingDerivation()) console.warn(getMessage(\"m013\")); // optimization: would be more efficient if the expr itself wouldn't be evaluated first on the next change, but just a 'changed' signal would be fired return computed(expr, { context: scope }).get(); } function toJS(source, detectCycles, __alreadySeen) { if (detectCycles === void 0) { detectCycles = true; } if (__alreadySeen === void 0) { __alreadySeen = []; } // optimization: using ES6 map would be more efficient! // optimization: lift this function outside toJS, this makes recursion expensive function cache(value) { if (detectCycles) __alreadySeen.push([source, value]); return value; } if (isObservable(source)) { if (detectCycles && __alreadySeen === null) __alreadySeen = []; if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") { for (var i = 0, l = __alreadySeen.length; i < l; i++) { if (__alreadySeen[i][0] === source) return __alreadySeen[i][1]; } } if (isObservableArray(source)) { var res = cache([]); var toAdd = source.map(function (value) { return toJS(value, detectCycles, __alreadySeen); }); res.length = toAdd.length; for (var i = 0, l = toAdd.length; i < l; i++) { res[i] = toAdd[i]; }return res; } if (isObservableObject(source)) { var res = cache({}); for (var key in source) { res[key] = toJS(source[key], detectCycles, __alreadySeen); }return res; } if (isObservableMap(source)) { var res_1 = cache({}); source.forEach(function (value, key) { return res_1[key] = toJS(value, detectCycles, __alreadySeen); }); return res_1; } if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen); } return source; } function createTransformer(transformer, onCleanup) { invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\"); // Memoizes: object id -> reactive view that applies transformer to the object var objectCache = {}; // If the resetId changes, we will clear the object cache, see #163 // This construction is used to avoid leaking refs to the objectCache directly var resetId = globalState.resetId; // Local transformer class specifically for this transformer var Transformer = function (_super) { __extends(Transformer, _super); function Transformer(sourceIdentifier, sourceObject) { var _this = _super.call(this, function () { return transformer(sourceObject); }, undefined, comparer.default, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this; _this.sourceIdentifier = sourceIdentifier; _this.sourceObject = sourceObject; return _this; } Transformer.prototype.onBecomeUnobserved = function () { var lastValue = this.value; _super.prototype.onBecomeUnobserved.call(this); delete objectCache[this.sourceIdentifier]; if (onCleanup) onCleanup(lastValue, this.sourceObject); }; return Transformer; }(ComputedValue); return function (object) { if (resetId !== globalState.resetId) { objectCache = {}; resetId = globalState.resetId; } var identifier = getMemoizationId(object); var reactiveTransformer = objectCache[identifier]; if (reactiveTransformer) return reactiveTransformer.get(); // Not in cache; create a reactive view reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object); return reactiveTransformer.get(); }; } function getMemoizationId(object) { if (typeof object === 'string' || typeof object === 'number') return object; if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object or primitive value, got: \" + object); var tid = object.$transformId; if (tid === undefined) { tid = getNextId(); addHiddenProp(object, \"$transformId\", tid); } return tid; } function log(msg) { console.log(msg); return msg; } function whyRun(thing, prop) { switch (arguments.length) { case 0: thing = globalState.trackingDerivation; if (!thing) return log(getMessage(\"m024\")); break; case 2: thing = getAtom(thing, prop); break; } thing = getAtom(thing); if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun()); return fail(getMessage(\"m025\")); } function getDependencyTree(thing, property) { return nodeToDependencyTree(getAtom(thing, property)); } function nodeToDependencyTree(node) { var result = { name: node.name }; if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree); return result; } function getObserverTree(thing, property) { return nodeToObserverTree(getAtom(thing, property)); } function nodeToObserverTree(node) { var result = { name: node.name }; if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree); return result; } function interceptReads(thing, propOrHandler, handler) { var target; if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) { target = getAdministration(thing); } else if (isObservableObject(thing)) { if (typeof propOrHandler !== \"string\") return fail(\"InterceptReads can only be used with a specific property, not with an object in general\"); target = getAdministration(thing, propOrHandler); } else { return fail(\"Expected observable map, object or array as first array\"); } if (target.dehancer !== undefined) return fail(\"An intercept reader was already established\"); target.dehancer = typeof propOrHandler === \"function\" ? propOrHandler : handler; return function () { target.dehancer = undefined; }; } /** * (c) Michel Weststrate 2015 - 2016 * MIT Licensed * * Welcome to the mobx sources! To get an global overview of how MobX internally works, * this is a good place to start: * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74 * * Source folders: * =============== * * - api/ Most of the public static methods exposed by the module can be found here. * - core/ Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here. * - types/ All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`. * - utils/ Utility stuff. * */ var extras = { allowStateChanges: allowStateChanges, deepEqual: deepEqual, getAtom: getAtom, getDebugName: getDebugName, getDependencyTree: getDependencyTree, getAdministration: getAdministration, getGlobalState: getGlobalState, getObserverTree: getObserverTree, interceptReads: interceptReads, isComputingDerivation: isComputingDerivation, isSpyEnabled: isSpyEnabled, onReactionError: onReactionError, reserveArrayBuffer: reserveArrayBuffer, resetGlobalState: resetGlobalState, isolateGlobalState: isolateGlobalState, shareGlobalState: shareGlobalState, spyReport: spyReport, spyReportEnd: spyReportEnd, spyReportStart: spyReportStart, setReactionScheduler: setReactionScheduler }; var everything = { Reaction: Reaction, untracked: untracked, Atom: Atom, BaseAtom: BaseAtom, useStrict: useStrict, isStrictModeEnabled: isStrictModeEnabled, spy: spy, comparer: comparer, asReference: asReference, asFlat: asFlat, asStructure: asStructure, asMap: asMap, isModifierDescriptor: isModifierDescriptor, isObservableObject: isObservableObject, isBoxedObservable: isObservableValue, isObservableArray: isObservableArray, ObservableMap: ObservableMap, isObservableMap: isObservableMap, map: map, transaction: transaction, observable: observable, computed: computed, isObservable: isObservable, isComputed: isComputed, extendObservable: extendObservable, extendShallowObservable: extendShallowObservable, observe: observe, intercept: intercept, autorun: autorun, autorunAsync: autorunAsync, when: when, reaction: reaction, action: action, isAction: isAction, runInAction: runInAction, expr: expr, toJS: toJS, createTransformer: createTransformer, whyRun: whyRun, isArrayLike: isArrayLike, extras: extras }; var warnedAboutDefaultExport = false; var _loop_1 = function _loop_1(p) { var val = everything[p]; Object.defineProperty(everything, p, { get: function get() { if (!warnedAboutDefaultExport) { warnedAboutDefaultExport = true; console.warn('Using default export (`import mobx from \\'mobx\\'`) is deprecated ' + 'and won’t work in mobx@4.0.0\\n' + 'Use `import * as mobx from \\'mobx\\'` instead'); } return val; } }); }; for (var p in everything) { _loop_1(p); } if ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") { __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({ spy: spy, extras: extras }); } exports.extras = extras; exports.Reaction = Reaction; exports.untracked = untracked; exports.IDerivationState = IDerivationState; exports.Atom = Atom; exports.BaseAtom = BaseAtom; exports.useStrict = useStrict; exports.isStrictModeEnabled = isStrictModeEnabled; exports.spy = spy; exports.comparer = comparer; exports.asReference = asReference; exports.asFlat = asFlat; exports.asStructure = asStructure; exports.asMap = asMap; exports.isModifierDescriptor = isModifierDescriptor; exports.isObservableObject = isObservableObject; exports.isBoxedObservable = isObservableValue; exports.isObservableArray = isObservableArray; exports.ObservableMap = ObservableMap; exports.isObservableMap = isObservableMap; exports.map = map; exports.transaction = transaction; exports.observable = observable; exports.IObservableFactories = IObservableFactories; exports.computed = computed; exports.isObservable = isObservable; exports.isComputed = isComputed; exports.extendObservable = extendObservable; exports.extendShallowObservable = extendShallowObservable; exports.observe = observe; exports.intercept = intercept; exports.autorun = autorun; exports.autorunAsync = autorunAsync; exports.when = when; exports.reaction = reaction; exports.action = action; exports.isAction = isAction; exports.runInAction = runInAction; exports.expr = expr; exports.toJS = toJS; exports.createTransformer = createTransformer; exports.whyRun = whyRun; exports.isArrayLike = isArrayLike; exports.default = everything; /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4))) /***/ }), /* 2 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); var _icons = __webpack_require__(6); var _constants = __webpack_require__(0); var _translator = __webpack_require__(7); var translator = _interopRequireWildcard(_translator); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } } var culture = /^([^-]{1,3})(-|$)/; var $ = function $(x) { return (0, translator.default)(x); }; function renderHeader(_ref, instance) { var meta = _ref.meta, user = _ref.user, reactions = _ref.reactions; var container = document.createElement('div'); container.lang = culture.test(instance.lang) ? instance.lang : \"en-US\"; container.className = 'gitment-container gitment-header-container'; var likeButton = document.createElement('span'); var likedReaction = reactions.find(function (reaction) { return reaction.content === 'heart' && reaction.user.login === user.login; }); likeButton.className = 'gitment-header-like-btn'; likeButton.innerHTML = '\\n ' + _icons.heart + '\\n ' + (likedReaction ? 'Unlike' : 'Like') + '\\n ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 ' + meta.reactions.heart + ' Liked' : '') + '\\n '; if (likedReaction) { likeButton.classList.add('liked'); likeButton.onclick = function () { return instance.unlike(); }; } else { likeButton.classList.remove('liked'); likeButton.onclick = function () { return instance.like(); }; } container.appendChild(likeButton); var commentsCount = document.createElement('span'); commentsCount.innerHTML = '\\n ' + (meta.comments ? ' \\u2022 ' + meta.comments + ' Comments' : '') + '\\n '; container.appendChild(commentsCount); var issueLink = document.createElement('a'); issueLink.className = 'gitment-header-issue-link'; issueLink.href = meta.html_url || \"javascript:void(0)\"; issueLink.target = '_blank'; issueLink.innerText = $('Issue Page'); container.appendChild(issueLink); return container; } function renderComments(_ref2, instance) { var meta = _ref2.meta, comments = _ref2.comments, commentReactions = _ref2.commentReactions, currentPage = _ref2.currentPage, user = _ref2.user, error = _ref2.error; var container = document.createElement('div'); container.lang = culture.test(instance.lang) ? instance.lang : \"en-US\"; container.className = 'gitment-container gitment-comments-container'; if (error) { var errorBlock = document.createElement('div'); errorBlock.className = 'gitment-comments-error'; if (error === _constants.NOT_INITIALIZED_ERROR && user.login && ~(instance.admin || [instance.owner]).map(function (x) { return x.toLowerCase(); }).indexOf(user.login.toLowerCase())) { // && user.login.toLowerCase() === instance.owner.toLowerCase()) { var initHint = document.createElement('div'); var initButton = document.createElement('button'); initButton.className = 'gitment-comments-init-btn'; initButton.onclick = function () { initButton.setAttribute('disabled', true); instance.init().catch(function (e) { initButton.removeAttribute('disabled'); alert(e); }); }; initButton.innerText = $('Initialize Comments'); initHint.appendChild(initButton); errorBlock.appendChild(initHint); } else { errorBlock.innerText = $(error); } container.appendChild(errorBlock); return container; } else if (comments === undefined) { var loading = document.createElement('div'); loading.innerText = $('Loading comments...'); loading.className = 'gitment-comments-loading'; container.appendChild(loading); return container; } else if (!comments.length) { var emptyBlock = document.createElement('div'); emptyBlock.className = 'gitment-comments-empty'; emptyBlock.innerText = $('No Comment Yet'); container.appendChild(emptyBlock); return container; } var commentsList = document.createElement('ul'); commentsList.className = 'gitment-comments-list'; comments.forEach(function (comment) { var createDate = new Date(comment.created_at); var updateDate = new Date(comment.updated_at); var commentItem = document.createElement('li'); commentItem.className = 'gitment-comment'; commentItem.innerHTML = '\\n \\n \\n \\n \\n \\n \\n ' + comment.user.login + '\\n \\n commented on\\n ' + createDate.toDateString() + '\\n ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 edited' : '') + '\\n ' + _icons.heart + ' ' + (comment.reactions.heart || '') + '\\n \\n ' + comment.body_html + '\\n \\n '; var likeButton = commentItem.querySelector('.gitment-comment-like-btn'); var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) { return reaction.content === 'heart' && reaction.user.login === user.login; }); if (likedReaction) { likeButton.classList.add('liked'); likeButton.onclick = function () { return instance.unlikeAComment(comment.id); }; } else { likeButton.classList.remove('liked'); likeButton.onclick = function () { return instance.likeAComment(comment.id); }; } // dirty // use a blank image to trigger height calculating when element rendered var imgTrigger = document.createElement('img'); var markdownBody = commentItem.querySelector('.gitment-comment-body'); imgTrigger.className = 'gitment-hidden'; imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"; imgTrigger.onload = function () { if (markdownBody.clientHeight > instance.maxCommentHeight) { markdownBody.classList.add('gitment-comment-body-folded'); markdownBody.style.maxHeight = instance.maxCommentHeight + 'px'; markdownBody.title = 'Click to Expand'; markdownBody.onclick = function () { markdownBody.classList.remove('gitment-comment-body-folded'); markdownBody.style.maxHeight = ''; markdownBody.title = ''; markdownBody.onclick = null; }; } }; commentItem.appendChild(imgTrigger); commentsList.appendChild(commentItem); }); container.appendChild(commentsList); if (meta) { var pageCount = Math.ceil(meta.comments / instance.perPage); if (pageCount > 1) { var pagination = document.createElement('ul'); pagination.className = 'gitment-comments-pagination'; if (currentPage > 1) { var previousButton = document.createElement('li'); previousButton.className = 'gitment-comments-page-item'; previousButton.innerText = $('Previous'); previousButton.onclick = function () { return instance.goto(currentPage - 1); }; pagination.appendChild(previousButton); } var _loop = function _loop(i) { var pageItem = document.createElement('li'); pageItem.className = 'gitment-comments-page-item'; pageItem.innerText = i; pageItem.onclick = function () { return instance.goto(i); }; if (currentPage === i) pageItem.classList.add('gitment-selected'); pagination.appendChild(pageItem); }; for (var i = 1; i 1 && arguments[1] !== undefined ? arguments[1] : '?'; var queryString = Object.keys(query).map(function (key) { return key + '=' + encodeURIComponent(query[key] || ''); }).join('&'); return queryString ? prefix + queryString : ''; } }; function ajaxFactory(method) { return function (apiPath) { var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com'; var req = new XMLHttpRequest(); var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY); if (base !== 'https://api.github.com') token = null; var url = '' + base + apiPath; var body = null; if (method === 'GET' || method === 'DELETE') { url += isString(data) ? data : Query.stringify(data); } var p = new Promise(function (resolve, reject) { req.addEventListener('load', function () { var contentType = req.getResponseHeader('content-type'); var res = req.responseText; var data = res; if (/urlencoded/.test(contentType)) { data = req.responseText ? Query.parse(res) : {}; if (data.error) return reject(new Error(data.error_description)); } else if (/json/.test(contentType)) { data = req.responseText ? JSON.parse(res) : {}; if (data.message) return reject(new Error(data.message)); } resolve(data); }); req.addEventListener('error', function (error) { return reject(error); }); }); req.open(method, url, true); req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json, application/x-www-form-urlencoded'); if (token) { req.setRequestHeader('Authorization', 'token ' + token); } if (method !== 'GET' && method !== 'DELETE') { if (isString(data)) { body = data; req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); } else { body = JSON.stringify(data); req.setRequestHeader('Content-Type', 'application/json'); } } req.send(body); return p; }; } var http = exports.http = { get: ajaxFactory('GET'), post: ajaxFactory('POST'), delete: ajaxFactory('DELETE'), put: ajaxFactory('PUT') }; /***/ }), /* 4 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; var g; // This works in non-strict mode g = function () { return this; }(); try { // This works if eval is allowed (see CSP) g = g || Function(\"return this\")() || (1, eval)(\"this\"); } catch (e) { // This works if the window reference is available if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window; } // g can still be undefined, but nothing to do about it... // We return undefined, instead of nothing here, so it's // easier to handle this case. if(!global) { ...} module.exports = g; /***/ }), /* 5 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _mobx = __webpack_require__(1); var _constants = __webpack_require__(0); var _utils = __webpack_require__(3); var _default = __webpack_require__(2); var _default2 = _interopRequireDefault(_default); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } // @see: https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/about-scopes-for-oauth-apps var scope = 'public_repo'; // Github setting of 'Authorization callback URL' in your OAuth application var force_redirect_protocol = '$&'; // A RegExp to match protocol and domain var rx_url_with_protocol = /^((https?:\\/\\/+){0,1}[^\\/]*)(.*)/; function extendRenderer(instance, renderer) { instance[renderer] = function (container) { var targetContainer = (0, _utils.getTargetContainer)(container); var render = instance.theme[renderer] || instance.defaultTheme[renderer]; (0, _mobx.autorun)(function () { var e = render(instance.state, instance); if (e) { if (targetContainer.firstChild) { targetContainer.replaceChild(e, targetContainer.firstChild); } else { targetContainer.appendChild(e); } } }); return targetContainer; }; } var Gitment = function () { _createClass(Gitment, [{ key: 'accessToken', get: function get() { return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY); }, set: function set(token) { localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token); } }, { key: 'loginLink', get: function get() { var oauthUri = 'https://github.com/login/oauth/authorize'; var redirect_uri = this.oauth.redirect_uri || window.location.href.replace(/^https?/i, this.oauth.redirect_protocol || force_redirect_protocol); var oauthParams = Object.assign({ scope: scope, redirect_uri: redirect_uri }, this.oauth); return '' + oauthUri + _utils.Query.stringify(oauthParams); } }]); function Gitment() { var _this = this; var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, Gitment); this.defaultTheme = _default2.default; this.useTheme(_default2.default); var internalId; Object.defineProperties(this, { 'updateCount': { value: new Function(), writable: true }, 'id': { get: function get() { return internalId; }, set: function set(id) { return internalId = id !== window.location.href ? id : '' + window.location.origin + window.location.pathname + window.location.search; } } }); Object.assign(this, { id: window.location.href, title: window.document.title, link: window.location.href, desc: '', labels: [], theme: _default2.default, oauth: {}, perPage: 20, maxCommentHeight: 250 }, options); this.useTheme(this.theme); var user = {}; try { var userInfo = localStorage.getItem(_constants.LS_USER_KEY); if (this.accessToken && userInfo) { Object.assign(user, JSON.parse(userInfo), { fromCache: true }); } } catch (e) { localStorage.removeItem(_constants.LS_USER_KEY); } this.state = (0, _mobx.observable)({ user: user, error: null, meta: {}, comments: undefined, reactions: [], commentReactions: {}, currentPage: 1 }); // NOTE: the proxy_gateway accept form-urlencoded only!!! // - PHP implement at https://github.com/aimingoo/intersect var query = _utils.Query.parse(); if (query.code) { var _oauth = this.oauth, client_id = _oauth.client_id, client_secret = _oauth.client_secret, proxy_gateway = _oauth.proxy_gateway; var code = query.code; delete query.code; var search = _utils.Query.stringify(query); var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash; history.replaceState({}, '', replacedUrl); Object.assign(this, { id: replacedUrl, link: replacedUrl }, options); this.state.user.isLoggingIn = true; var logging = !proxy_gateway ? _utils.http.post('https://gh-oauth.imsun.net', { code: code, client_id: client_id, client_secret: client_secret }, '') : _utils.http.post('/login/oauth/access_token', 'code=' + code + '&client_id=' + client_id, proxy_gateway); logging.then(function (data) { _this.accessToken = data.access_token; _this.update(); }).catch(function (e) { _this.state.user.isLoggingIn = false; alert(e); }); } else { this.update(); } } _createClass(Gitment, [{ key: 'init', value: function init() { var _this2 = this; return this.createIssue().then(function () { return _this2.loadComments(); }).then(function (comments) { _this2.state.error = null; return comments; }); } }, { key: 'useTheme', value: function useTheme() { var _this3 = this; var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; this.theme = theme; var renderers = Object.keys(this.theme); renderers.forEach(function (renderer) { return extendRenderer(_this3, renderer); }); } }, { key: 'update', value: function update() { var _this4 = this; return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () { return Promise.all([_this4.loadComments().then(function () { return _this4.loadCommentReactions(); }), _this4.loadReactions()]); }).catch(function (e) { return _this4.state.error = e; }); } }, { key: 'markdown', value: function markdown(text) { return _utils.http.post('/markdown', { text: text, mode: 'gfm' }); } }, { key: 'createIssue', value: function createIssue() { var _this5 = this; var id = this.id, owner = this.owner, repo = this.repo, title = this.title, link = this.link, desc = this.desc, labels = this.labels; return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', { title: title, labels: labels.concat(['gitment', id]), body: link + '\\n\\n' + desc }).then(function (meta) { _this5.state.meta = meta; return meta; }); } }, { key: 'getIssue', value: function getIssue() { if (this.state.meta.id) return Promise.resolve(this.state.meta); return this.loadMeta(); } }, { key: 'post', value: function post(body) { var _this6 = this; return this.getIssue().then(function (issue) { var matched = issue.comments_url.match(rx_url_with_protocol); return _utils.http.post(matched[3], { body: body }, matched[1] || undefined); }).then(function (data) { _this6.state.meta.comments++; _this6.updateCount(); var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage); if (_this6.state.currentPage === pageCount) { _this6.state.comments.push(data); } return data; }); } }, { key: 'loadMeta', value: function loadMeta() { var _this7 = this; var id = this.id, owner = this.owner, admin = this.admin, repo = this.repo; return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', { labels: id }).then(function (issues) { if (issues.length) { // recheck creator for organization // - or check 'issue.user.login and issue.user.site_admin' ? var allowed = (admin || [owner]).map(function (x) { return x.toLowerCase(); }); issues = issues.filter(function (issue) { return ~allowed.indexOf(issue.user.login.toLowerCase()); }).sort(function (left, right) { return new Date(left.created_at) - new Date(right.created_at); }); } if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR); _this7.state.meta = issues[0]; _this7.updateCount(); return issues[0]; }); } }, { key: 'loadComments', value: function loadComments() { var _this8 = this; var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage; return this.getIssue().then(function (issue) { var matched = issue.comments_url.match(rx_url_with_protocol); return _utils.http.get(matched[3], { page: page, per_page: _this8.perPage }, matched[1] || undefined); }).then(function (comments) { _this8.state.comments = comments; return comments; }); } }, { key: 'loadUserInfo', value: function loadUserInfo() { var _this9 = this; if (!this.accessToken) { this.logout(); return Promise.resolve({}); } return _utils.http.get('/user').then(function (user) { _this9.state.user = user; localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user)); return user; }); } }, { key: 'loadReactions', value: function loadReactions() { var _this10 = this; if (!this.accessToken) { this.state.reactions = []; return Promise.resolve([]); } return this.getIssue().then(function (issue) { if (!issue.reactions.total_count) return []; return _utils.http.get(issue.reactions.url, {}, ''); }).then(function (reactions) { _this10.state.reactions = reactions; return reactions; }); } }, { key: 'loadCommentReactions', value: function loadCommentReactions() { var _this11 = this; if (!this.accessToken) { this.state.commentReactions = {}; return Promise.resolve([]); } var comments = this.state.comments; var comentReactions = {}; return Promise.all(comments.map(function (comment) { if (!comment.reactions.total_count) return []; var owner = _this11.owner, repo = _this11.repo; return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {}); })).then(function (reactionsArray) { comments.forEach(function (comment, index) { comentReactions[comment.id] = reactionsArray[index]; }); _this11.state.commentReactions = comentReactions; return comentReactions; }); } }, { key: 'login', value: function login() { window.location.href = this.loginLink; } }, { key: 'logout', value: function logout() { localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY); localStorage.removeItem(_constants.LS_USER_KEY); this.state.user = {}; } }, { key: 'goto', value: function goto(page) { this.state.currentPage = page; this.state.comments = undefined; return this.loadComments(page); } }, { key: 'like', value: function like() { var _this12 = this; if (!this.accessToken) { alert('Login to Like'); return Promise.reject(); } var owner = this.owner, repo = this.repo; return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', { content: 'heart' }).then(function (reaction) { _this12.state.reactions.push(reaction); _this12.state.meta.reactions.heart++; }); } }, { key: 'unlike', value: function unlike() { var _this13 = this; if (!this.accessToken) return Promise.reject(); var _state = this.state, user = _state.user, reactions = _state.reactions; var index = reactions.findIndex(function (reaction) { return reaction.user.login === user.login; }); return _utils.http.delete('/reactions/' + reactions[index].id).then(function () { reactions.splice(index, 1); _this13.state.meta.reactions.heart--; }); } }, { key: 'likeAComment', value: function likeAComment(commentId) { var _this14 = this; if (!this.accessToken) { alert('Login to Like'); return Promise.reject(); } var owner = this.owner, repo = this.repo; var comment = this.state.comments.find(function (comment) { return comment.id === commentId; }); return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', { content: 'heart' }).then(function (reaction) { _this14.state.commentReactions[commentId].push(reaction); comment.reactions.heart++; }); } }, { key: 'unlikeAComment', value: function unlikeAComment(commentId) { if (!this.accessToken) return Promise.reject(); var reactions = this.state.commentReactions[commentId]; var comment = this.state.comments.find(function (comment) { return comment.id === commentId; }); var user = this.state.user; var index = reactions.findIndex(function (reaction) { return reaction.user.login === user.login; }); return _utils.http.delete('/reactions/' + reactions[index].id).then(function () { reactions.splice(index, 1); comment.reactions.heart--; }); } }]); return Gitment; }(); module.exports = Gitment; /***/ }), /* 6 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); /** * Modified from https://github.com/evil-icons/evil-icons */ var close = exports.close = ''; var github = exports.github = ''; var heart = exports.heart = ''; var spinner = exports.spinner = ''; /***/ }), /* 7 */ /***/ (function(module, exports, __webpack_require__) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); exports.english = english; exports.chinese = chinese; exports.chineseTraditional = chineseTraditional; exports.fromLanguageCode = fromLanguageCode; function english(Text) { return Text; } function chinese(Text) { return { 'Issue Page': '所有评论', 'Initialize Comments': '初始化本文的评论页', 'Loading comments...': '加载评论...', 'Error: Comments Not Initialized': '(未开放评论)', 'No Comment Yet': '(还没有评论)', 'Previous': '上一页', 'Next': '下一页', 'Nothing to preview': '（没有预览）', 'Loading preview...': '加载预览...', 'Submitting...': '正在提交评论...', 'Comment': '发送', 'Write': '评论', 'Preview': '预览', 'Logging in...': '登入中...', 'Login to Comment': '请登入以发表评论', 'Leave a comment': '(发表评论)', 'Login': '登入', 'Logout': '退出' }[Text] || Text; } function chineseTraditional(Text) { return { 'Issue Page': '所有評論', 'Initialize Comments': '初始化本文的評論頁', 'Loading comments...': '加載評論...', 'Error: Comments Not Initialized': '(未開放評論)', 'No Comment Yet': '(還沒有評論)', 'Previous': '上一頁', 'Next': '下一頁', 'Nothing to preview': '（沒有預覽）', 'Loading preview...': '加載預覽...', 'Submitting...': '正在提交評論...', 'Comment': '發送', 'Write': '評論', 'Preview': '預覽', 'Logging in...': '登入中...', 'Login to Comment': '請登入以發表評論', 'Leave a comment': '(發表評論)', 'Login': '登入', 'Logout': '登出' }[Text] || Text; } // @see: // https://www.w3.org/TR/1999/REC-html401-19991224/struct/dirlang.html#h-8.1.1 // https://gist.github.com/JamieMason/3748498 function fromLanguageCode(code) { var culture = /^([^-]+)-/; return { 'en': english, 'zh': chinese, 'zh-CN': chinese, 'zh-CHS': chinese, 'zh-TW': chineseTraditional, 'zh-HK': chineseTraditional, 'zh-CHT': chineseTraditional, 'en-US': english }[code] || culture.test(code) && fromLanguageCode(code.match(culture)[1]) || english; } exports.default = english; /***/ }) /******/ ]); //# sourceMappingURL=gitmint.browser.js.map"},{"title":"","date":"2022-05-12T00:55:13.450Z","updated":"2021-09-01T03:03:44.000Z","comments":true,"path":"resume/index.html","permalink":"https://lchml.com/resume/index.html","excerpt":"","text":"李城 李城 出生：1989.01 手机：18668068337 邮箱：licheng_xd@163.com 博客：https://lchml.com 教育背景 西安电子科技大学·硕士 2010.9 - 2013.3 通信工程 西安电子科技大学·学士 2006.9 - 2010.6 电子与信息工程 工作履历 2012.12 ~ 至今: 网易，技术专家 专业技能 具有大型IM、PaaS、SaaS系统设计和实践经验，技术团队管理经验 维护多个开源框架，并被广泛应用 通过PMP资格认证，有项目管理经验 热爱技术，热衷于把技术转化为价值，有责任感 业务成果 网易互客(huke.163.com) 2019.07 - 至今 技术总监兼项目经理 七鱼(qiyukf.com) 2019.02 - 至今 架构师，负责七鱼整体架构设计等工作。 云信(netease.im) 2015.04 - 至今 架构师，负责云信IM服务器架构设计实现。 即时通信云市场份额第一，峰值消息量达到每秒10亿条。 奇幻狼人杀(lrs.163.com) 2017.05 - 2018.02 奇幻狼人杀技术负责人，负责游戏技术架构设计等。 易信(yixin.im) 2012.12 - 2017.05 易信服务器负责人，负责易信服务器工作。 注册用户4亿+，日活达到千万级。 中间件及平台 业务观测平台 Odin 2020.02 - 至今 作者，基于Zipkin、Logstash、Kafka、ClickHouse的全链路日志分析监控平台。 应用于网易云商业务的多个产品线，有效提高问题定位和修复效率。 开源延时队列 DelayQ 2019.02 - 至今 作者，基于gRPC、ZooKeeper、Kafka实现，以Kafka插件的轻量化的方式实现的开源延时队列。 在网易及其他互联网公司多个重要项目的生产环境中使用。 Redis多数据源代理 Yedis 2019.07 - 至今 基于Jedis和Lettuce的redis代理，可以支持Redis多数据源实时配置 为了机房迁移而开发，作为七鱼和云信的核心组建在线上环境运行多年。 开源配置中心 Bimaconf 2018.02 - 至今 作者，基于ZooKeeper实现的配置中心，相比社区已有的开源配置中心，有更多的高级功能和更简洁的接入方式。 在网易及其他互联网公司多个重要项目的生产环境中使用。 服务发现框架 Yxguard 2016.02 - 至今 基于ZooKeeper的轻量级服务发现框架 作为易信和云信的核心组建在线上环境运行多年。 开源Webcat服务器框架 Webcat 2017.05 - 2017.8 作者，一个基于Netty实现的轻量级Http/Websocket服务器框架。 被公司内部多个项目使用。GitHub: https://github.com/licheng-xd/webcat 开源ip库生成器 ipdb_creator 2014.02 - 2014.05 作者，根据ICANN的最新全球IP分配文件，生成详细ip数据库。 被多个市场上的小公司使用。GitHub: https://github.com/licheng-xd/ipdb_creator"},{"title":"","date":"2022-05-12T00:55:13.452Z","updated":"2017-04-18T06:18:32.000Z","comments":true,"path":"resume/resume.css","permalink":"https://lchml.com/resume/resume.css","excerpt":"","text":"html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; } body { font-family: Helvetica, arial, freesans, clean, sans-serif; /*font-family: \"Helvetica Neue\", Helvetica, Microsoft Yahei, Hiragino Sans GB, WenQuanYi Micro Hei, sans-serif;*/ font-size: 14px; line-height: 1.6; color: #333; background-color: #fff; padding: 20px; max-width: 960px; margin: 0 auto; } body>*:first-child { margin-top: 0 !important; } body>*:last-child { margin-bottom: 0 !important; } p, blockquote, ul, ol, dl, table, pre { margin: 5px 0; } h1, h2, h3, h4, h5, h6 { margin: 20px 0 10px; padding: 0; font-weight: bold; -webkit-font-smoothing: antialiased; } h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code { font-size: inherit; } h1 { font-size: 28px; color: #000; } h2 { font-size: 24px; border-bottom: 1px solid #ccc; color: #000; } h3 { font-size: 18px; } h4 { font-size: 16px; } h5 { font-size: 14px; } h6 { color: #777; font-size: 14px; } body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child { margin-top: 0; padding-top: 0; } a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0; padding-top: 0; } h1+p, h2+p, h3+p, h4+p, h5+p, h6+p { margin-top: 10px; } /* LINKS =============================================================================*/ a { color: #4183C4; text-decoration: none; } a:hover { text-decoration: underline; } /* LISTS =============================================================================*/ ul, ol { padding-left: 30px; } ul li > :first-child, ol li > :first-child, ul li ul:first-of-type, ol li ol:first-of-type, ul li ol:first-of-type, ol li ul:first-of-type { margin-top: 0px; } ul ul, ul ol, ol ol, ol ul { margin-bottom: 0; } dl { padding: 0; } dl dt { font-size: 14px; font-weight: bold; font-style: italic; padding: 0; margin: 15px 0 5px; } dl dt:first-child { padding: 0; } dl dt>:first-child { margin-top: 0px; } dl dt>:last-child { margin-bottom: 0px; } dl dd { margin: 0 0 15px; padding: 0 15px; } dl dd>:first-child { margin-top: 0px; } dl dd>:last-child { margin-bottom: 0px; } /* CODE =============================================================================*/ pre, code, tt { font-size: 12px; font-family: Consolas, \"Liberation Mono\", Courier, monospace; } code, tt { margin: 0 0px; padding: 0px 0px; white-space: nowrap; border: 1px solid #eaeaea; background-color: #f8f8f8; border-radius: 3px; } pre>code { margin: 0; padding: 0; white-space: pre; border: none; background: transparent; } pre { background-color: #f8f8f8; border: 1px solid #ccc; font-size: 13px; line-height: 19px; overflow: auto; padding: 6px 10px; border-radius: 3px; } pre code, pre tt { background-color: transparent; border: none; } /* QUOTES =============================================================================*/ blockquote { border-left: 4px solid #DDD; padding: 0 15px; color: #777; } blockquote>:first-child { margin-top: 0px; } blockquote>:last-child { margin-bottom: 0px; } /* HORIZONTAL RULES =============================================================================*/ hr { clear: both; margin: 15px 0; height: 0px; overflow: hidden; border: none; background: transparent; border-bottom: 4px solid #ddd; padding: 0; } /* TABLES =============================================================================*/ table th { font-weight: bold; } table th, table td { border: 1px solid #ccc; padding: 6px 13px; } table tr { border-top: 1px solid #ccc; background-color: #fff; } table tr:nth-child(2n) { background-color: #f8f8f8; } /* IMAGES =============================================================================*/ .markdown-body img { max-width: 100% }"},{"title":"tags","date":"2018-07-19T06:40:17.000Z","updated":"2018-07-19T06:41:20.000Z","comments":true,"path":"tags/index.html","permalink":"https://lchml.com/tags/index.html","excerpt":"","text":""},{"title":"时间","date":"2022-05-12T00:55:13.416Z","updated":"2017-08-22T09:57:00.000Z","comments":true,"path":"timeline/index.html","permalink":"https://lchml.com/timeline/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-12T00:55:13.470Z","updated":"2017-04-19T06:53:34.000Z","comments":true,"path":"donate-page/simple/index.html","permalink":"https://lchml.com/donate-page/simple/index.html","excerpt":"","text":"Donate-Page // 获取链接地址 GET 参数 String.prototype.getQuery = function(name) { var reg = new RegExp(\"(^|&)\"+ name +\"=([^&]*)(&|$)\"); var r = this.substr(this.indexOf(\"\\?\")+1).match(reg); if (r!=null) return unescape(r[2]); return null; } var strHref = location.href.substring(location.href.indexOf(\"?\")+1); var ppitem_name = strHref.getQuery('item'); //项目名称 var donatrNo = strHref.getQuery('price'); //金额 Donate AliPay WeChat"},{"title":"","date":"2022-05-12T00:55:13.488Z","updated":"2017-04-19T06:53:20.000Z","comments":true,"path":"donate-page/simple/script.js","permalink":"https://lchml.com/donate-page/simple/script.js","excerpt":"","text":"jQuery(document).ready(function() { var QRBox = $('#QRBox'); var MainBox = $('#MainBox'); //var BTCQR = 'images/BTCQR.jpg'; // 二维码路径 var AliPayQR = 'images/alipay.jpg'; var WeChanQR = 'images/wechat.jpg'; // PayPal 账户建议使用 Unicode var ppbusiness = \"\\u0074\\u0075\\u0066\\u0075\\u0039\\u0034\\u0034\\u0031\\u0040\\u0067\\u006d\\u0061\\u0069\\u006c\\u002e\\u0063\\u006f\\u006d\"; if (!ppitem_name) { ppitem_name = \"Donate\"; } // if (!donatrNo) { donatrNo = 1; } //创建 Paypal 表单 // 捐赠方式，仅适用于国外账户! function ppDonate() { var tempForm = document.createElement(\"form\"); tempForm.id = \"paypal\"; tempForm.method = \"post\"; tempForm.action = \"https://www.paypal.com/cgi-bin/webscr\"; tempForm.target = \"paypal\"; var cmd = document.createElement(\"input\"); cmd.type = \"hidden\"; cmd.name = \"cmd\" cmd.value = \"_donations\"; tempForm.appendChild(cmd); var business = document.createElement(\"input\"); business.type = \"hidden\"; business.name = \"business\" business.value = ppbusiness; tempForm.appendChild(business); var lc = document.createElement(\"input\"); lc.type = \"hidden\"; lc.name = \"lc\" lc.value = \"US\"; tempForm.appendChild(lc); var item_name = document.createElement(\"input\"); item_name.type = \"hidden\"; item_name.name = \"item_name\" item_name.value = ppitem_name; tempForm.appendChild(item_name); var no_note = document.createElement(\"input\"); no_note.type = \"hidden\"; no_note.name = \"no_note\" no_note.value = \"0\"; tempForm.appendChild(no_note); var currency_code = document.createElement(\"input\"); currency_code.type = \"hidden\"; currency_code.name = \"currency_code\" currency_code.value = \"USD\"; tempForm.appendChild(currency_code); var bn = document.createElement(\"input\"); bn.type = \"hidden\"; bn.name = \"bn\" bn.value = \"PP-DonationsBF:btn_donate_SM.gif:NonHostedGuest\"; tempForm.appendChild(bn); document.body.appendChild(tempForm); tempForm.submit(); document.body.removeChild(tempForm); } // 立即购买，适用于中国账户 function ppBuy() { var tempForm = document.createElement(\"form\"); tempForm.id = \"paypal\"; tempForm.method = \"post\"; tempForm.action = \"https://www.paypal.com/cgi-bin/webscr\"; tempForm.target = \"paypal\"; var cmd = document.createElement(\"input\"); cmd.type = \"hidden\"; cmd.name = \"cmd\" cmd.value = \"_xclick\"; tempForm.appendChild(cmd); var business = document.createElement(\"input\"); business.type = \"hidden\"; business.name = \"business\" business.value = ppbusiness; tempForm.appendChild(business); var lc = document.createElement(\"input\"); lc.type = \"hidden\"; lc.name = \"lc\" lc.value = \"US\"; tempForm.appendChild(lc); var item_name = document.createElement(\"input\"); item_name.type = \"hidden\"; item_name.name = \"item_name\" item_name.value = ppitem_name; tempForm.appendChild(item_name); var no_note = document.createElement(\"input\"); no_note.type = \"hidden\"; no_note.name = \"no_note\" no_note.value = \"0\"; tempForm.appendChild(no_note); var amount = document.createElement(\"input\"); amount.type = \"hidden\"; amount.name = \"amount\" amount.value = donatrNo; tempForm.appendChild(amount); var currency_code = document.createElement(\"input\"); currency_code.type = \"hidden\"; currency_code.name = \"currency_code\" currency_code.value = \"USD\"; tempForm.appendChild(currency_code); var bn = document.createElement(\"input\"); bn.type = \"hidden\"; bn.name = \"bn\" bn.value = \"PP-DonationsBF:btn_donate_SM.gif:NonHostedGuest\"; tempForm.appendChild(bn); document.body.appendChild(tempForm); tempForm.submit(); document.body.removeChild(tempForm); } function showQR(QR) { if (QR) { MainBox.css('background-image','url('+QR+')'); } $('#DonateText,#donateBox,#github').addClass('blur'); QRBox.fadeIn(300,function(argument) { MainBox.addClass('showQR'); }); } // Buttons // $('body').on('click', '#PayPal', function() { // ppBuy(); // 购买按钮适用于国内的 Paypal 账户 // // ppDonate(); // 捐赠按钮仅适合国外的 PayPal 账户 // }); $('#donateBox>li').click(function(event) { var thisID = $(this).attr('id'); if (thisID === 'PayPal') { ppBuy(); } else if (thisID === 'BTC') { showQR(BTCQR); new Clipboard('#BTCBn'); } else if (thisID === 'AliPay') { showQR(AliPayQR); } else if (thisID === 'WeChat') { showQR(WeChanQR); } }); MainBox.click(function(event) { MainBox.removeClass('showQR').addClass('hideQR'); setTimeout (function(a) { QRBox.fadeOut(300,function(argument) { MainBox.removeClass('hideQR'); }); $('#DonateText,#donateBox,#github').removeClass('blur'); },600); }); });"},{"title":"","date":"2022-05-12T00:55:13.490Z","updated":"2017-04-19T06:56:36.000Z","comments":true,"path":"donate-page/simple/style.css","permalink":"https://lchml.com/donate-page/simple/style.css","excerpt":"","text":"html, html>body { margin: 0px !important; padding: 0px !important; height: 100%; width: 100%; } body { font-family: \"Helvetica Neue\", Ubuntu, \"WenQuanYi Micro Hei\", Helvetica, \"Hiragino Sans GB\", \"Microsoft YaHei\", \"Wenquanyi Micro Hei\", \"WenQuanYi Micro Hei Mono\", \"WenQuanYi Zen Hei\", \"WenQuanYi Zen Hei\", \"Apple LiGothic Medium\", \"SimHei\", \"ST Heiti\", \"WenQuanYi Zen Hei Sharp\", Arial, sans-serif; -webkit-font-smoothing:antialiased; line-height: 1.8em; text-shadow: 0 0 1px rgba(255,255,255,0.1); background: #fff; } img {border-width: 0px;} a{ color: #000; text-decoration: none; outline:none; border:none; } .list, .list li, .list-left li { list-style: none; list-style-type: none; margin: 0px; padding: 0px; } .pos-f { position: fixed; } .left-100 { width: 100%; height: 100%; } .blur { -webkit-filter: blur(3px); filter: blur(3px); } .tr3 { transition: all .3s; } #DonateText { position: fixed; font-size: 12px; width: 70px; height: 70px; line-height: 70px; color: #fff; background: #ffd886 url(images/like.svg) no-repeat center 10px; background-size: 20px; border-radius: 35px; text-align: center; left: calc(50% - 120px); top: calc(50% - 60px); z-index: -1; transform: rotatez(-15deg ); } /*#DonateText::before { position: absolute; top: 0; left: 0; content: \" \"; width: 70px; height: 70px; background: url(/images/BOXKS-Round.svg) no-repeat center center; background-size: contain; opacity: 0.05; z-index: -1; }*/ #donateBox { left: calc(50% - 150px); top: calc(50% - 15px); background-color: #fff; border: 1px solid #ddd; border-radius: 6px; width: 299px; height: 28px; float: left; /*overflow: hidden;*/ z-index: 1; } #donateBox li { width: 149px; float: left; text-align: center; border-left: 1px solid #ddd; background: no-repeat center center; background-color: rgba(204, 217, 220,0.1); background-size: 45px; transition: all .3s; cursor: pointer; overflow: hidden; line-height: 600px; height: 28px; -webkit-filter: grayscale(1); filter: grayscale(1); opacity: 0.5; } #donateBox li:hover { background-color: rgba(204, 217, 220,0.3); -webkit-filter: grayscale(0); filter: grayscale(0); opacity: 1; } #donateBox>li:first-child { border-width: 0; /*border-radius: 6px 0 0 6px;*/ } /*#donateBox>li:last-child { border-radius: 0 6px 6px 0; }*/ #donateBox #PayPal { background-image: url(images/paypal.svg); } #donateBox>#BTC { background-image: url(images/bitcoin.svg); line-height: 28px; } #donateBox>#BTC:hover { overflow: visible; } #BTC>button { opacity: 0; cursor: pointer; } #donateBox #AliPay { background-image: url(images/alipay.svg); } #donateBox #WeChat { background-image: url(images/wechat.svg); } #QRBox { top: 0; left: 0; z-index: 1; background-color: rgba(255,255,255,0.3); display: none; perspective: 400px; } #MainBox { cursor: pointer; position: absolute; text-align: center; width: 200px; height: 200px; left: calc(50% - 100px); top: calc(50% - 100px); background: #fff no-repeat center center; background-size: 190px; border-radius: 6px; box-shadow: 0px 2px 7px rgba(0,0,0,0.3); opacity: 0; transition: all 1s ease-in-out; transform-style: preserve-3d; transform-origin: center center; overflow: hidden; } #btc-key { opacity: 0; width: 2px; height: 8px; overflow: hidden; left: -2px; top: -8px; } #github { width: 24px; height: 24px; left: calc(50% + 135px); top: calc(50% - 30px); background: no-repeat center center url(images/github.svg); background-size: contain; opacity: 0.3; transform: rotatez(15deg ); } [data-footnote] { position: relative; overflow: hidden; } [data-footnote]:hover { overflow: visible; } [data-footnote]::before, [data-footnote]::after { position: absolute; transition: all .3s; transform: translate3d(-50%,0,0); opacity: 0; left: 37px; z-index: 10; } [data-footnote]::before { content: attr(data-footnote); border-radius: 6px; background-color: rgba(100,100,100,0.8); color: #fff; height: 24px; line-height: 24px; padding: 0 6px; font-size: 12px; white-space: nowrap; top: -24px; left: 37px; } [data-footnote]::after { content: ''; border: 5px solid #333; border-color: rgba(100,100,100,0.8) transparent transparent transparent; top: 0; left: 37px; } [data-footnote]:hover::before,[data-footnote]:hover::after { opacity: 1; } [data-footnote]:hover::before,[data-footnote]:hover::after { transform: translate3d(-50%,-7px,0); } #MainBox.showQR { opacity: 1; animation-name:showQR; animation-duration:0.51s; animation-timing-function:ease-in-out; animation-iteration-count:1; animation-fill-mode:forwards; -webkit-animation:showQR 0.5s ease-in-out 0s 1 normal forwards; } @keyframes showQR { from { transform: rotateX(90deg); } /* 8% { opacity: 1; transform: rotateX(-60deg); }*/ /* 18% { opacity: 1; transform: rotateX(40deg); }*/ /* 34% { opacity: 1; transform: rotateX(-28deg); }*/ /* 44% { opacity: 1; transform: rotateX(18deg); }*/ /* 58% { opacity: 1; transform: rotateX(-12deg); }*/ /* 72% { opacity: 1; transform: rotateX(9deg); }*/ /* 88% { opacity: 1; transform: rotateX(-5deg); }*/ /* 96% { opacity: 1; transform: rotateX(2deg); }*/ to { opacity: 1; } } #MainBox.hideQR { opacity: 1; animation-name:hideQR; animation-duration:0.5s; animation-timing-function:ease-in-out; animation-iteration-count:1; animation-fill-mode:forwards; -webkit-animation:hideQR 0.5s ease-in-out 0s 1 normal forwards; } @keyframes hideQR { from { } 20%,50% { transform: scale(1.08,1.08); opacity: 1; } to { opacity: 0; transform: rotateZ(40deg) scale(0.6,0.6); } }"}],"posts":[{"title":"阅过留痕","slug":"read","date":"2024-02-18T16:00:00.000Z","updated":"2024-02-26T08:48:40.025Z","comments":true,"path":"book/read/","link":"","permalink":"https://lchml.com/book/read/","excerpt":"知者不惑，仁者不忧，勇者不惧。反者道之动，弱者道之用。凡所有相，皆是虚妄。","text":"知者不惑，仁者不忧，勇者不惧。反者道之动，弱者道之用。凡所有相，皆是虚妄。 《零售的哲学》 2024-02-18 铃木敏文讲述关于711创立和发展的过程。日本企业家总带有一点日漫中的热血理想主义气质。虽然看书的过程中会不禁质疑真实性，或者说质疑自己的格局，但其中很多做事的思路和态度是非常值得我们学习的。 更多关于全书内容可以看：《零售的哲学》 《1453君士坦丁堡之战》 2023-12-14 从西方的角度总是宣传君士坦丁堡的陷落，是野蛮战胜了文明。然后实际情况却是默罕默德二世建立了一个比原来更宽容、更多元化的包容社会，尊重不同信仰，尊重不同生活习俗。 更多关于全书内容可以看：《1453君士坦丁堡之战》 《我曾走在崩溃的边缘》 2023-09-27 虽然作为成功学类书籍，免不了会有些鸡汤味。但是新东方在经历双减之后依然能在绝境中重生，完美印证了俞老师在本书中所展示的个人品质和企业文化。从绝望中寻找希望，俞老师真的做到了。最近自己也正在经历组织的变革，对书中一段关于变革的论述深有同感。 “变革不只是一个结构的问题，更是一个心态的问题。只有当所有人都愿意去变革的时候，这个变革才能推动。推动变革最重要的要素，既不是理想，也不是情感，甚至不是未来，而是利益的分配机制。也就是说，当所有人或绝大部分人都意识到变革能给自己带来巨大的利益和良好的未来预期的时候，这个变革就特别容易推进了。” “在组织机构和个人身份发生变化的过程中，利益猜忌问题就出现了。” 更多关于全书内容可以看：《我曾走在崩溃的边缘》 《华为铁三角工作法》 2023-09-21 让听见炮声的人来决策，本书对华为销售体系进行了系统性探索和深入研究，总结了华为通过构建敏捷的铁三角及从线索到回款流程（LTC）的端到端保障体系，让销售从不确定走向确定的底层逻辑。学习理论很简单，根据每个人每个组织的不同情况，理论怎么结合实践才是最难的。作为工具书做一些参考还是挺不错的。 更多关于全书内容可以看：《华为铁三角工作法》 《即兴演讲》 2023-09-14 一般般，全书内容总结起来一句话就说明白了，即兴讲话的关键是准备，用抓手-要点-论据-呼吁行动的四步脚本，没了。 更多关于全书内容可以看：《即兴演讲》 《翦商：殷周之变与华夏新生》 2023-09-12 全书开篇就先描述了一次详细的人祭过程，有种当头一棒，被惊吓到愣在原地的感觉。再到后面一次次的用平静的文字描述极度残忍的人祭方法看的人都麻了，相比商朝各种人祭方法花样之多，纣王的酒池肉林简直是小意思。如果没有打开这本书看到这些可怕又血腥的文字和图片，我会一直以印象里传统的观念去看待历史的发展，不会知道那些看不见、被掩埋的真相是多么的让人窒息。 书中也有很多有趣得内容，比如各种汉字在甲骨文发源的时候的含义，如甲骨文的”学“字，上面是两手在摆放技术的草棍（爻），下面是一所房子，意为”学习算数的地方“，甲骨文的“史”字是一个非常尊贵的字，造型是手拿着一支笔，上面是一张嘴，象征用笔把口头指令记录下来。还有不管是商人，还是周人的传说中，他们的始祖都是未婚女子遇到神迹而生下的伟大儿子，一千多年以后耶稣的诞生方式也是这种模式，奇怪的巧合。比如对周文王《易经》的解读方法。还比如清明节是来源于牧野之战。类似的有意思的知识还有很多。当然，这本书虽然是考古为依据，但是也混入了大量作者的想象，不能作为正史来读，但也正是这些想象，让遥远的上古时代能在读者脑海里有更形象生动的画面。 书中有一段孔子对商周的总结，“殷人尊神，率民以事神，先鬼而后礼，先罚而后赏，尊而不亲。其民之敝，荡而不静，胜而无耻。周人尊礼尚施，事鬼敬神而远之，近人而忠焉，其赏罚，用爵列，亲而不尊。其民之敝，利而巧，文而不惭，贼而蔽。”，不仅精确的描述了商周文化区别，甚至于可以说是当前中西文化的缩影。 作者说，周公时代变革的最大结果，是神权退场，这让中国的文化过于早熟；战国时代变革的最大结果，是贵族退场，这让中国的政治过于早熟。在三千年前的古人类文明中，只有华夏独自走出了神权的掌控，成为一个“异类”。这是一种过于早熟的世俗文明，一直持续到今日。 更多关于全书内容可以看：《翦商：殷周之变与华夏新生》 《李鸿章传》 2023-06-19 从中学历史书中臭名昭著的李鸿章，到走向共和中公忠体国、鞠躬尽瘁的李鸿章，中国近代的百年国殇正是始于李鸿章。正如开头所说：天下唯庸人无咎无誉。李鸿忠至于清政府无愧于文忠之谥，师承于曾国藩，带领淮军剿捻，到打败李秀成，再到洋务运动，再到主掌外交。一辈子都都在为清政府糊住那注定要破的窗。他是时势所造之英雄，非造时势之英雄。大家骂他卖国，相信非他所愿，大家骂他不改革政体，振兴国家，相信非他所能。所以任公说：李固可责，而彼辈又岂能责李之人哉？只怪200多年的清政府统治已使天下之大，竟无一真英雄豪杰。 更多关于全书内容可以看：《李鸿章传》 《革命与征服中的阿拉伯人：1516年至今》 2023-04-25 这本书可能是我近年来阅读耗时最长的书，从去年底到现在，陆陆续续读了4个多月。书中人物名字冗长，历史事件纷杂，再加上对列强殖民的情绪，看起来确实不轻松。但是对穆斯林社会的认识，会让我的思维和观念时常受到强烈冲击，这是看书能得到的最宝贵的财富之一。 历史是理解世界任何地方的必要起点，中东作为当今世界动乱最多，冲突最激烈，势力最复杂的地区，伊斯兰文明也是中华文明、西方文明以外当今最为重要文明之一，了解其背后的历史和原因，我认为是有意义有价值的。在中东这500年的历史中，有很多我们作为局外人无法理解的地方，也有很多与中国2000多年来极其相似的历史，会愤怒列强的霸道，会愤怒宗教的暴力，会同情平民的悲惨。从中国历史的角度来看，阿拉伯人想要重现历史的辉煌，还有着漫漫长路。 更多关于全书内容可以看：《革命与征服中的阿拉伯人：1516年至今》 《ClickHouse原理解析与应用实践》 2022-12-16 由于业务上要用到ClickHouse，因此花了两三天看了此书，讲的不是特别深，但是挺适合作为ClickHouse使用者的入门，常用的使用姿势和应用需要了解的一些原理都有讲到。 更多内容可以看：《ClickHouse原理解析与应用实践》 《卓有成效的管理者》 2022-12-11 管理深深触及一些精神层面关切的问题——像人性的善与恶。 目前看过的管理类书籍，其实内容和表达的思想都比较类似，这本书虽然是号称管理学教父的彼得德鲁克所写，但也还是并没有让人觉得眼前一亮，为之惊艳的感觉，也可能管理本身就是这样吧。全书主要有四个重点：时间管理，重视贡献，用人之长，有效决策。个人感觉前两部分的内容更有输入，特别是重视贡献的视角，作为技术人员，有些内容颇有拨开迷雾的效果。如其中关于通才得论述：所谓“通才”，应该也是一位专家，是一位能将其所专的一个小领域与其他广大知识领域联系的专家。有少数人也许可以精通几门知识，但这并不意味着他们便是通才，他们不过是精通几门知识的专家而已。专业人员必须使他本人有效，必须使他的专才有效。他必须考虑到他的产出供什么人使用，也必须了解用户应该知道些什么才能有效使用他的产出，从而产生成果。例如关于贡献，只有外部世界才是产生成果的地方，只有重视贡献，才能使管理者的注意力不为其本身的专长所限，不为其本身的技术所限，不为其本身所属的部门所限，才能看到整体的绩效，同时也才能使他更加重视外部世界。其实不仅是管理者，在互联网这种以知识工作者为主的企业中，每个人都一样适用。特别是技术思维的同学经常掉入的陷阱，可以从这个角度改变思考方式。 更多关于本书的内容可以看：《卓有成效的管理者》 《人间杭州》 2022-11-30 阅读一座城市的历史，会让人获得另一种时间感，你可以从任何一个段落回忆过往或眺望未来。如果你恰巧是一个正生活在这里的人，城市的历史将让你产生身不由己的连接。 多年前杭州专门因为G20推出了《杭州简史》一书，当时看完觉得颇有收获。这次看到微信读书推荐的《人间杭州》马上就有了兴趣，作者是著名的财经作家吴晓波，代表作《激荡三十年》很多人可能都听过。这本书跳出作者一贯的商业视角，而是以人文角度，以杭州的人角度在感受和体会这座城市。看书的时候，你可能会发出很多“哦，原来是这样啊”的感叹。 原来在遥远的夏商周时期，杭州还隶属于天下九州之一的扬州。原来余杭是来源于“禹杭”。原来如今房价上天的滨江西兴街道正是当年吴越争霸，范蠡送西施入吴的渡口。原来钱唐之名自秦才有。原来是慧理和尚给第一次杭州注入了城市灵魂“灵隐”。原来西湖最早叫钱塘湖，是东汉时兴修水利，从钱塘江隔出的一个泻湖，而曲院风荷最早是人们酿酒的地方。原来日本的茶道是源自径山寺。原来西湖的名字是白居易起的，而如今的白堤其实不是白居易的白堤。原来钱镠的吴越王是灭唐的朱温封的。原来钱学森、钱伟长都是钱镠的后人，钱家是杭州的千年士族。原来三潭印月是苏轼担心人们围湖造田，侵占湖面才造的。原来葱包桧儿这名字还和秦桧有关。原来易安居士李清照在西湖边的马塍路住了二十年却过眼西湖无一句。原来马可波罗游记中提到最多的城市就是杭州。原来雷峰塔是被倭寇焚毁的。原来灵隐寺里的云林禅寺，是因为康熙写错了字。原来毛泽东在西子宾馆住了五百多天。原来是王国平决定拆除环西湖的政府机构，免费开放西湖，实现了“还湖于民”。原来杭州是一座属于平民的城市。 希望了解更多可以看：《人间杭州》 《西线无战事》 2022-11-16 人们相信奇迹，但事后才知，奇迹不过是块面包。 很早就听说过这本书，这次刚好微信读书推荐，就顺手读了。有点类似多年前看美剧《兄弟连》的感觉，通过一线士兵第一视角表现出的战争的残酷，对人性的摧残，对生命的漠视，确实直击人心。在战争中，人性全部被扭曲，每个人必须变的冷酷、猜忌、无情、满怀仇恨、残忍粗鲁。假如不这样，大多数人都会疯掉。其实本质上是士兵只有通过摧毁自己的人格，才能承受住战争带来的压力。就像书中说的：“我们已经意识到：人只要屈服，就能躲避打击，忍受恐惧 —— 但去思考，就立即活不下去了。”，他们是被牺牲的一代，但是，是谁牺牲了他们？他们为了什么而牺牲？有没有人问过他们是否愿意牺牲？ 可能依旧如张养浩所说：兴，百姓苦；亡，百姓苦。 《祥瑞：王莽和他的时代》 2022-10-27 其实中国一直都是内法外儒，法家是中国的政治体制，儒家是中国的意识形态，自秦之后几千年，甚至当今社会，莫不如是。 看历史最有趣的事情之一就是对我们自己的三观或者说哲学思想自我认知的拷问，当看到很多历史人物基于他们的思想做出不同的选择产生不同的后果，我们会直觉的认为他们是对的或错的，是高尚德或卑鄙的，是不可接受的或可以理解的等等，而这些直觉的结论其实就是我们自己的三观所在，然后我们可以再进一步想为什么我会这么人为，如果换成我会怎么样？而这种感觉在本书中由于王莽的偏执型人格会显得特别强烈。另外一件事当你看着历史中形形色色，起起落落的各种人物，你不禁会问自己，我更愿意做那种人，是位极人臣却可能一朝覆灭，还是阿谀奉承，用尽手段上位，亦或是刚正不阿却可能一生悲惨，又或者做好本分，明哲保身。你会发现无论哪一种都不是那么简单。最后，书中对孔休的描述虽然只有短短几句话，但却让我印象深刻，可能这就是我的选择？ 更多内容请看：《祥瑞：王莽和他的时代》 《特别认真地生活》 2022-09-22 这本书其实算不上自传，更像是稻盛和夫表达自己关于经营管理的哲学思想，内容本身并没有什么创新或者特殊之处，其中的道理和思考，相信大部分人都懂，或者说都知道。其区别只在于能不能做到，也就是你的认知和你的行动是否一致。而稻盛和夫想要表达的就是他对生活，对工作，对人生的追求是一种极致的，纯粹的利他精神。他认为想要经营好企业，必须要有这样的利他之心，而他自己从京瓷到日航，再到创办盛和塾，都是基于这样的理念。 当然，从我自己的角度，我并不是很认同或者说相信他所有的表达。首先我从不接受有完美的人这种概念，当然也可能是我还没达到那样的境界，我更认同陀思妥耶夫斯基作品中表达出来的人性的复杂性。其次，我认为人性中都有一种本能的欲望，就是希望把自己的价值观传播出去，传递给他人，这给人带来的成就感会远超物质上的激励。这也是为什么各行各业的大师大家，最后都会走向传经布道或者表达思想的终点。特别的，当一个人的物质已经得到极大满足时，这种域名一定就会愈发强烈。话说回来，从稻盛和夫的个人经历来说，他对经营企业，起码是日本企业的能力是毋庸置疑的。比如他对人才的看法是这样的：从长远的目光来看，比起那些半吊子所谓优秀人才，倒是头脑略为迟钝但拼命努力的人可以成就伟大的工作。能力这种东西，由于驾驭它的人的人格不同，既可以向好的方面发展，也可以向坏的方面发展。所以人格比能力更重要。 最后，书中关于如果判断是非黑白时的思路我觉得很值得我们再生活中借鉴。当你犹豫一件事要不要做，该不该做，无法做决断的时候，你不妨问问自己：这么做，作为人正确吗？ 《时间从来不语，却回答了所有问题》 2022-09-19 全书给人一种豁达，实在的感觉，不教你怎么做人，不教你大道理，讲的就是简简单单的朴实的生活和想法。回到书名”时间从来不语，却回答了所有问题“，不仅仅书书中文字的提炼，可能更是季老的一生经历感悟，百年的时光，走遍三十多个国家，经历战争与和平。也许当时间足够长的时候，很多问题都早已不是问题，不论是政治，战争，仇恨，感情，大概都已随风飘散。 《真希望我父母读过这本书》 2022-09-14 又是一本心理咨询师写的书，刚刚看完的《也许你该找个人聊聊》的作者也是一位心理咨询师。这是老婆推荐给我的育儿类书籍，自从有了宝宝以后，老婆疯狂学习育儿知识，把自己的大部分精力都投入在了宝宝身上，为我减轻了很多负担，很感谢她为这个家庭的付出。 针对这类书籍，我觉得大家一定要牢记一点，这些都是社会人文科学，不是自然科学，不存在1+1&#x3D;2的真理，也不存在绝对好坏的标准。每个作者都只是在表达自己的观点，并为此引用了一些案例。这些都不代表作者说的就是对的，读社科类的书，我们应该思考作者的观点我认不认同，对我有没有价值，适不适合我。特别是某些作者，某些不那么好的书，千万不能简单的全盘接受。说到本书，举个例子，作者说不要对孩子做任何评判，在我看来显然是过于极端的做法。当然其中关于如何真实表达自己的感受，如何给自己设定界限，还有身教大于言传的观点我都是很认同的。总之，这本书在这类书籍里面算是比较不错的，也就是没有那么多我认为”极端“的观点。 《管理百年》 2022-09-13 网易领导力训练营的推荐读物，全书总结了管理学从1900年开始的发展历程，在一百多年的时间中，有大量理论登上舞台，同样也有大量的理论随着时代消逝。其原因是管理是社会人文科学，它并没有标准也没有真理，有的只是适应此时此刻此情此景的“恰好”。它不是自然科学，不像万有引力一旦被证明就变成一种不可变的规律。书中会看到很多我们熟知的人物、企业、商业案例。管理的概念虽然兴起的时间很短，但是如果广义的看，人类从原始社会进入群居生活以后，管理就一直存在，只是通常会被忽视，因为通常管理并不直接解决根本问题，但却是解决复杂问题的必要手段。就好像汽车的动力根本上来自于汽油燃烧产生热能，而管理就像机油。 更多本书内容可以看：《管理百年》 《秋园》 2022-08-15 强烈推荐，书很薄，但是很沉。和多年前看《活着》有一种类似的感受，在历史洪流中挣扎生存的人，依然可以看到历史的一粒尘埃落到每个人身上都是一座大山。但是书中的秋园在这座大山面前，展现出了我们人类最宝贵的品质，善良和勇敢。人性的光芒可以超越历史和时间。 有很多评论都在讨论女权问题，但我想说这历史的洪流和社会的意识形态真的是普通人能左右的吗？人是社会的产物，我们现在认为的人权，认为的独立思考也只是历史洪流中的一瞬间，你的所思所想并步仅仅是因为你。我想书中体现出的人性的善恶远远超越了性别的区别。 秋园最后对自己的总结：一九三二年，从洛阳到南京一九三七年，从汉口到湘阴一九六〇年，从湖南到湖北一九八〇年，从湖北回湖南一生尝尽酸甜苦辣终落得如此下场 《也许你该找个人聊聊》 2022-08-11 作者自己的人生经历就够传奇的，当过电视剧制作人，当过作家，并在30岁的时候决定转行去当医生，还顺利的考入了名牌大学医学院，开始和比自己年轻的多的同学们一起学解剖学理论，最后因为想要和患者有更长期的接触而选择了心理治疗师作为自己的职业。 更多内容请看：《也许你该找个人聊聊》 《天蓝色的彼岸》 2022-06-15 当你还存在于某个人的记忆中，还被人爱着，你就是存在的。很久很久以前就听说过这本书，一直没去看，最近微信读书上刚好推荐了此书。作者用一个儿童的视角思考了生命与死亡的意义，爱和记忆的意义。让人想到了《寻梦环游记》、《心灵奇旅》两部皮克斯动画，有异曲同工之妙。主人公哈里给人一种温暖且治愈的感觉。 《领导力的5个层次》 2022-06-07 网易集团领导力培训课前读物。全书总体来说鸡汤味有点浓，其中有大量的正确废话，写作风格有点像读书时写作文，为了论证观点引用大量的小故事或者名人名言。当然也有一定的收获，有一些之前没想到的或者认识的盲区。属于可以一读，但并不值得强烈推荐。 《百年孤独》 2022-06-06 “多年以后，面对行刑队，奥里雷亚诺· 布恩迪亚上校将会回想起父亲带他去见识冰块的那个遥远的下午。”在惊艳的开头之后，出现的是各种冗长的重复的人名。大约六七年前，第一次翻开书，读了20多后页放弃了，第二次翻开书读了100多页后又放弃了。没想到在2022年端午节的连续三天大雨中，再次翻开书后就一发不可收拾，直到读完还意犹未尽，也不知道这六七年间是什么变了。 全部读后感以及全书人物关系图：《百年孤独》 《星空邮局》 2022-05-28 佩服作者的勇敢和坚强，人生无常，努力过好每一天。 《建筑也可以很好玩：欧洲篇——从古希腊到文艺复兴》 2022-05-24 看完《地下室手记》以后需要看点轻松的书来调节一下，刚好微信读书推荐了这个，确实还挺有意思的，不仅科普了建筑知识，还简单科普了古希腊到文艺复兴的欧洲历史。书中涉及到历史，宗教，科学各方面，其中关于宗教大家有兴趣可以看我之前总结的《三教起源与关系》。了解了基督教、犹太教、伊斯兰教之间的关系后看本书会更顺畅。 看书时想到，如今地球上的主要文明，其实就是发源于地中海沿岸的欧洲文明，发源于两河的中东伊斯兰文明，以及发源于的中国的东亚文明三大文明。 本书的摘要信息《建筑也可以很好玩：欧洲篇——从古希腊到文艺复兴》 《地下室手记》 2022-05-11 一切贬义的负面的词语都能用来形容主人公：懦弱、自卑、敏感、卑劣。下流、猥琐、纠结、怪异、阴暗、虚荣、窝囊、无耻、季度成性、反复无常、自欺自人等等，然而最无奈的是什么？是我们总能从他身上发现自己的影子，也许这是因为所有这些原本就是人性中与生俱来的。 第一次读陀思妥耶夫斯基的作品，地下室人，也就是主人公永远都在矛盾和不断的臆想以及自我否定中试图寻找自己的自尊和虚荣。几乎每句话都是对前句话的反驳与嘲笑。越往后读，越感觉到作者真的是在对读者实施精神上的酷刑和拷问。原以为短短几万字的内容会很快就读完，万万没想到会读的如此艰难，甚至有些痛苦。第一次意识到理性的局限性，意识到理性在人性面前的矛盾和脆弱。理性是好东西，这是毋庸争议的，然后理性却终究只是理性，只能满足人的理性能力，而意愿确是整个生命的表现，也就是人的整个生命，既包括理性，也包括一切内心的骚动。地下室人对丽莎的指责和被丽莎撞见窘态后的崩溃的歇斯底里，看似极端却又合理。人可以在痛苦和被折磨之中发现可耻的快感并享受它。所有的矛盾和问题最终都指向“人是什么？” 《城乡中国》 2022-04-28 此书带着大量经济学知识，加上大量作者的调研数据和观察总结，信息量很高，所以读起来会稍微有点慢。全书的核心思想就在于论证赋予农地转让权，让农地入市的合理性，正当性和必要性。作者作为国内著名经济学教授、北大院长，经济学方面的实力无需质疑。从书中学习到了很多经济学理论，还特地了解了书中经常提到的经济学家科斯。全书前半部分，有过于理想主义的经济学学者思维的感觉，信仰完全的自由市场经济模式，后半部分深入关于农地入市的主题后，不得不说非常有古代谏臣的感觉。虽然书中有很多观点我认为过于理想，并不赞同。但更重要的是，我认为作者这样的学者在中国是非常稀缺和重要的，直言直谏的价值有时候远远超过观点本身。邓公说过，我们要警惕右，但主要防止左，左带来的危害要远远大于右。 另外关于阅读过程中的一些感悟和原文的摘抄可以看《城乡中国》 《蛤蟆先生去看心理医生》 2022-04-16 跟着蛤蟆先生一起经历了心理上的自我剖析，阅读过程中常会有”原来如此“的感觉。每个人都有儿童状态、父母状态、成人状态。但实际上人总是会本能的逃避成人状态，因为这需要刻意的思考和学习。在儿童状态下的人容易抑郁，在父母状态下的人容易愤怒。学习这些之后可以让我们更了解自己了解别人，会去思考每个人包括自己情绪行为背后的心理状态。 当下的社会，人们越来越普遍的焦虑抑郁，值得每个人警惕。情绪的控制和表达是一项非常重要的技能，如果不知道如果正确的表达自己的情绪，通常最后要么会导致抑郁，要么会导致爆发失控。 摘抄了一些文字，对于想粗略了解本书内容的人可以看《蛤蟆先生去看心理医生》 《显微镜下的大明》 2022-04-12 最近一两年看了很多历史，感慨历史的波澜壮阔，帝王将相英雄豪杰的力挽狂澜，直到去年看了马亲王的《长安的荔枝》，突然感受到了历史中小人物视角的魅力，然后再看了此书，确实我们通常印象中的历史都是烛照万里的规律总结，是高屋建瓴的宏大叙事，都是王朝的兴盛和衰败，然而历史车轮下的百姓却鲜有提起，历史的一粒尘埃落在每个人身上就是一座山。 六个故事都给人一种普通老百姓面对官僚集团时的无力感，但在这背后却又能感觉到一种顽强的生命力，可能是人类反抗挣扎的本能吧。 《PPT演讲力》 2022-03-25 作为不擅长表达的人来说，当作工具书挺好的，起码可以让你的演讲过得去，不至于一塌糊涂，书中方法的可操作性也不错，当然别指望靠这个成为大师或者发家致富，就像书中讲的，你的演讲本身就是你过往所有的人生阅历和智慧沉淀。 《圆圈正义》 2022-03-23 罗翔老师的杂文集，书中通常会从司法的角度分析问题，但更多的是从哲学和道德的层面在讲述。阅读过程中能感受到作者带有理想主义，悲观而又温暖的思考。让我知道了法治和法家的区别，知道了法律的尽头是道德，是一般民众朴素的期待。 作者提到很多问题，比如功利主义，虚无主义，极端自由主义等等，都能很好的帮我们理解社会理解自己，时刻警惕自己人性的幽暗面，自己的虚荣心。时刻谨记真实的生活意味着承认自己的有限、浅薄和虚荣。要记得爱人如己，要记得谨慎、节制、公正、坚毅的品质。 巧合的是，由于之前一段时间阅读了不少中华文明，中国历史相关的书籍，再加上近来西方国家的表现和国内媒体的报道，让自己一度陷入中华文明最伟大，西方文明不过如此的迷恋之中。幸好，在这本书中罗老师借用了许多西方文明的伟大先驱和哲学思想，提醒了我各大文明一直都是各有长处，也同样各有缺点。我们要做的不是去迷恋一个或鄙视一个，而应该集各家之所长来不断提高自己。 另外也多了一些关于民主的思考，民主中有一个重要的悖论——多数人的暴政。而民主，本身就是可以操控的，因为不可能每个人都足够理性，都能独立思考，更多的是被引导被思考，再加上现代社会中，发达的媒体加上互联网的辅助，可以非常容易的给每个人编织信息茧房，同时还让每个人都觉得自己是在独立思考。这些都让暴政更容易成为现实。 《无规则游戏：阿富汗屡被中断的历史》 2022-03-18 “院子里的一条好狗，比首都的好国王更有用。” —— 阿富汗民谚 在18世纪才刚刚从原始社会变成一个民族国家的阿富汗，欧亚大陆各大文明的交汇之地，各大帝国的利益所在，地理和历史就决定了这是一个不会太平的地方。对比中华文明，相当于阿富汗需要在短短两百多年时间，完成中华文明几千年的发展，这几乎是不可能的事情。所以他们在两百年前还在上演着中国两千多年前的士族门阀制度，人民的思想和“王侯将相宁有种乎的”还有太远的距离。一百多年前的国王还在试图进行像商鞅那样的消除门阀加强中央集权的改革。然而给阿富汗的时间太短了，期间更有英国、苏联、美国各种帝国势力的入侵或干涉，所有的这些就汇集成了一个混乱误解的阿富汗。 同时纵观世界历史，也再次印证了，在国际关系上利益才是不变的底层逻辑，美国为了利益通过巴基斯坦三军请报局扶持了塔利班，之后同样为了利益赶走了塔利班，如今依旧是为了利益逃离了阿富汗，从政治的角度，没有人在意阿富汗是什么样子，只在意阿富汗的样子是不是符合自己的利益。 作者作为美籍阿富汗人，不可避免的会站在美国的角度进行叙事带入主观意见，但不影响此书的内容。 《微积分的力量》 2022-03-01 看了前50%的，作为科普读物还不错，但远没有网上吹的那么好，如果说世界进步是微积分的力量就好像说世界进步是氧气的力量一样，因为所有成就都是人做出来的，人总需要氧气，所以这是一个非常勉强的观点，作者可能只是把微积分作为一个切入点而已，但是书名还是觉得不妥。其实关于这方面的书，我更推荐曹天元写的《上帝掷骰子吗》，写的更有趣生动，也更真诚。 《微尘》 2022-01-13 作者一次次用平淡的语言描述着自己经历和目睹过的不幸，以至于生死离别就像吃饭睡觉一样平平常常，让人产生强烈的无力感，无奈而残忍。那么多人命如草芥，随风飘荡，就如书名微尘一样，他们在这个世界上存在过，挣扎过，消失了，却没有留下任何痕迹。 常年浸泡于城市职场中的我们，有时候都忘了很多东西，以为人生就该如此，以为一切应该有逻辑，以为付出就应该有回报。其实世界很单纯，所有逻辑所有规则都是人自己给自己附加的。 只是活着已经让很多人耗尽了毕生精力。 《置身事内——中国政府与经济发展》 2022-01-01 看完此书，最大的感受就是，经济规律和金融制度才是当今世界的底层逻辑。作者用非常通俗易懂的语言很好的讲解了中国政府和中国经济的发展，理解了这个发展逻辑，我们就能更好的理解身边的一些事情。比如政府为什么不想让房价涨，但是为什么房价又不得不涨的原因。比如为什么中美贸易战其实是一个必然的结果。比如所谓权力，实质就是在说不清楚的情况下由谁来拍板决策的问题。比如政府为什么都需要有各种城投公司。对当下政治和经济有兴趣的人，此书都值得一读。 此书在微信阅读里面是需要付费阅读的，摘抄了一些数据，对于想粗略了解本书内容的人可以看《置身事内》——中国政府与经济发展 《长安的荔枝》 2021-12-14 全书一气呵成，读起来也就跟着主人公一路驰骋，酣畅淋漓。李德善的绝望、无奈、迷茫到最后的释然，情绪随着剧情的进展跌宕起伏。当然，借古讽今永远是作家最爱的操作，很有意思，哈哈哈。 《中国哲学简史》 2021-12-12 深以为此书和《中国通史》两本书应该作为中国人必读之书。能把晦涩艰深的中国几千年的哲学及其发展史写的如此浅显易懂，足见作者的哲学功底之强，称得上学贯中西，博古通今。全书通过梳理诸子百家中主要的儒家、墨家、道家、名家、阴阳家、法家，以及之后的佛学、新道家、禅宗、新儒家，到最后西方哲学的传入。系统的解释了中国几千年来的哲学变化，也就间接的讲述了中国人几千年来思维方式的变化。 在看书的过程中突然觉得似乎当今社会大部分人的哲学思维依旧停留在先秦诸子百家时期。 由于此书内容信息量巨大，因此有必要单独写一篇《中国哲学简史》摘抄 《论中国》 2021-11-07 虽然基辛格作为中国人民的“老朋友”，可以说对中国文化的了解已经非常深入，有些地方甚至远超许多中国人。同时作为学者身份也尽可能从中立或学术的角度进行描述。但全书依然有强烈的美式思维和立场，会有许多让人不适或不爽的感觉。还能感觉到西方人对中华文明既敬佩又傲慢的矛盾心理。同时在书中可以强烈感受到作者对周恩来总理的尊重。在书中也预言了许多已经成为现实的中美冲突，最后为世界和平或者说中美和平给出了自己的意见和建议。 看完本书后，我更加相信，中华文明如同大海，人类沧海桑田，中华文明始终屹立。 《格鲁夫给经理人的第一课》 2021-10-13 花了几天断断续续读完，书很薄，但是干货很多。作者作为国际著名科技企业英特尔的CEO，手把手教你怎么做管理，大到战略思想，指导方针，小到言行举止，操作步骤。每个章节都有高度总结提炼的宝贵经验。读完书很快，但是消化它，把它变成自己的东西需要很久。 更多内容可以看《格鲁夫给经理人的第一课》 《凤凰架构》 2021-08-26 关于构建可靠的大型分布式系统很好的科普型技术书籍 更多内容可以看《凤凰架构》 《中国通史》 2021-08-19 一直对中国历史比较感兴趣，特别是对战国时代的历史。在读此书之前，通过学生时代的学习，文学作品，影视剧等，对中国历史有些零散不成体系的了解，因此一直想要把所有历史贯通起来，吕思勉先生的这本《中国通史》正式最合适的。中国五千多年的历史中，无数朝代兴亡，无数君王更替，无数权臣起起落落，正应了那句名言，滚滚长江东逝水，浪花淘尽英雄。然而纵观夏商周之后的历史，战乱动荡的岁月几乎可占去半数不止，而至于太平盛世更是十无其一，可以想象在大部分的岁月中，大部分的百姓生活都是艰难曲折的。由此也更应珍惜当下的和平。另外，本书也介绍了中国社会文化思想更方面的发展历史，如中国文化思想的三个阶段及其原因。从秦汉诸子思想，到魏晋隋唐的玄学佛教思想，再到宋明的理学心学，如此我们也就更明白了自己的许多观念思想缘何而来。更深一步可以说是部分回答了我是谁，从哪来这两个问题。 ** 吕思勉先生在本书（此书写于1939年，正值中国大地战火纷飞，外敌入侵之际）最后写到：我们现在，所处的境界，诚极沉闷，却不可无一百二十分的自信心。岂有数万万的大族，数千年的大国、古国，而没有前途之理？！** 本书内容信息量大《中国通史》 《邓小平时代》 2021-08-05 挽狂澜于既倒，扶大厦之将倾！他引导中国完成了从落后、封闭、僵化的社会主义制度走向一个有国际影响的现代化经济强国的艰难过渡。精神和肉体都留给了这个让他奋斗一生，贡献一生的国家。邓公千古！ 《邓小平时代》读后感 《追风筝的人》 2021-07-19 作者用最平淡最细节最温暖的语言，写出了最悲惨最残忍最善良的故事。这是一本有力量的书，让人看到了丑恶和美丽。哈桑说：为你，千千万万遍。 《上帝掷骰子吗》 2021-07-10 由于最近看了大刘的几部科幻，又勾起了对量子力学的兴趣。这书用比较生动且“相对易懂”的语言讲述了整个量子力学的发展史，很庆幸自己大学时选修了量子力学课程，让我看这书时轻松了不少。书写的很精彩，是很好的物理学科普或了解物理学历史的材料。 《三体3-死神永生》 2021-07-02 三体的前两部很多年前就已经看过了，第三部一直拖着没去看，当时觉得以黑暗森林作为结局其实也不错。由于最近看了《球状闪电》，又勾起了兴趣。所以还是把三体做了个了结。论想象力，第三部确实是三部书中最丰富最宏大的，宇宙变的如此拥挤，甚至破败。完全打破的我的思维边界，我想这也是科幻最吸引人的地方，突破思维的界限，进入未曾想象的世界。 《球状闪电》 2021-06-16 丰富的想象力，把微观世界的规则引入宏观世界，量子力学放大至宏观世界后，一切都变的那么震撼却又合理。 《雪中悍刀行》 2021-05-16 看完全书，印象最深的不是主角，而是李淳罡和他的“剑来”。 《枪炮。病菌与钢铁》 2020-11-27 全书最主要的论题是：为什么现在社会是这样的格局，为什么欧洲人殖民了非洲美洲，而不是反过来。是不是人种的优劣造成的。 全书主要结论：产生当前格局的主要因素是全球地理因素（虽然作者说这不等同于地理决定论） 《团队协作的五大障碍》 2020-11-12 在《系统架构》一书中作者提出：系统的功效必须大于各自元素的功效之和。而任何一个团队都可以视为一个系统，对于大多数管理者来说，让团队相互协作发挥出一加一大于二的力量是其最重要的工作。团队协作之所以不能良好的实现，是因为总是不自觉的陷入了五个很普通但却很危险的沼泽之中。我们这里称其为团队协作的五大障碍。他们并不是相互独立，而是共同作用，互为因果的。 更多内容可以看《团队协作的五大障碍》 《富兰克林传》 2020-10-12 美国国父之一，政治家、科学家、发明家、作家等各种头衔集于一身。有很强的的社交能力、组织能力、演讲能力等等。不过整体看下来，并不是我喜欢或敬佩的类型。 《乡村教师》 2020-08-29 看过大刘的三体，惊叹其想象力和宏大的世界观。这本书是一些短篇的合集，整体来说依旧是大刘风格的宇宙，一个星系乃至宇宙都是可以被轻易毁灭的世界。其中有几篇非常精彩，非常有想象力。也有几篇给人重复的感觉。总体来说依旧是很优秀的科幻作品。 《蒋介石与现代中国》 2020-05-04 作为传记，书本身写的不够精彩，中间有大篇幅的流水叙事。但作为历史，可以了解到很多你本来可能不了解的是。蒋的一生在中国近现代史，甚至整个中国历史上都是非常重要的一段。对比毛泽东传，本书少了很多主观评判，坐着尽量都以客观的态度在叙述发生过的历史事件。和毛一样，蒋也有着功过是非复杂多变的一生。（有一点记忆深刻，蒋给世人留下的映像总是儒雅温和，符合儒家文人形象。但他在年轻时，脾气极差，并且流连烟花场所，身染性病。） 1887年10月31号，蒋介石出生于浙江奉化溪口镇的一个经商家庭，祖父玉表公替孙子依辈份取名蒋瑞元，蒋家的小店生意兴旺，是镇上的首富。蒋介石从小跟着私塾先生学习，据说9岁前已经念完了“四书”（《大学》、《中庸》、《论语》、《孟子》）。十四岁那年在家庭安排下娶了邻村一位19岁的姑娘毛福梅。1903年参加童子试未考取，转而去了奉化县城凤麓学堂学习英文、算术等西学。当蒋介石在城里见识到了“大鼻子” 的外国传教士以后，也开始嫌弃替他料理家室的不识字的糟糠之妻。据传闻，毛福梅曾向朋友抱怨她经常遭到丈夫殴打。1903年，蒋进入宁波箭金学堂，毛福梅陪读几个月后，蒋嫌她土里土气，打发她回溪口侍候婆婆。1906年，蒋在其仰慕的新儒家老师顾清廉鼓励下，研读了王阳明和曾国藩的著作，这对他后来产生了很大的影响。在18岁那年，蒋决定要东渡去日本求学，并自己剪去了辫子。在蒋的一生中有两股力量对其影响至深，一是新儒学，使其在后期注重修身养性，自律自省，二是清末中国被列强瓜分压迫的惨痛经历，使其对国家统一自强有深刻的使命感。 看完这《毛泽东传》和《蒋介石与现代中国》已经有一段时间了。最近刚好在看中国通史的百集纪录片，不由感叹，分久必合合久必分真的是中华大地上逃脱不了的轮回。夏商周（合）-春秋战国（分）-秦汉（合）-三国魏晋南北朝（分）-隋唐（合）-五代十国（分）-宋元明清（合）-民国军阀（分）-共和国。说回到这两本书，首先两本书看完后给人的感觉是完全不一样的，历史又一次上演两个性格迥异、亦敌亦友的人共逐天下。 《毛泽东传》 2020-02-24 与人斗其乐无穷，“斗争”从始至终贯穿了他的一生，从少年时代与父亲斗到晚年与自己的战友同事斗，他坚信斗争才能让人进步，青年时的心怀天下到晚年带有虚幻色彩的哲学思想，都展示了他注定不平凡的一生，无论是非功过，他都将影响几代人甚至几十代中国人的生活和思想。 少年时期 1893年12月26号，毛泽东出生于湖南省湘潭县韶山村，父亲毛顺生是村里的一个小地主，生活有保障。8岁时，毛泽东对私塾里教授的儒家经典十分反感，经常和私塾先生发生冲突。还偷偷在私塾里看禁书——《水浒传》、《三国演义》、《西游记》，这些书比韶山的任何东西对毛泽东的思想世界影响都要大。父亲毛顺生不喜欢毛泽东把大把的时间“浪费”在看书上，为了让儿子走上“正轨”，毛顺生强迫14岁的毛泽东娶了一个大他6岁的姑娘，但是毛泽东拒绝和她生活在一起，他说他从来没有碰过她一下。在1910年，毛泽东和他父亲因为继续上学的问题开始争吵，毛顺生计划让毛泽东去70多里外湘潭县城的一个米店当学徒，而毛泽东希望去一所教“外国”课程的新式学堂当全日制学生。16岁的毛泽东已经学会了如果制定切实可行的计划以达到自己的目的，他从母亲娘家以及一些家庭朋友中东拼西凑借了一些钱，然后直接向他父亲宣布“我决定去东山高校去上学”。由于摆脱了对父亲的经济依赖，天一亮毛泽东就收拾好行李徒步离开了韶山，并再也没有回来生活过。离开前母亲七妹问他要不要和父亲道个别，毛泽东回答“不，不用”。在他16岁之前，他从没有离开过韶山。毛从青少年时期就展现出了惊人的抗争精神，并且和一般同龄人不同的是，他并不是简单的叛逆，而是以一种冷静的、深思熟虑的方式与父亲斗争，并且通常相当有成效。多年以后，他自述自己人生中第一个造反的对象就是他父亲。 求学时期 在东山学堂，毛泽东年龄比其他孩子大五六岁，加上身高出挑，很难融入学生之中。书是他真正的朋友，他从为数不多的朋友萧三那里借阅了《世界英雄豪杰传》，当归还书时，每个人物边上都写满了他的批注。1911年，毛泽东离开湘乡步行到湘潭，申请入读一所高小被拒。为此他准备好了后备计划，在东山时通过一位老师为他在长沙申请了一所中学。毛泽东第一次来到湖南省会，接触到了更大的世界，开始接收到各类革命运动的消息，开始自己写文章发表政见，此时17岁的他剪去了辫子。在长沙期间毛泽东曾去参军，但实际没有参战，做的都是服侍军官的后勤工作，后又决定回归校园。经过一系列的筛选，毛最后选择进入了湖南第一师范学校，在校期间他阅读了大量书籍，包括西方各类哲学思想著作。并在第一师范碰到了第一个影响他一生的人杨昌济，杨昌济是第一师范的教授，崇敬宋代儒学（程朱理学），同时在英国和德国留学期间，吸收了康德等西方理想主义的理论。毛泽东后来娶了他的女儿杨开慧。毛泽东在第一师范期间培养了一种信念，即通过鉴定的努力可以使人获得新生。他着迷于身体锻炼，洗冷水浴，爬山，甚至很长一段时间内每天只吃一顿饭，长时间晒太阳，逆着风大声朗诵唐诗，这些对毛泽东来说不仅仅是为了身体健康，更是为了在意志力同一切阻力进行的搏斗中获得乐趣。“与天奋斗，其乐无穷，与地奋斗，其乐无穷，与人奋斗，其乐无穷”他在日记中这样写着。 步入正轨 毛泽东26岁时，第一次离开家乡湖南省。在北京大学做图书管理员，接触到了更多的人物，当时的图书馆长就是李大钊。他的同学朋友们很多开始出国留学，而他决定留在中国，期间还爆发了著名的五四运动。在北京仅仅停留了6个月后，他去了上海，拜访了陈独秀，然后又回到了长沙，成为了长沙地区五四运动的先锋人物。1921年，中共第一次会议举行，正式成立了中国共产党，而在这次会议上，毛泽东还只是一个非常不起眼的人物。当天晚上毛泽东对他的同学萧瑜说：“假如我们努力奋斗，有三五十年，共产党就有可能通知中国。”之后他回到长沙，作为湘区党委书记开始组织工作。 #TODO 《拿破仑传》 2019-12-25 这本书写的实在有些太冗长了，以至于最后我没能读完。内容更多的集中在对拿破仑的生活和个人心理活动方面，对生平事迹的着墨偏少，看着着实有些犯困。 《列奥纳多·达·芬奇传》 2019-10-25 在达芬奇身上你会觉得天才有时候真的是天生的，天然的对事物充满好奇心，所有理所应当的事在达芬奇眼里都变成了问题。以私生子的身份出生，但幸运的在一个对私生子习以为常的社会中，一生最大的最求并不是绘画，而是军事工程，最后却留下了无数艺术传奇。达芬奇能一生最求艺术也有美第奇家族的功劳。 《史蒂夫·乔布斯传》 2019-02-11 六天时间，一口气看完了这本比砖还厚的书。跌宕起伏又魅力无穷的人生传奇。让人觉得自己很重要，觉得自己被期待，是很重要的说服别人的方法。没有人会臣服一个平庸的人，没有人会喜欢一个无聊的人。 《人类群星闪耀时》 2019-07-22 本书名气很大，但内容其实一般，一方面可能是时代所限，一方面有太多作者作为诗人主观的浪漫主义色彩，可以当做小故事传记来看。 《北欧，冰与火之地的寻真之旅》 2019-02-15 不要被书名误导以为是旅游类的书，作者以英国人和丹麦女婿的角度深入分析了北欧生活和文化，诙谐有趣又不失深度思考。看完以后一定会让想去一趟北欧感受他们的文化和习俗。 《机器人短篇全集》 2019-01-20 看这本书是因为著名的“机器人三定律”就是出自此书，从成书的时间点来看，作者的想象力确实惊人，并且成功预测了很多现在的事情。 《阳明学述要》 2019-06-01 知行合一，未有知而不行者，知而不行只是未知。无善无恶心之体，有善有恶意之动，知善知恶是良知，存善去恶是格物。圣人只在成色上争，不在分量上争。阳明之约多被后世所误读，偏离本意。阳明心学是中华儒家文化之瑰宝，可惜现代社会已经让大家没有时间没有精力去悟。 《曾国藩传》 2019-05-25 最近花了一个星期时间读完了张宏杰写的《曾国藩传》，从小就听说过各种人对曾国藩的崇拜和敬仰。这次终于系统的了解曾国藩的一生。作为中国传统文化的最后一个精神偶像，曾国藩用一生的努力实践了儒家立行、立言、立德。成为晚清第一重臣，挽狂澜于既倒，扶大厦之将倾，镇压太平天国运动，维护中华儒家文化，发起洋务运动，以开放的心态带领中国走出了现代化的第一步，以一人之力为腐朽的清帝国又续命了几十年。然而朝代的更替和历史的进程已经超出了个人能力的范围，最后清政府依然在1912年终于倒下，中国人民，中华文化在一片混乱，外强环绕之中步履蹒跚的走向下一个时代。 《万历十五年》 2018-11-25 几千年以来，以道德代替法治，最后导致了整个社会机器的停摆，作者认为道德应该被用于大方向，是追寻的目标，而具体的实施和细节的评判应该出于法治和技术，而非道德。（作者整体思想偏西化，有一种以西方文化看中国传统的感觉） 《未来简史》 2018-11-05 宗教与科学的关系，现代社会几乎所有人都是人文主义信徒，包括你我在内，以人类为中心。未来也许是数据主义，以数据为中心，人类可以退出历史或是通过科学升级自身，成为下一代“人类”。 《人类简史》 2018-09-18 作者以上帝视角回顾了人类发展的过程。从认知革命，农业革命，到工业革命。无论阶级或是人权，奴隶制或是人人平等都是存在于人类之间的虚构想象。更努力并没有使人类更幸福。今天盛行的自由主义，遵从内心，这一套理论很大程度上是为了配合资本主义和消费主义而存在的。经常有人会说科学只是一种新的宗教而已。本书很好回答这个问题：科学相比以往的宗教，关键区别在于承认了人类的无知，从而在探索未知领域时带了无限可能。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"政治","slug":"政治","permalink":"https://lchml.com/tags/%E6%94%BF%E6%B2%BB/"},{"name":"文学","slug":"文学","permalink":"https://lchml.com/tags/%E6%96%87%E5%AD%A6/"},{"name":"科幻","slug":"科幻","permalink":"https://lchml.com/tags/%E7%A7%91%E5%B9%BB/"},{"name":"经济","slug":"经济","permalink":"https://lchml.com/tags/%E7%BB%8F%E6%B5%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"传记","slug":"传记","permalink":"https://lchml.com/tags/%E4%BC%A0%E8%AE%B0/"},{"name":"心理学","slug":"心理学","permalink":"https://lchml.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"文化","slug":"文化","permalink":"https://lchml.com/tags/%E6%96%87%E5%8C%96/"},{"name":"心学","slug":"心学","permalink":"https://lchml.com/tags/%E5%BF%83%E5%AD%A6/"},{"name":"书单","slug":"书单","permalink":"https://lchml.com/tags/%E4%B9%A6%E5%8D%95/"}]},{"title":"《零售的哲学》","slug":"711","date":"2024-02-17T16:00:00.000Z","updated":"2024-02-26T08:40:33.617Z","comments":true,"path":"book/711/","link":"","permalink":"https://lchml.com/book/711/","excerpt":"日本企业家总带有一点日漫中的热血理想主义气质。虽然看书的过程中会不禁质疑真实性，或者说质疑自己的格局，但其中很多做事的思路和态度是非常值得我们学习的。","text":"日本企业家总带有一点日漫中的热血理想主义气质。虽然看书的过程中会不禁质疑真实性，或者说质疑自己的格局，但其中很多做事的思路和态度是非常值得我们学习的。 因此，关键点在于从变化预测未来，环环相扣地思索应对变化的方法，如此循环往复才会萌发新的商机。（从变化预测未来，这可以锻炼学习出来吗？） 从变化中读懂“未来”，建立“假设”然后“执行”，再对结果进行“验证”。这一过程有助于优化工作模式——如果在平日的工作中坚持重复“假设-执行-验证”的过程，那么在不远的未来必将有所斩获。（对于大部分人的问题是，社会上宏观的变化怎么和自己的微观工作联系起来） 实现机遇并不需要特殊的才能，关键在于问题意识和思维力。其中，问题意识指能经常主动研究现行的工作模式是不是处于最优的状态。而思维力代表了深层次挖掘事物本质的能力。 在这一过程中，我逐渐掌握了有助于经营的两个基础的学科知识——统计学和心理学。 当时，我的顶头上司并不想改变持续已久的既定做法。但是，只要不轻言放弃就会出现支持自己的人。隔壁企划部主任对我的想法很感兴趣，并代为转达给了当时的社长，让我获得了在董事会上介绍方案的机会。最后，《新刊新闻》得以问世，其中还加入了采访著名作家及女演员等崭新的企划。 我之所以能在日后建立日本第一家真正意义上的便利店——7-Eleven，也是因为没有受制于行业常识的缘故（你的优势也是你的枷锁） 在最终谈判中，我们并没有采取任何精妙的战术，而是站在对方的立场思考，提出不能总是执拗于眼前的“费率”问题，应从长远考虑的论点，而这也成为了获得对方理解的关键转折点。 我们采取了和传统私人商店截然不同的做法，以全力提高生产效率和产品价值为目标，建立了独一无二的经营结构。 任何一家批发商都不愿改变固有的做法，甚至指责我们的提议违背常识。然而时代瞬息万变，世事也有各种不同的思考角度，常识并非永远都正确。面对顽固的批发商，我们这些门外汉不屈不挠，一家又一家，一次又一次地反复上门游说着。 1.在一定区域内，提高“7-Eleven”的品牌效应，加深消费者对其的认知度。而认知度又与消费者的信任度挂钩，能促进消费的意愿。（长沙的茶颜悦色） 简而言之，共同配送是指生产厂家、供应商和7-Eleven总部三方通过互相合作，集中原本相对分散的配送路径，从而形成的合理化物流体系。 我们要盯住“客户”而不是竞争对手，在我们眼中，真正的竞争对手并不是其他品牌的便利店，而是不断变化的“客户需求”。 与其作出没有任何依据的主观臆测，倒不如思考为何消费者会减少外出就餐的次数，尝试在时代的变化中挖掘更深层次的原因。 为了成长，必须积极应对变化挂在嘴上。（组织的核心价值观很重要） 站在他们的立场，或许很不情愿被我逐一盘问，但是如果不能应对上司的提问，就证明其在工作上有所疏漏。如果业务内容属于自己的管辖范围，不论别人提出任何疑问都应该具备迅速作答的能力。我也能借此判断对方是不是一个“用心工作、大有前途的人”。 演讲这一形式能让头脑在短时间内快速运转，让人灵光乍现。我并不把演讲当作倾吐自身想法的时间，而是利用它整理思维，使想法系统化，将这一过程作为启发创意的源泉。 连锁便利店事业的关键并不在于门店总数的多少，最优先考虑的理应是提升每家店铺的品质，这才是我们真正需要达到的“目标”。而公开宣布“要在几年内开设几家门店”的做法，无疑会让经营陷入歧路。 因为无论是谁，说过的话都会对行为产生影响。 所谓欲速则不达，工作中，应当沉下心思考应该做的事，仔细探讨前进道路中必须面对的问题，并逐一进行解决，像这样专心而脚踏实地的态度才是最重要的。 ◆ 零售の哲学 做不了基础工作的人也无力发起革新。 只要有发现问题的意识，有效的信息自然就会出现。 不要随口说出数值目标。 认为“多数人反对的事业往往能够获得成功”。反之，如果一项事业谁都表示赞同，势必会陷入全面的竞争状态，最后通常以失败或平庸收尾（大家都认为能赚钱的事，一定会竞争越来越激烈） 然而毫无实质内容的战略并不能长久地吸引顾客。更何况人的内心变化无常，一旦需求被过分满足转眼就会失去兴趣，达到饱和状态。 企业必须依靠自身的智慧建立可持续性发展的事业。如果企业没有认识到这一点，人云亦云地设定经营方针的话，最终必将以失败告终。 在引导各种项目推进的时候，每个成员对“项目实现价值”的认知程度是决定成败的关键因素。而作为领导者，重要的一环就是制造“认知”的契机。 开拓新事业时，关键要具备认清核心重点的能力，起步之初，并没有必要遵循完美主义。 如果把口感独到的食品素材、原料、调料的浓淡等要素数值化，逐一进行分析，那么“美味”也能得到具象。 不过，在协同多个企业研发产品时，有一点必须要注意，就是绝对不能成为“好朋友”。 ◆ 零售の哲学 不能沉迷于过往的成功经验。 改变卖方市场的思维方式。 主动开拓新市场。 社会情势的变化难以捉摸，不论过去下达了多么精妙的指示，我也会立刻回到一张白纸的状态重新建立假设思考。在这个日新月异的时代，经营也需要“朝令夕改”。 因为我发现社会中出现了下述三点变化的征兆。（中国也进入到一样的阶段了） 由于社会老龄化和低生育率，老年人的数目正在持续增长； 由两三个人组成的小规模家庭数量呈现出逐年增加的趋势； 个人经营的商店不断减少。 只要坚持“应有的工作态度”，就能绝处逢生，转变为稳步成长的企业 但我认为越是大型的计划，一旦决定实行就越应该注重速度。因为没有人可以预计下一秒市场会产生怎样的变化。 决定事业成败与否的关键因素在于“人”。要想掀起“改变”的浪潮，比起大刀阔斧的推翻一切，大胆地转换“思维模式”才是推进改革的第一步。 企业的实质和方针自当随时代改变，但我自身的性格却从未有过改变。正如序言所言，今后，我也将秉承勤恳和踏实的态度，继续指挥经营的航线。 如果问正在读这本书的你“为什么选择了现在这份工作？”，我想很少有人的答案会是“因为我喜欢”或“这是我的天赋”吧。可能70%的人都对目前的工作抱有不满，但又因为是自己的选择，依然咬紧牙关努力做到最好。而这就是职场人士应有的态度，既然决定了，就一定要有坚持到底的信念。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"},{"name":"企业","slug":"企业","permalink":"https://lchml.com/tags/%E4%BC%81%E4%B8%9A/"},{"name":"经营","slug":"经营","permalink":"https://lchml.com/tags/%E7%BB%8F%E8%90%A5/"}]},{"title":"《我曾走在崩溃的边缘》","slug":"wczzbkdby","date":"2023-09-26T16:00:00.000Z","updated":"2023-10-07T02:23:01.836Z","comments":true,"path":"book/wczzbkdby/","link":"","permalink":"https://lchml.com/book/wczzbkdby/","excerpt":"从绝望中寻找希望","text":"从绝望中寻找希望 新东方在经历双减之后依然能在绝境中重生，完美印证了俞老师在本书中所展示的个人品质和企业文化。从绝望中寻找希望，俞老师真的做到了。最近自己在经历组织的变革，对书中一段关于变革的论述深有同感。 “变革不只是一个结构的问题，更是一个心态的问题。只有当所有人都愿意去变革的时候，这个变革才能推动。推动变革最重要的要素，既不是理想，也不是情感，甚至不是未来，而是利益的分配机制。也就是说，当所有人或绝大部分人都意识到变革能给自己带来巨大的利益和良好的未来预期的时候，这个变革就特别容易推进了。” “在组织机构和个人身份发生变化的过程中，利益猜忌问题就出现了。” 同时，我还在北大继续教书。教书对我来说还是比较轻松的，教的都是和原来一样的内容，每个星期只要上八小时的课，剩下的时间都是自己的 本来我还是想留在北大的，因为当时我的理想就是出国留学，留学成功以后，比如到国外读了博士，回来继续在北大当老师，图一个安逸的生活。对我来说，每天早上读读书，在未名湖边散散步，是很舒适的生活。而且当时我已经结婚了，就图个安稳。 这应了中国那句老话：“人挪活，树挪死。”离开北大的时候，我内心还是很凄凉的。但是今天看来，凄凉是没有必要的，因为虽然我离开了一个让我感到极其安全的舒适区，走进风雨之中，但就像大家常说的那样：风雨之后才能见到彩虹。 这套方法跟现在互联网的应用方法其实是差不多的，其本质就是你如何能够以最低的代价获得最可靠的客户，并且让这些客户变成你的品牌宣传员，愿意把新的客户带进来，这就是做生意的本质。 我之所以要全面备课，一是因为缺老师，二是因为我希望对每门课的教学特点进行研究和了解，这样当我去听这个老师课的时候，就能知道这个老师讲课的优点和缺点，并且通过对老师讲课的优点、缺点进行分析，引导这个老师把课讲得更好。所以，当时我也抱着培养老师的目的，让自己先把每门课都备好。 我教每一门课还有一个重要原因，那就是我发现如果有一门课我不会教，另外一位老师会教的话，这位老师就会觉得自己在这个课堂上特别重要，不可替代，他会高估自己。 如果公司在某一个领域，比如技术、市场营销或产品设计领域，过度依赖某一个人，除了这个人别人都做不了，其结果就是要么给这个人特别高的薪酬待遇和股权激励，要么就去找一个跟他水平相当的人一起干这件事情，否则到了一定程度，会出现“挤兑”或“造反”的现象。其实，我后来碰到的很多创业公司之所以倒闭了，就是因为公司最核心的、不可缺少的人才离开公司，或公司人才缺失导致的。 提高自己的讲课水平还可以同时培训新老师，省下来的钱还能用在新东方进一步的发展上。 创业公司倒闭，常常是由于创始人不懂核心业务导致的。 当时我在新东方全面备课，其实内心也有防范这种大厨效应的想法。也就是说，我既是老板，又是做饭最好吃的人，这样的话我的饭店就安全了！ 当有一件事情你不能做的时候，一定要找几个人同时帮你做。除非你相信自己已经给了这个人足够的利益，并且这些利益能够保证他一辈子都愿意跟你一起干。当然，这是不太容易做到的。 当一个人向你提出过分的要求时，你会怎么处理，这在某种意义上代表你的能力和智慧。 但从本质上来说，只有把利益的问题摆正了，人与人之间的友情才能长久。 所以我后来实行了这样一个分配体系，就是确保老师的工资收益，比如老师来新东方讲课，他的工资与北京同类机构的工资相比已经是最高的，所以他会觉得很划算。 大家都知道，公司或组织在不同发展阶段的利益分配是最难的，公司在不同时期应该采取不同的分配体系以留住不同的人才。 人们常常能够在艰难困苦的时候团结在一起艰苦奋斗，但是在面对利益的时候，却往往做不好利益分配的工作，导致公司倒闭。 我觉得我能够成功的一个很重要的因素就是我没有自己要先拿钱的想法。 拿到这个盖了章的证明以后，我就又到了海淀区教育局。海淀区教育局的工作人员说：“这就算齐了，就给你办吧！”于是，我拿到了办学许可证。拿到办学许可证的那天是1993年11月16日，我记得特别清楚。那天狂风大作，我骑着自行车，马路边上几十年的大杨树树叶落了一地，被狂风一吹，满天飘舞。 从某一个点上把自己带到最高点，让自己占领用户的心智，再向最高点延伸，这可能就是品牌的成功之道。 从绝望中寻找希望，人生终将辉煌。 在这点上，我觉得我还算是抓住了一项事业发展的核心要素：你的事业能发展多大，要看你的合伙人有多强。 人遇到机会时，还是要闯一闯的，虽然我们并不知道这到底是不是一个机会，也许它就是一个坑，是有风险的，但只要你觉得这件事情值得做，即使失败了也不会有太严重的后果，那就应该去试一下。 所以，我希望我的同学和朋友们，以后在面对选择时要更加有勇气，更加有眼光，要更加坚定不移地沿着会给自己带来精彩的生活道路走下去！ 不管是过去的企业，还是现在的企业，都是一样的，都要先想办法让企业活下去，即使有资金也要学会节流，把资金用在最关键的时刻。 情怀是什么？就是明白我们到底要干什么，就是自己在做一件事时，要有成就感，要引以为傲，并且能为这个社会带来某种好处和进步，这就是情怀的最终解释。情怀就是在做一件事时把个人和社会揉在一起，同时对两者都有好处，这就是情怀的核心。 组织结构决定了一个公司的发展规模，所以毫无疑问，我们现在就需要有人来帮我们建立组织结构。 其实，变革不只是一个结构的问题，更是一个心态的问题。只有当所有人都愿意去变革的时候，这个变革才能推动。 推动变革最重要的要素，既不是理想，也不是情感，甚至不是未来，而是利益的分配机制。也就是说，当所有人或绝大部分人都意识到变革能给自己带来巨大的利益和良好的未来预期的时候，这个变革就特别容易推进了。 在组织机构和个人身份发生变化的过程中，利益猜忌问题就出现了。 一个人做事情是要有底线的。所谓的底线实际上是人品底线和道德底线，也就是说，无论任何时候都不能为了自己的利益，去破了人品底线，哪怕再受欺负。 今天再回头看，在那一段艰难的岁月里，我们所有人都没有做任何没有底线的事情，这无疑是新东方发展的基础，也是新东方精神文化的一部分。 这是我人生的一个准则，那就是无论人在什么岗位上，在任何困境中，都要让自己保持进步。 一个机构要给新人“三个台”：一个是舞台，一个是平台，一个是后台。 企业应该创造事情来做，而不是为了解决问题来做事情，离业务越来越远，这是包括新东方在内的很多企业都存在的问题。 我们未来要做到的，就是在尽可能屏蔽资本带来的坏处的前提下，尽可能利用资本的力量，为中国教育的发展做出贡献！ 让没有历史包袱的人走向战场，这样有利于新东方的发展。 这项变革后来被商学院归纳为一整套理论，叫非连续性业务发展，又叫第一线和第二线。什么是非连续性业务发展呢？就是任何一个行业、任何一家公司想要有大发展的话，不能只做主营业务，因为这样的话它的市场容量是有限的。 一些新项目的管理者和开拓者，其实并不一定非要从新东方内部一点一点地培养，而是可以引入外面的成熟型人才，这样这项业务能够得到更加迅速的发展。 关于大方向，我认为有以下几点需要注意：第一，要重视这个市场，因为这个市场确实存在；第二，要为市场提供更好的服务；第三，要把服务品牌建立起来，让老百姓信任你的品牌。 现在，我可以比较自信地说：在一个孩子健康成长的过程中，父母的作用占到了80%左右，学校的作用占到15%左右，而社会的作用占到5%左右。 我觉得从危机中去寻找机会，是一个企业家应该具备的能力。 每一个考核指标都决定了下面人的动作。因此，考核指标要满足两个条件：第一，考核指标必须跟企业的文化、战略和未来紧密结合；第二，所有的考核指标从上到下必须保持一致。 考核指标相当于整个公司的行动指南，新东方的考核指标经历了从没有考核指标到有非常粗犷的考核指标，又从不合理的考核指标到相对正确的考核指标的过程。当然，考核指标没有绝对正确的。因为每一年，各个公司的战略方向和重点都会调整，而这些调整就是从考核指标上反映出来的。所以，各个公司的考核指标都会在第二年进行修正。 有些人像流着流着水量越来越小的河，就像沙漠中间的断头河一样，到最后就是水渗透到沙漠中，没有了踪影，人生也变成一片荒芜。 因为你发现自己像一只家养的动物被扔到了荒野中，选择只有两个，要么在荒野中饿死，要么迅速学会捕食猎物！所以，在艰难的环境中，你的成长速度反而会更快。 个人成长和团队成长是完全不同的，个人成长可以随心所欲、心愿所到，快一点或慢一点，做错了或做对了都由自己负责。但是到了团队中，你就必须为团队负责，既要展示自己的成长速度，又要展示自己的眼光和威望。 所以人在关键时刻，是要知道后退的。但所谓的“后退”不是能力上的退化，而是退一步海阔天空。 所谓的“历练个性”是什么意思呢？就是对于有些你不愿意面对的东西，要想办法去面对，因为你不去面对的话，这件事情就永远留在那儿，永远也解决不了，到最后甚至会发酵，会越来越麻烦。 因为我觉得这是对一个人生命的承认，对一个人自由意志的承认，而自由意志和奋斗精神一直是我信奉的核心价值观。个人的自由以及个人的探索是大于一切利益的。 用靠谱的人做伟大的事，分更多的钱。 我个人认为，降低做事的成本最好的方法就是把自己变成一个诚信、坦诚和值得别人信任的人，而且是唯一的方法。你只要做到这些，就可以把精力、时间和资源用在你的事业和人生中最重要的地方，而不是把精力耗费在无聊的信息上。 其次就是中国从古代到今天就是一个人情社会。人情常常会大于规矩。有时候，我们按照规矩去做事情，人家可以不理你，但是你要按照人情去做事情，人家就可能会理你。所以在中国的不少场合，如果人情没到，关系就不会到。你在中国做事情首先要把人情建立好，关系才能建立好，这是一个循环的过程。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"传记","slug":"传记","permalink":"https://lchml.com/tags/%E4%BC%A0%E8%AE%B0/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"《华为铁三角工作法》","slug":"huaweitiesanjiao","date":"2023-09-20T16:00:00.000Z","updated":"2023-09-22T01:45:17.384Z","comments":true,"path":"book/huaweitiesanjiao/","link":"","permalink":"https://lchml.com/book/huaweitiesanjiao/","excerpt":"让听见炮声的人来决策。学习理论很简单，根据每个人每个组织的不同情况，理论怎么结合实践才是最难的。这本书是华为销售体系的一个总结，作为工具书做一些参考还是挺不错的。","text":"让听见炮声的人来决策。学习理论很简单，根据每个人每个组织的不同情况，理论怎么结合实践才是最难的。这本书是华为销售体系的一个总结，作为工具书做一些参考还是挺不错的。 本书对华为销售体系进行了系统性探索和深入研究，总结了华为通过构建敏捷的铁三角及从线索到回款流程（LTC）的端到端保障体系，让销售从不确定走向确定的底层逻辑。 核心是一靠流程，二靠团队，而前提是一心为客户创造价值的理念。 华为一线销售团队的奖金分配不采用销售提成制，而是基于目标达成率的“奖金包分配模式”，按照“贡献和利润分享制”，辅以项目奖励，通过激励机制实现集体与个人的利益平衡。 不要对客户说你的产品有多牛，而要说你的方案对他有什么价值！ 销售是需要兼备个体进攻性和团队协同性的工作，没有进攻性便拿不下订单，这个道理显而易见；而没有团队的协同配合，即便拿下了订单也无法长期为客户提供让其满意的产品或服务，客户满意度自然无法提升，也就失去了复购和转介绍的可能。 铁三角由三个角色组成： 第一个是客户经理，或者叫作销售经理，简称为AR（account responsible，客户负责人），主要负责客户关系、业务需求管理、商务谈判、合同与回款，也就是案例中的小李。 第二个是方案经理，简称为SR（solution responsible，产品方案负责人），主要负责产品需求管理、产品与方案设计、报价与投标、技术问题解决，也就是案例中的老黄。 第三个是交付经理，简称为FR（fulfill responsible，交付负责人），主要负责从订单、制造、物流、安装到交付验收的项目管理。 铁三角并不是一个三权分立的制约体系，而是紧紧抱在一起生死与共、聚焦客户需求的共同作战单元。它的目的只有一个：满足客户需求，成就客户的理想。 然而风起于青萍之末，每一座手可摘云的高楼大厦，都是从挖下地基的第一铲土开始的。 但表象背后暴露出来的是组织架构与客户端的需求不匹配，绝大多数人还在按照传统模式运作，客户经理不懂产品，产品经理不懂交付，交付经理不涉及客户界面，每个产品部只是简单地沿用在国内的报价模式，只关注自己的一亩三分地，缺乏统一协调的整网解决方案。 LTC流程的价值主要体现在客户更满意、财务更健康、运营更高效三个方面 对客户经理而言，在销售一个产品前，需要了解客户的现状和面临的问题，从中找到机会点，只要你认定客户有需求，而且这个需求是真实的，坚信能用自己的产品和服务为客户创造价值，就应该从客户角度出发，充分为客户着想，取得客户的理解和信任。 一个合格的客户经理必须同时扮演四种角色：销售项目的主导者、客户关系平台的建立和维护者、全流程交易质量的责任者，以及客户群规划的制订和执行者 华为并不强制要求客户经理参与具体的产品解决方案设计，也不考核他是否参加后期的实际交付工作，公司只关注这名客户经理是否在项目中充分理解了客户的需求，并带领铁三角团队拿下项目获得订单，赢得客户信赖，这才是一名优秀的客户经理的真正职责所在。同时，客户经理还必须及时处理方案经理和交付经理提出的客户界面的工作需求，更紧密地联系客户，达成整个团队协同的结果，这些工作要求是要被考核的。 方案经理是一个十分重要的角色，他绝不是客户经理的简单辅助，而是作为一个项目的战略分析者和策划者，负责分析市场和客户的方方面面，拉通各方面的资源，以求最大概率获得项目成功。 方案经理最核心的角色定位，是产品格局的构造者、品牌的传播者以及盈利的守护者。 因为很多公司在项目运作的过程中，往往将交付置于最后环节，就是客户经理和方案经理在千辛万苦拿下订单之后，就会将绝大部分精力投入新项目的开发与新机会点的找寻，而将此前签下的合同直接甩给后端交付部门，再也懒得过问。而后端交付部门由于对项目前期的参与度不够，不完全了解一线客户经理对客户做出了怎样的承诺，而且这些承诺是否能够完成，并没有经过交付部门的确认。 交付一定要提高效率，从本职工作开始改善，提高自身能力。正确理解客户需求，正确做出合同，正确录入合同，正确发货，正确交付，正确服务，每一个环节都很重要。” 最重要的一点，便是要求销售团队拥有实现契约管理的能力，确保无法完成交付的事情不在合同中体现。基于这个目标，在铁三角销售体系中，华为要求交付经理一改以往的弱势形象，全程参与项目从立项到合同签订的过程，全面了解项目的前因后果，并且发表自己的专业意见。 交付经理在铁三角销售体系中具有十分重要的作用，其责任和价值不再仅仅是“售后” 真正的铁三角只有一个共同目标，今年会有多少订单，形成多少收入和回款。在分钱的时候，也要基于这个目标制定一个奖金包，而不是在各自的职能部门拿提成。” 这才是铁打的三角，是个利益共同体。如果各有各的利益，必然出现“屁股决定脑袋”的情况，无法真正实现对客户价值的创造。 学习铁三角销售法，首先观念上要转变，面对客户，无论你来自销售部门、产品部门、交付部门还是研发部门，都是代表公司，没有“我们”“你们”“他们”，只有“我们”，客户也只会记住你公司的名字。 需要强调的是，铁三角销售团队每天白天在与潜在客户交流之后，晚上一定要回到办公室集中碰个头，看看当天挖掘出哪些新的客户需求，又有哪些客户需求需要综合考虑，甚至有哪些需求需要“呼唤炮火”，将公司相关专家拉进来一起讨论。 只有自己创造的线索，才可称为真正的第一手线索，对销售团队才具有最大的验证价值。 企业所有的研发、市场、产品与服务等业务，都必须由客户需求来驱动。满足客户需求、为客户服务，是企业存在的唯一理由。 在项目运作的关键环节，作为一线作战单元，当地的铁三角团队会促成公司高层间的交流与访问，在此过程中敲定关键问题，实现双方一拍即合的效果。这把利剑在华为的销售团队内部被戏称为“用好老板为项目打工”，这也是华为铁三角销售法的一个亮点——一线呼唤炮火。华为的管理层都是业务人员出身，“招之即来，来之能战，战之能胜”，为一线业务提供炮火支援，是华为公司高层义不容辞的责任。 关于竞争，任正非说过两句名言。第一句：“什么是核心竞争力？客户选择我而没有选择你，就是核心竞争力。”第二句：“公司之间的竞争，说白了，就是管理的竞争。” 销售成功的逻辑，说到底就是客户、竞争和自身的博弈。谁能快人一步掌握客户的痛点和需求，比竞争对手更好地帮助客户解决问题，谁就能赢得活下去的机会。 事后弥补远不如事中控制，而事中控制又远不如事前管理，这就是线索管理的精髓所在。 没有痛点就没有业务，客户的问题就是推动项目前进的动力。发现问题和解决问题，是销售团队最基本的工作内容。销售人员经常使用的痛点分析引导分类表 让客户意识到付费的价值。客户都会认为花钱是一件很痛苦的事，要让客户认识到问题带来的痛苦比花钱的痛苦更大，客户愿意花钱，销售机会也就产生了。 及时建立起和客户的连接。当客户想通过购买产品或服务来解决痛点时，会第一时间联系你，而不是联系你的竞争对手。这一点至关重要，否则，你就只是为竞争对手作了嫁衣。 线索管理流程示例 线索和机会点都来自客户，二者的主要区别在于是否有明确的预算和启动时间。对于客户没有预算的线索，你投入的时间和精力再多，也有可能打水漂；如果客户已经准备好了充足的预算，有明确的项目时间，加上公司有与之匹配的解决方案，那么销售机会就真的来了。 华为各级销售管理部直接参与管理的便是立项决策环节，这个环节直接决定了该项目的级别以及对应的资源投入。立项决策一般是由铁三角团队中的方案经理或者客户经理发起，明确了客户可能需要的产品和预算的多少，以及项目需要申请的级别。不同的项目级别对应的支撑资源完全不同，包括高层支持资源、研发支持力度、项目预算，等等，相对应的项目奖金也有着巨大的差异。一线的销售团队为了取得更多的资源支持，往往都会想方设法放大自己的机会点以申请高对应的级别，因此制定项目级别标准非常重要。 团队销售中最难处理的地方在于过程的不确定性。因为正在运作的项目总是处于各种可能发生的变化之中，而销售漏斗的基本思想就是变不确定为确定。请记住：只有确定才能量化，只有量化才能管理。 有经验的销售人员都知道，一个项目标书发出来的时候，80%的结果其实已经基本决定了。铁三角销售法的核心之一，就是各个角色在线索开始就不同程度地介入，标前引导是一个非常重要的阶段。 客户为什么选择你？关键是你向客户传递了什么样的价值主张，你能帮助客户实现什么价值。 客户关系策略可以简单地表述为一句话：找对人，说上话，办成事。 从机会点到最终生成合同，整个过程势必涉及客户方的多人决策，并最终形成一条决策链条。在这条决策链上往往存在若干个角色，这些角色对该销售机会的最后确定发挥着至关重要的作用，如果处理不当或者有所遗漏，很容易出现“莫名其妙的刁难”。 销售的本质，就是一个不断对客户决策链条施加影响的过程。 销售人员在评估客户的决策链条时，千万不要忽视一些关键的隐形角色。例如，决策者的股东、利益相关方、家人、好友、社交团体成员等，都很有可能对该决策者产生影响。另外，直接业务相关方的领导及分管的副总，有时甚至还包括一些客户单位中的明日之星（具有发展潜力的管理者、技术骨干或业务骨干），都有可能对项目决策产生影响。因此，一个完整的客户决策链条，必须对这些“隐形角色”加以分析。 真正困难的，是用规则的确定性来应对业务运作过程中的不确定性。 针对重大的拜访，尤其是高层拜访，以终为始是拜访成功的重要思路之一。良好的开始是成功的一半，用于破局的武器，必须是精品。销售团队必须要有这个习惯。 销售不仅是产品的竞争，更是方案的竞争。不要对客户说你的产品有多牛，而要说你的方案对他有什么价值！ 在铁三角销售团队的方案经理和交付经理背后，都有对应的研发“娘家组织”给予支持和配合。在华为，市场和研发不是两张“皮”，而是天然的联盟。如果一线呼唤“炮火支援”，公司就会安排产品管理的专家来一线，和铁三角团队一起参与关键项目的拓展与竞争，这是他们的岗位职责之一。 这是一种行之有效的顾问式销售策略，它有针对性地提出具有差异化和竞争力的解决方案，让竞争对手无计可施。具体而言，SPIN销售法可分为以下四个部分。 SPIN销售法可分为以下四个部分。 （1）S（situation question）：背景问题 （2）P（problem question）：困难问题 （3）I（implication question）：暗示问题 （4）N（need-pay off question）：需求效益问题 SPIN销售法的核心，在于通过一系列提问启发目标客户的潜在需求，使其认识到购买此产品为他带来的价值。这种销售方法能够帮助销售人员较为准确地找到客户的痛点，从而让解决方案有的放矢。 什么是高质量合同？华为对此的理解极为直白、简练而精确，那就是“合理利润、正现金流、风险可控、客户满意”。高质量合同除了能给客户带来正向的商业价值，还应该让双方都能规避潜在的风险，最终实现双赢。要想实现这个目标，需要系统性地评审、决策，并对合同的条款风险和履行风险进行严格管控。 盈利是公司的头等大事。在一定程度上，严格的风险控制环节或许增加了一线销售团队的工作量，也或多或少会降低一些决策效率，但能保证稳定的利润回报，防范相关风险，积小胜为大胜。 “轻诺必寡信，多易必多难。”所谓信任，就是在每一件承诺过的小事上都做到言而有信，真真正正地以客户为中心。 交付经理在售前阶段就要介入项目的销售工作，一方面约束客户经理向客户做出的承诺，另一方面也要对客户的各种要求进行合理化处理，并且将项目推进过程中可能出现的各种问题的权责归属进行合理划分，控制服务的可交付性。 高质量的交付与服务，除了流程体系和组织体系的构建，还需要现代化信息系统的支撑和驱动，华为构建了强大的项目管理集成信息系统，将高质量的交付与服务能力打造成华为的核心竞争力，成为客户选择华为的重要支撑点。 我在走访某客户公司时发现，在这家公司里，每个项目组内的交付人员都很努力，但满脑子想的只是如何管好自己的产品交付，压根儿不关注其他产品。于是我劝这些一线项目组的工程师尽量一专多能，多从端到端的角度关注整体的产品交付情况，但很多人跟我说“我不会做，做不了”，然后就开始推卸责任，抵触情绪十分严重。 如果要学习华为“让一线呼唤炮火”，就需要从前端向后端梳理流程和组织，最终以流程来驱动项目，才能长治久安，铁三角销售团队在一线才能真正落地，人员才能实现真正的转身。转变要从思想上开始，思想通了，自然一通百通。 敲定了“谁听得见炮声，谁来呼唤炮火”。铁三角定义了什么是炮火——各种资源，也明确了到底“什么是炮声”——来自市场一线的客户声音。 不是客户说什么，我们就要做什么。铁三角团队要学会找到客户声音的根源，通过分析提出更有针对性的解决方案，这才是我们面对客户声音的应有态度。 客户经理任职标准要求示例 方案经理任职标准要求示例 交付经理任职标准要求示例 考核是激励的前提，有考核标准才有激励标准 对铁三角销售团队的考核，主要包括合同财务、卓越运营和客户满意度三大指标。合同财务指标包含收入、利润、现金流和成本达成情况；卓越运营指标包含业务、质量、时间和预算等合同条款履行情况；客户满意度指标则包含客户体验、问题解决和关系维护情况等。 （1）客户经理 客户经理的主要职责是确保为客户创造价值，使客户满意，与客户建立良好关系；关键指标是销售目标达成（收入、利润的前提）、回款目标（现金流）达成和客户满意度，这是内部考核指标，而真正以客户为中心的价值创造才是根本。客户经理既代表客户的利益又代表公司的利益，掌握二者平衡的奥秘才真正体现出客户经理的能力。 （2）方案经理 方案经理的主要职责是为客户提供满足其需求的、有竞争力的解决方案，关键指标是销售目标的达成（收入、利润的前提）和产品市场份额（收入、利润的前提）保障。因此，方案经理要懂得如何呈现产品与解决方案的价值，站在客户的维度去思考价值创造，以及如何让客户感知和认可相关的独特价值，而不是纠缠于产品与解决方案的低层次功能。 （3）交付经理 交付经理的主要职责是保障合同成功履行，以及客户对合同履行的满意度，关键指标是收入的达成、成本控制和卓越运营指标。交付经理需要在项目早期介入，参与产品与解决方案设计，在合同和订单产生的过程中提前控制和避免交付风险，并与客户达成一致。在这个过程中，与客户经理和方案经理的协同以及与客户达成共识的水平，体现出交付经理的能力。 以上三个角色在考核时会采用平衡记分卡模式，主要考核指标一般可分为关键财务指标（70%）、关键举措（20%）、团队合作（10%）和个人学习与成长（加分项），按照公司目标制定管理办法进行目标制定，按照公司个人绩效考核管理办法进行考核，考核结果按照公司激励与奖励管理办法进行应用。铁三角人员个人绩效考核PBC示例： （1）奖金分配制度，华为在一线铁三角销售团队的奖金分配上，坚持不搞“销售提成制”，而是基于目标达成率的“奖金包分配模式”，即按照“贡献和利润分享制”，再辅以项目奖励，实现集体与个人的利益平衡。 （2）考核指标 （3）落实“以客户为中心，为客户创造价值”的协同价值导向华为不断强化市场、销售、研发、供应链都应面向“实现客户需求，让客户满意”的价值诉求，通过面向市场和客户的考核指标进行拉通。主要做法是：在上下游业务单元之间形成考核联动，设置客户满意度指标，并利用考核指标的互锁，让所有部门都面向客户进行承诺。 华为不断强化后方与一线铁三角团队的高效协同，从“以自我和领导为中心”向“以客户为中心”转变。 铁三角的有效运行，需做好利益机制和经营机制的协同，从共同的KPI、能力管理、决策与授权、资源池可收费性&#x2F;利用率等几个要素进行赋能 在华为的LTC流程中，包含立项决策、投标决策、合同决策、合同变更决策、合同关闭决策五个方面的内容。 1、团队文化 2、业务流程 3、组织体系 4、授权机制 5、考核与激励机制 6、数字化系统 对企业来说，思维层面的认知升级，最好要先于业务层面的改变。没有一个合适的文化基础，即便业务调整到了合适的方向，也很难成功落地。所以，要想让员工从意识形态上接受铁三角销售模式，企业还是要从文化建设的角度入手。 1.“以客户为中心”的价值导向 2.协同价值导向 为了保证三个关键角色不会在具体的工作中忽略协同一致的核心逻辑，企业需要给这三个角色找到一个共同的参照物。在实际工作中，和铁三角团队当中的三个角色都有关系，同时又对最终的销售结果有重要影响的因素，其实就是客户。 想要组建自己的铁三角团队，首先要重新塑造自己的销售业务流程。 产品交付需要一定的时间才能到位，在这个过程当中，客户的心情会比较急切。为了避免客户产生焦虑心理，交付人员需要将交付状态可视化地呈现给客户。比如，我们在电商平台上购买商品之后，快递的运输路线和到达位置都能实时进行展示，这就是所谓的交付可视化的一种表现形式。 LTC作为客户价值创造的主流程，是从“以客户为中心”的核心价值观中生发出来的战略系统，也是铁三角团队工作的平台。走台阶之所以比爬陡坡更容易到达山顶，就是因为稳定而循序渐进。企业复制铁三角的过程，无异于攀爬一座高山，一步步脚踏实地，更容易到达目的地。 只有企业确定了自己的销售业务流程，才能明确销售团队在具体的工作中需要承担哪些责任，以及履行责任需要拥有哪些权利。 数字化系统的价值不仅仅是提升销售流程的效率那么简单。更重要的是，系统可以为人赋能，系统也驱动着人工作。 从数字化营销、数字化交易、数字化采购和供应、数字化办公这四个维度进行设计。 在项目竞争中，竞争对手抛出远低于我方的价格，如何应对？答案是：三看一定。有针对性地采取组合策略来应对，而不是直接和对手比拼价格，两败俱伤。 作为一个职业的一线销售人员，首先要思考的是客户为什么要求降价？客户要求降价的真正想法是什么？只有明确了客户真正的想法，才能做出正确的应对措施。所以，客户提出降价要求的时候，我们首先要做的是对客户要求降价的根本原因做出正确判断，而不是思考怎么降价。 客户要求降价的六个常见场景分析及对策： 1.客户还在担心风险和收益。 2.其他对手抛出更低的价格。 3.超出客户预算。 4.客户组织绩效要求。 5.客户有个人诉求。 6.客户只是随口一说。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"},{"name":"领导力","slug":"领导力","permalink":"https://lchml.com/tags/%E9%A2%86%E5%AF%BC%E5%8A%9B/"},{"name":"销售","slug":"销售","permalink":"https://lchml.com/tags/%E9%94%80%E5%94%AE/"}]},{"title":"《即兴演讲》","slug":"jxyj","date":"2023-09-12T16:00:00.000Z","updated":"2023-09-14T05:58:49.619Z","comments":true,"path":"book/jxyj/","link":"","permalink":"https://lchml.com/book/jxyj/","excerpt":"本书的目的是让每一位读者在即兴演讲时拥有更好的表现，其中的秘诀并不像读者想象得那样复杂，简而言之，秘密在于准备！也就是说你必须做好“自然应对”的准备，这听起来似乎自相矛盾。不过，对任何希望影响他人的人来说，“引领当下”是目标，而“准备好自然应对”则是实现这一目标的手段。","text":"本书的目的是让每一位读者在即兴演讲时拥有更好的表现，其中的秘诀并不像读者想象得那样复杂，简而言之，秘密在于准备！也就是说你必须做好“自然应对”的准备，这听起来似乎自相矛盾。不过，对任何希望影响他人的人来说，“引领当下”是目标，而“准备好自然应对”则是实现这一目标的手段。 即兴演讲关系到语言、脚本及表演。不过，在选择语言或打底稿之前，还需要有正确的思维模式。这就是本书第二部分要讲的内容。正确的思维模式包括领导意识、倾听、真实、专注和尊重。保持正确的思维方式，之后要做的事情自然会按部就班、水到渠成。 选择合适的时间和地点 获得观众充分的注意力 谈话内容要有价值 建立关系 面对面沟通 得体沟通今天的组织结构已经更加扁平化，但在组织中不管是上下层级还是部门之间，仍然存在办公室政治。这也意味着即兴对话要符合身份且得体。 用你的大脑：理智倾听理智倾听是倾听的第二个层面，即全心参与对话、在对话中探索和构建新思想。这一层面的倾听包括创造性地处理其他人或其他小组提出的想法。 笔记最好的方法是用手记，而不是在电脑上记录。有研究表明，尽管用电脑记录得更快，但手中的笔却比键盘的功能更为强大。当你用笔记录时，大脑会归纳整理材料，最终让你对会议内容有更深刻的领悟。 用你的心：有感情地倾听倾听的第三个层面涉及与他人情感上的联结，同时不让自己的感受妨碍有效倾听。往往员工会认为这种“同理心”非常重要，而领导者却常常低估它。 即使有人做了一些冒犯你的事，你也需要超越这件事，不要启动情绪反应，否则只会造成更多的压力和抵触。聆听并尝试理解对方的动机。 倾听是一个高强度的创作性过程，无论是身体的、理智的倾听，还是情感的倾听。引领当下所需要的一部分知识存在于你周围人的身上，正是他们的想法、观察、建议、恐惧、目标和激情引发了你的回应。人们永远不会跟随一个人，除非他们相信那个人真的理解他们。领导力思维必须包含倾听的欲望和倾听的能力。 可信是领导力的基础。他们解释说：“人们只有信任领导者，才会跟随领导者。” 展示真实性的策略有很多方法可以展示真实自我。接下来的六个方法将使你触及真实的自己。 第一，真实地处于当下。凸显真实性，首先需要你保持在当下。 第二，分享你的想法。真实性意味着有勇气分享你的观点和看法。 第三，分享你的信念和价值观。真实的领导者用自己的信念和价值观影响激励他人 第四，分享你的感受。真正的领导者会分享他们的感受并且对他们的听众保持敏感。 第五，分享你的脆弱。真正的领导者直面自己的优点和缺点。 第六，分享你的故事。对你的雇主、老板、团队、同事、客户或朋友来说，没什么比分享一个鼓舞人心的故事更能让大家对你产生亲密感。 温斯顿·丘吉尔曾经调侃那些讲话主题不明确的人，他说：“起床之前，他们不知道自己要讲什么；讲话的时候，不知道自己在说什么；坐下时，不知道自己刚刚讲了什么。” 首先是学科知识。人们期望你展示出你对正在讨论的话题有扎实的知识背景。其次是一般性知识。越博览群书，在科学、政治和体育的发展方面越与时俱进，你的观点会越丰富，你的演讲就越有说服力。最后是经验性知识。最棒的即兴演讲者还会在演讲时讲述一些个人经历。 无论你所在组织、团队如何，一定要写下关键信息和其他支持性信息，并且将这些信息刻在脑子里，每次讲话时都引用它，这些将构成你即兴演讲草稿的基础。这些步骤将有助于你对各种即兴情况做好准备。所有出色的即兴演讲者都会事先做好准备、构建扎实的知识基础，并牢记关键信息。正如一位客户所解释的：“最好的即兴情况是当我做足准备，当我熟知相关材料，无论你把我放在什么情形中，我都能脱口而出。” 记住在任何情况下，事先收集、整理自己的想法非常重要，千万不能毫无准备就上台发言，不能想到什么就说什么。这种跟着感觉走的讲话方式对于领导者来说非常不合适，会导致听众的“彷徨”和“困惑” 讲话没有要点，讲话就变成了基于信息而不是基于想法的沟通，听众就会搞不清楚你提出的建议究竟是什么，或者你为什么要提议开展某种行动。 领导者用观点来引领他人。而观点不会在你说话的那一刻不请自来，你需要事先为即兴讲话做好准备。 第一，讲话要点是你的观点，即将你的想法浓缩成一个你希望听众信服的观点。你在讲话时要始终围绕这个重点。 第二，要点是简单、清晰的一句话。为什么？因为如果你的信息不止一句话，而是一个冗长而复杂的句式，听众就很难“理解它”。 第三，有吸引力。要点应当能够吸引人心。如果希望听众信服你的观点，那么你需要设计好要点，让听众能够理解它、相信它，并想要跟随它。 第四，要点承载着你的信念。要确保首先自己要相信自己的讲话要点。 第五，积极正面。讲话要点应当能打动整个会场，确保要点包含希望、目标、可能性和成就。 第六，清晰可辨。确保每个听到你讲话的人都能够识别出你讲话的要点。通常在表达要点时，要采取强势、明确、宣告式的陈述方式（带着确信的语气），以凸显这些要点就是你的主要观点。 通过练习，每次即兴演讲都有要点、每次都能自然地演讲将会成为你的第二天性。你会自然而然地想到讲话要点，但形成要点有时可能需要勇气，特别是向上级汇报时。一定要记住听众，尤其是你的上级，他们希望你说话清晰、切中要害而不要浪费他们的时间。如果你想在今天的知识经济时代中让人听到自己的观点，那么讲话有要点是一个强大的策略。 如果已知道自己将现场发表讲话或回答听众提问，那么尽可能提前构建讲话脚本，即使你不确定是否要讲话，也要在纸上或脑子里记下一些要点，以备万一。 提出案例涉及如何为论证要点选择正确的组织模式，而对即兴演讲来说这种选择经常在瞬间发生。成功的秘诀在于领悟以下四种组织模式，并为每个即兴脚本选择最好的模式。 1.原因模式。这种模式罗列各种原因及理由来支持主要观点。 2.方法模式。这种模式显示的是实现主要观点可以采取的具体行动方式，或者是那些必须完成的“事情”。 3.情况&#x2F;反应模式。当讲话要点涉及某种情况或挑战而需要采取行动时，就可以使用这种模式。第一点可以描述情况或挑战，第二点可以描述如何回应。 4.时间顺序模式。这种模式通过时间序列来详细描述讲话要点。 领导者有大量的机会影响和激发他人。当别人讲话时，我们应当仔细倾听，并基于他人的观点做最后决策。当我们讲话时，即使是在会议中激烈交锋的时刻，也应当花一些时间收集、整理自己的想法。这样做，不仅会产生更好的想法、更好的决策、对参会者更多的关注，而且日复一日，你将为自己建立领导者的形象。 当想发展事业时，必须要知道你希望人们记住关于你的信息是什么，或许是你正在找工作，或者你是在职状态，或正在为另一个机会重新定位自己。归根结底，当人们转身离开时，你想让他们记住关于你的什么信息？ 如果你事先知道需要讲话，那么不管采用什么方法一定要做好调查，创建支持性论据，并把这些嵌入到脑子里，做好准备，激励他人。 以简短、个性化的抓手内容开始演讲。 选择鼓舞人心的讲话要点。 在结构体部分提供论据。 以呼吁行动结束。 在说话前稍作停顿。你可以利用停顿收集、整理自己的想法，构建智慧的答案。 不管你的角色如何，呼吁行动部分的关键在于基于要点并明确听众可相信和参与的未来。 1.不要重复否定的观点（甚至不要否定它）。 2.不要评价这个问题，只要回答它就可以。 3.不要推测。 4.不要默认错误的陈述。如果有人对你或你公司的描述有误，请礼貌地纠正，否则听众会认为它是准确的。 5.不要向提问者发问。一旦问题提出，就轮到你回应了。 6.不要否定。有些时候，有人会就你、你的公司、职业、同事或你的竞争对手提出负面的问题（“你是说你的公司还没有实现盈利吗”）。回答这种问题时不要重复其否定陈述，而要说“我们希望明年实现盈利”。 7.不要因为听众提的问题实际上不是“问题”而感到沮丧。 8.不要回答那些极端无理的问题。 为了完善即兴讲话使用的语言，记住以下“4C原则”：清晰性(clear)、口语化(conversational)、自信(confident)和协作性(collaborative)。 首先，不要被过去分心。在即兴谈话中，我们很容易停留在过去的事件上，或评判我们刚刚说过的话，而这些想法往往是消极负面的。 其次，不要顾虑未来。为即兴谈话做好准备（正如本书所要求的那样），然后守在当下，不要担心下一个事件或任务。 最后，相信自己，接纳恐惧。如果你想守在当下，那么就要相信自己。怀疑和恐惧只会削弱自己，并可能导致反应迟钝或表达不清楚。即兴剧场的表演强调相信自己、接纳错误、体验感觉来战胜恐惧。 下沉你的声音会使它更深沉、更有力、更可信。在指导领导者时，我经常会收到一些高管的请求，他们要求我指导他们的下属增强声音的力量。 正确的节奏讲话节奏应当比思维速度慢一些。当我们即兴讲话时，经常会有大量的观点、文字、想法和情绪冒出来。因此，我们经常以非常快的速度喷发出语言，说话的速度远比我们思考的速度要快，听众根本来不及吸收。 首先，在句子之间停顿。这将为我们留出一些时间准备下一个观点，它还有助于听众吸收刚才的讲话。通常句子之间的停顿大约两秒，但如果刚刚讲的是一个重要见解，那就需要给听众更多的时间来消化吸收。 其次，以放松的速度传达想法。这样我们就能够消除赘词、重复词和冗长句，就能够更成功地构建我们的想法。我们说的每句话都应该有一个清晰的观点，如果说得慢一点，就能够更有效地形成观点。所以，要慢慢地说，说话的速度和思考的速度应当一致。 最后，在领导者讲话脚本的四个部分之间停顿。这些停顿对听众来说是一种信号，表明你正从抓手移到要点、移到结构体，最后到呼吁行动。这些停顿也会让你有时间思考这些部分。 人类和其他动物一样，当我们长期拥有权力并且当下感觉到权力的时候，我们就会让自己显得很‘大’。另一方面，当我们感到无力时，恰恰相反，我们沉默不语、把自己包裹起来，让自己变‘小’。 避免以下传达负面信息的手势。·攻击性的手势（拳头、伸出的手指尖或举起的手）。·紧张的手势（搓手、把硬币碰得叮当作响或坐立不安）。• 减弱自我的手势（用手遮掩面部、遮住嘴巴或自我保护式地抓着脖子）。·梳理手势（抚摸或甩头发、触摸或抚摸自己的脸）。手势是与观众建立关系的有效方式。手势会自己说话，并告诉他人你想要与他们联结。在每一次即兴时刻，想想手势如何才能最好地为你服务。 首先，用眼睛来研究观众，无论听众是一个人还是多个人，确保你的讲话要点被接受。 其次，当你在讲每个要点的时候一定要看着观众。当然没有必要所有时间都看着对方，没有人喜欢被一直盯着看。 再次，用眼睛来“控制会场”。很多人在与多人交谈时眼睛会瞟向会场其他地方，而不是某个人。 最后，用眼睛表明你在听别人说话。我们的目光会显示我们在关注、参与、回应。所以，不管你是在走廊里一对一谈话，还是在与10个人会面，都要把注意力集中在讲话者身上，明确表示你对这个人的讲话感兴趣。这样你会被认为善于倾听，而你也确实会成为一个优秀的倾听者。 如果你想说服或激励他人，要以热情、平等和能产生共鸣的态度开始讲话。如果你看起来对大家漠不关心，那么也没有人会跟随你。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"},{"name":"工具","slug":"工具","permalink":"https://lchml.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"《翦商：殷周之变与华夏新生》","slug":"jianshang","date":"2023-09-10T16:00:00.000Z","updated":"2023-09-12T01:06:21.306Z","comments":true,"path":"book/jianshang/","link":"","permalink":"https://lchml.com/book/jianshang/","excerpt":"周公时代变革的最大结果，是神权退场，这让中国的文化过于早熟；战国时代变革的最大结果，是贵族退场，这让中国的政治过于早熟。在三千年前的古人类文明中，只有华夏独自走出了神权的掌控，成为一个“异类”。这是一种过于早熟的世俗文明，一直持续到今日。","text":"周公时代变革的最大结果，是神权退场，这让中国的文化过于早熟；战国时代变革的最大结果，是贵族退场，这让中国的政治过于早熟。在三千年前的古人类文明中，只有华夏独自走出了神权的掌控，成为一个“异类”。这是一种过于早熟的世俗文明，一直持续到今日。 本书是关于中国上古时代的文明起源的，始自新石器时代末期（4000余年前），终于商周易代（殷周革命），时间跨度一千余年。 后冈祭祀坑中的戍嗣子一家人可能也是被纣王杀戮献祭的。杀祭地点在戍嗣子的家宅或附近，操办和参加祭礼的是商朝贵族，给了死者一点宽待，但仍按照惯例烹食了很多被献祭的人，尤其是婴儿和幼儿。 “卯”是把人或牲畜对半剖开、悬挂的祭祀方式；“羌”是当时的晋陕土著人群，商王祭祀最常使用羌人。 周灭商后，人祭被周人消除，但周人并未开创一种新的宗教，而是采用世俗的人文主义立场，与极端宗教行为保持距离，不允许其干预现实生活，所谓“敬鬼神而远之”。这奠定了后世中国的文化基础。 从龙山时代、夏代（洛阳二里头古城）到商代，是华夏文明的最初阶段，可以称之为“华夏旧文明”。在周族崛起并灭商后，周公旦一代人迅速废除了人祭宗教，并抹去了与此相关的文献与记忆，进而开创了和平、宽容的“华夏新文明”，一直延续至今。 进入新石器时代，人类才有了农业和定居生活，不再像野生动物一样四处流动觅食。这是距今约一万年前开始的变化。 在千年的维度上，很多变化都是缓慢的。各种技艺的水平，如农作物种植、家畜养殖、制陶、纺织等，一直在缓慢提高着，人口或村落的总量也在缓慢增长。但这些都是量变，而非质变。 越是偏僻、交通不便的地方，小型共同体越容易维持，而缺乏天险环境中的人群更容易被裹挟进更大的共同体。 据说，商人始祖是一名叫简狄的女子，有次在野外洗澡时，她见到玄鸟产下一枚卵，就吞了下去，结果生下儿子契，繁衍出后来的商族。上古时代，常有女子未婚生育的神话，据说这是母系时代“知其母，不知其父”的特征。周族史诗也是如此，他们的女性始祖姜嫄在荒野踩到巨人脚印而怀孕，生下弃（后稷），从而繁衍出周族。 牵着牛车到远方贸易挣钱孝敬父母：“肇牵车牛，远服贾，用孝养厥父母。”（《尚书·酒诰》）商朝灭亡后，很多商族人从事的便是贸易行业，所以，在部族、王朝之名外，“商”还衍变为行业、职业之名，结果，本来代表贸易的“贾”字被“商”所取代。在早期商族的畜牧迁徙和商贸生活中，也可能有一些农业经济 商代可能是中国历史上最为奇异的一段，如果将其分成早、中、晚三期，人们最熟悉的是晚商（殷墟阶段）。殷墟发掘最早，有精致的青铜器、甲骨文和大规模杀祭场。但其实，早商的奇迹更多，它在二百年左右的时间里创造的成就，其后一千年都难以再现。那是一种几乎抵达秦汉大一统王朝的气象。 约3500年前（盘龙城文化四期），一支商人远征队出现在盘龙城繁忙的陶器码头。他们装备着锋利的青铜兵器，如矛、戈、刀、钺、弓矢等，而满身烟尘的土著却只能任由外来者安营扎寨，发号施令。南中国长江流域最早的冶铜基地和铜交易中心，就这样出现了。 商代女性贵族普遍饮酒，甚至参加战争。和台西遗址基本同时，殷墟妇好的墓葬也随葬了大量酒器和兵器，并且，甲骨文中还有妇好带领军队远征的记载。 有些骨头，特别是股骨上，有敲砸和刀砍断痕，可能是敲骨吸髓所致。约一半骨头被烧过，应是烧烤食用。发掘报告推测，当时这里应该存在食人风俗，战俘或奴隶可能会被杀死后肢解分食。 在商人的观念里，喜怒无常的诸神主宰着人世间，所以为了推动迁都，盘庚的讲话所表达的神权理念非常直白，充满着恐吓和威胁，不仅距离儒家描述的古圣先贤实在太远，也突破了后人对上古时代的想象力。 两百多年后，商朝灭亡，当周公旦提出搬迁殷都的要求时，他也将和盘庚王一样，对殷商贵族发布一番动员讲话。而殷都的诞生与毁灭，就在盘庚和周公的这两次讲话之间。 假设一位战国时代的思想家，如孟子或者荀子，亲身访问商朝，其所见所闻将会彻底颠覆那些从史书中获得的认识。现代考古学也只是揭开了真实商代的一个小角，不仅如此，如何解读考古发现甚至复原真正的商文化，却是更加困难的工作。 在商人的眼里，世界是冷酷的，充满暴力、杀戮、掠夺和不安全。他们不认为鬼神有明确的善恶观念，或者说，商人本没有明确的善恶观念，自然也不会想象鬼神能有。商人认为鬼神会随时、随意给任何人降下灾难，大到灾荒和战乱，小到生活中的各种不如意，都有鬼神在背后操纵，即便是商王也难免。 如“教”字，甲骨文写作￼：右边是攵，手拿一根棍子；左上是“爻”，一种用摆放草棍计数的方式；下面是“子”，也就是幼儿。顾名思义，用棍子督促孩子学习算数，就是教。 大约和盘庚王迁往殷都同时，在中东地区，古埃及和古赫梯两国发生了一场著名的大战——卡迭石战役，双方投入的马拉战车均超过一千辆。这次战役被古埃及文和赫梯人的楔形文字记录了下来。两相比较，商代的战车数量应该还达不到这种规模。 这种规则之下，商王需要直接管理的王朝事务比较少，其最重要的事务是组织祭祀和战争，而商人各宗族则承担提供祭祀贡品和战争兵员（自带装备）的任务。所谓：“国之大事，在祀与戎。”这正是家族分封制而非官僚帝制时代的规则。 由此，商人征服者难免和当地人互相侵染、同化，从而丢掉商人的精神内核——勇武和人祭宗教，甚至接受诡异的异族宗教。这是盘龙城发生过的教训。更不可容忍的是，南土的异族文化还向郑州都城倒流，污染商朝王室，引发了王朝内战——九世之乱。外来精神污染虽然最终被肃清，但早商的扩张成果也大半化为泡影。 甲骨文的“学”字，写作￼，上面是两手在摆放计数的草棍（爻），下面是一所房子，意为“学习算数的地方 甲骨H11:1记载，癸巳日占卜如何祭祀“文武帝乙宗”（纣王父亲帝乙的宗庙），同时占卜是否适合一起祭祀成唐（成汤，商朝开国之王，生日也是乙日），方式则是“报”祭（可能是在大鼎里煮熟）两名女子，还有猪和羊各三头，用血献祭。 但即便如此，仍有些蛛丝马迹被保留了下来，这便是文王周昌创作的《易经》。周昌一直生活在暗黑的商代，没能等到商朝灭亡便已死去，但他在《易经》里给后人留下了很多珍贵的记录，其中就包括商人的血祭仪式和周族充当人牲捕猎者的经验。 自亶父迁居周原，周人一直为商朝捕猎羌人，所以周昌在研究《易经》占算方法时，很关注预测捕俘的结果。全是捕俘技术的，是需卦。周人捕猎俘虏的经验，在需卦中有很多记载。“需”通“须”，字意是等待。这个卦主要是有关设伏和诱敌的技巧的。 《易经》里为何会有这么多周人生活的真实记录？这便涉及周昌创作《易经》的目的：研究各种事物背后的因果联系，最终建立一套翦商的理论和操作方法。 九三爻曰：“小人用壮，君子用罔。”意思是，对地位低的羌人（小人），可以打伤以后俘获（用壮），但对于部族的酋长（君子），最好用猎网捕获，以避免其受伤。这自然是因为，在商人那里，人牲的地位越高越珍贵，最好保证其无伤损。 “荐”是指杀人献祭，后世“荐俘”一词即从此来，如《逸周书·世俘》有“荐俘殷王鼎”。但观卦的内容有点奇特：这次不知何故，在“盥”的程序后，却迟迟没有开始杀俘，所谓“盥而不荐”。这应该是周昌初次参加殷都的献祭仪式，虽不懂其中的操作原理，但却在紧张等待中牢牢地记下了自己的见闻。 关于周昌在殷都的遭遇，古书记载较多，但从未提及他的儿子们。文王最年长的四个儿子分别是长子伯邑考、武王周发、周公旦、管叔周鲜。从常识推测，当周昌获准前往殷都时，因长子伯邑考要代理周族事务，周昌或许带上了另一个儿子出行；而当他被捕的消息传回周原，伯邑考和两个弟弟应该也会带着行贿的礼物赶往殷都。 关于周昌在殷都的遭遇，古书记载较多，但从未提及他的儿子们。文王最年长的四个儿子分别是长子伯邑考、武王周发、周公旦、管叔周鲜。从常识推测，当周昌获准前往殷都时，因长子伯邑考要代理周族事务，周昌或许带上了另一个儿子出行；而当他被捕的消息传回周原，伯邑考和两个弟弟应该也会带着行贿的礼物赶往殷都。 卦爻辞纷繁杂乱的现象背后，其实是周昌对世界运行规律的探索，通过卦象排列组合的变化，他发现，现有的世界秩序不是永恒的，而是可以改变的。尤为重要的是，商朝的统治也是如此。 上古时代，人们曾发明一种用草或竹子的小棍来算数的方法：把它们在地上摆放成不同的形状，用以代表不同的数字，然后进行计算，有点类似后世的算盘。用来计数的竹棍，叫“策”或“筹”，比如，流传下来的古语中就有“运筹”和“策划”等。 这种思维方式可谓石破天惊。当时的人还没有走出神权时代，普遍认为世间一切都被天界的鬼神主宰：商王家族世代向上帝和诸神献祭，从而得到天界的福佑，因此和商朝作对，就意味着违反鬼神世界的意志，不可能成功。 宜”，甲骨文字形像案板上放着切碎的肉，即剁成肉酱；￼“咸”，甲骨文字形像钺和一张嘴，表示剁肉吃。看来，这位“无敄”和“梅伯”的下场一样，被剁成肉酱吃掉了。 在甲骨文中，“史”是一个非常尊贵的字，写作￼，造型是手拿着一支笔，上面是一张嘴，象征用笔把口头指令记录下来。 在那个时代，人们制造鬼神，被鬼神主宰拨弄，但又逐渐心有不甘。这已不全然是神话时代，已经具有“文明”的一切要素，虽然这“文明”仍在血污与恐怖中挣扎。 周文化和商文化很不同，族群性格也差别很大。商人直率冲动，思维灵活跳跃，有强者的自信和麻木；周人则隐忍含蓄，对外界更加关注和警觉，总担心尚未出现的危机和忧患。这是他们作为西陲小邦的生存之道。而在阴谋翦商的十余年里，这种个性更是表现得无以复加。 连比干怀孕的妻子也难逃一死，甚至腹中胎儿还被扯出来让纣王检视：“纣剖比干妻以视其胎。” 可以说，这场战斗从一开始，武王一方就没有任何章法和战术可言。但商军阵列却突然自行解体，变成了互相砍杀的人群。或许是看到周军义无反顾的冲锋，商军中的密谋者终于鼓起勇气，倒戈杀向纣王中军。接着，西土联军全部投入了混战。 当淡淡的阳光穿透晨雾洒向原野间的纵横尸骸，近六百年的商王朝已经终结。太公则在那个黎明变成一只鹰盘旋在牧野上空，而积云散去的清晨，自此被周人称作“清明”。 伴随着周人大分封运动的，是广泛而持续的民族融合。由此，新的华夏族逐渐成形。这和周人传统的“同姓不婚”（族外婚）习俗有直接关系。周人的“姓”是区别种族血缘的概念， 就这样，随着统治阶层的繁衍，周朝特色的贵族制度逐渐得以形成，其中，最首要的是“宗法”家族制，核心则是嫡长子一系的独尊地位。 周公的“改制”恭敬地解除了上帝和诸神对世间的掌控，把他们奉送到距离尘世极为遥远的彼岸世界。诸神远行似乎也带走了一切奇伟莫测，留给人间的只有平庸的平和，以及残留着种种传说的巨大废墟。不过，诸神及其神迹并未消失，只是它们不再返回东亚，而在此后的美洲大陆上，玛雅和阿兹特克等文明将相继繁荣，且伴随着盛大的人祭仪式以及精美的图画文字、石雕和巍峨的金字塔神庙。 此外，商人还探索了古中国的诸多地域，甚至研究过人骨的各种利用方式，但随着商朝覆亡，这种探索精神和技术狂热也消失了，或者沦为被上层社会漠视的末流小技，在其后的三千年里一直未能复兴。即便作为商王室传人的宋国，也未能保留这些特质。 商文明很复杂，有着残酷、奔放、奇幻和科技理性等诸多层面，以及那些我们已经无法认知的部分。只是早在三千年前，它们就已经被彻底忘却。 从孕育到成熟，华夏旧文明跨越两千年。和同期的其他古代人类文明一样，它们都属于神权与王权合一、宗教主导的社会。如果一直延续下去，历史将充斥族群壁垒、杀戮与献祭。 在三千年前的古人类文明中，只有华夏独自走出了神权的掌控，成为一个“异类”。这是一种过于早熟的世俗文明，一直持续到今日。 孔子和儒家最推崇周公，而周公思想是儒家文化的源头。周公思想的产生和形成，主要源于对人祭宗教的恐惧，以及消灭人祭宗教的需要。这是后人从未堪破的秘密。 周公在事实上扭转了历史进程，改变了人们的认知；孔子则把这一切文本成果汇总起来，形成盖棺定论的“六经”经典，传递给后世：华夏文明的源头就是如此，再无其他。 概而言之，周公时代变革的最大结果，是神权退场，这让中国的文化过于“早熟”；战国时代变革的最大结果，是贵族退场，这让中国的政治过于“早熟”。而在其他诸人类文明中，神权和贵族政治的退场，都发生在公元1500年之后的所谓近现代时期。 进入人祭的领域后，我最关注的，其实是哪些古人群没有人祭遗存，或者比较少。我宁愿相信陶寺和二里头古国的人祭都不太多，也认为商朝中期还曾发生过一场反人祭的上层宗教改革。证据也许还不算多，但总应该有那么一点东西，让人维持哪怕微茫的希望。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"考古","slug":"考古","permalink":"https://lchml.com/tags/%E8%80%83%E5%8F%A4/"}]},{"title":"《李鸿章传》","slug":"lhzz","date":"2023-06-18T16:00:00.000Z","updated":"2023-06-19T10:14:19.750Z","comments":true,"path":"book/lhzz/","link":"","permalink":"https://lchml.com/book/lhzz/","excerpt":"天下唯庸人无咎无誉","text":"天下唯庸人无咎无誉 读后感从中学历史书中臭名昭著的李鸿章，到走向共和中公忠体国、鞠躬尽瘁的李鸿章，中国近代的百年国殇正是始于李鸿章。正如开头所说：天下唯庸人无咎无誉。李鸿忠至于清政府无愧于文忠之谥，师承于曾国藩，带领淮军剿捻，到打败李秀成，再到洋务运动，再到主掌外交。一辈子都都在为清政府糊住那注定要破的窗。他是时势所造之英雄，非造时势之英雄。大家骂他卖国，相信非他所愿，大家骂他不改革政体，振兴国家，相信非他所能。所以任公说：李固可责，而彼辈又岂能责李之人哉？只怪200多年的清政府统治已使天下之大，竟无一真英雄豪杰。 摘抄史家之论霍光，惜其不学无术。吾以为李鸿章所以不能为非常之英雄者，亦坐此四字而已。李鸿章不识国民之原理，不通世界之大势，不知政治之本原，当此十九世纪竞争进化之世，而惟弥缝补苴，偷一时之安，不务扩养国民实力，置其国于威德完盛之域，而仅摭拾泰西皮毛，汲流忘源，遂乃自足。更挟小智小术，欲与地球著名之大政治家相角，让其大者，而争其小者，非不尽瘁，庸有济乎？ 吾故曰：敬李之才，惜李之识，而悲李之遇也。但此后有袭李而起者乎？其时势既已一变，则其所以为英雄者亦自一变，其勿复以吾之所以恕李者而自恕也。 然亦贵族柄权之风未衰，故非贵族者不敢有异志也。斯为权臣之第一种类。及董卓以后，豪杰蜂起，曹操乘之以窃大位，以武功而为权臣者自操始。此后司马懿、桓温、刘裕、萧衍、陈霸先、高欢、字文泰之徒，皆循斯轨。斯为权臣之第二种类。又如秦之商鞅，汉之霍光、诸葛亮，宋之王安石，明之张居正等，皆起于布衣，无所凭藉，而以才学结主知，委政受成，得行其志，举国听命，权倾一时，庶几有近世立宪国大臣之位置焉。此为权臣之第三种类。其下者则巧言令色，献媚人主，窃弄国柄，荼毒生民，如秦之赵高，汉之十常侍，唐之卢杞、李林甫，宋之蔡京、秦桧、韩侂胄，明之刘瑾、魏忠贤，穿窬斗筲，无足比数。此为权臣之第四种类。以上四者，中国数千年所称权臣，略尽于是矣。 李鸿章之地位，比诸汉之霍光曹操、明之张居正，与夫近世欧洲日本所谓立宪君主国之大臣，有迥不相侔者，势使然也。 即使李鸿章果有实权，尽行其志，吾知其所成就亦决无以远过于今日。何也？以鸿章固无学识之人也。且使李鸿章而真为豪杰，则凭藉彼所固有之地位，亦安在不能继长增高，广植势力，以期实行其政策于天下。 自古大伟人，其进退出处之间，天亦若有以靳之，必待机会已熟，持满而发，莫或使之，若或使之。谢康乐有言：诸公生天虽在灵运先，成佛必居灵运后。 其后屡与敌战，常能以少击众，所向披靡，故官军敌军，皆号之曰“常胜军”。常胜军之立，实在李鸿章未到上海以前也。 故争兵要则莫如武汉，争饷源则莫如苏杭 先是八酋之降也，戈登实为保人。至是闻鸿章之食言也，大怒，欲杀鸿章以偿其罪，自携短铳以觅之。鸿章避之，不敢归营。数日后，怒渐解，乃止。 鸿章随曾军数年，砥砺道义，练习兵机，盖其一生立身行己耐劳任怨坚忍不拔之精神，与其治军驭将推诚布公团结士气之方略，无一不自国藩得之。故有曾国藩然后有李鸿章。其事之如父母，敬之如神明，不亦宜乎 至其所以失败之故，由于群议之掣肘者半，由于鸿章之自取者亦半。其自取也，由于用人失当者半，由于见识不明者亦半。彼其当大功既立功名鼎盛之时，自视甚高，觉天下事易易耳；又其裨将故吏，昔共患难，今共功名，徇其私情，转相汲引，布满要津，委以重任，不暇问其才之可用与否，以故临机偾事，贻误大局，此其一因也。又惟知练兵，而不知有兵之本原；惟知筹饷，而不知有饷之本原，故支支节节，终无所成，此又其一因也。 李鸿章所办商务，亦无一成效可睹者，无他，官督商办一语，累之而已。中国人最长于商，若天授焉，但使国家为之制定商法，广通道路，保护利权，自能使地无弃财，人无弃力，国之富可立而待也。今每举一商务，辄为之奏请焉，为之派大臣督办焉，即使所用得人，而代大匠斵者，固未有不伤其手矣。况乃奸吏舞文，视为利薮；凭挟狐威，把持局务，其已入股者安得不寒心，其未来者安得不裹足耶？ 吾敢以一言武断之曰：李鸿章实不知国务之人也，不知国家之为何物，不知国家与政府有若何之关系，不知政府与人民有若何之权限，不知大臣当尽之责任。其于西国所以富强之原，茫乎未有闻焉，以为吾中国之政教文物风俗，无一不优于他国，所不及者惟枪耳、炮耳、船耳、铁路耳、机器耳，吾但学此，而洋务之能事毕矣。此近日举国谈时务者所异口同声，而李鸿章实此一派中三十年前之先辈也。是所谓无盐效西子之颦，邯郸学寿陵之步，其适形其丑，终无所得也，固宜。 吾于中日之役，固一毫不能为李淮恕也，然特患夫虚骄嚣张之徒，毫无责任，而立于他人之背后，摭其短长以为快谈，而迄未尝思所以易彼之道，盖此辈实亡国之利器也。李固可责，而彼辈又岂能责李之人哉？ 故义和团实政府与民间之合体也，而其所向之鹄各异：民间全出于公，愚而无谋，君子怜之；政府全出于私，悖而不道，普天嫉之。 当是时，为李鸿章计者曰，拥两广自立，为亚细亚洲开一新政体，上也；督兵北上，勤王剿拳，以谢万国，中也；受命入京，投身虎口，行将为顽固党所甘心，下也。 以光绪二十七年（1901）九月廿七日薨于京师之贤良寺。闻薨之前一点钟，俄使尚来促画押云。卒之此约未定，今以付诸庆亲王、王文韶。临终未尝口及家事，惟切齿曰：“可恨毓贤误国至此！”既而又长吁曰：“两宫不肯回銮。”遂瞑焉长逝，享年七十八岁。 太息斯人去，萧条徐泗空，莽莽长淮，起陆龙蛇安在也；回首山河非，只有夕阳好，哀哀浩劫，归辽神鹤竟何之。 人各有所难，非胜其难，则不足为英雄。 李鸿章女婿张佩纶，也是近代才女张爱玲的祖父","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"传记","slug":"传记","permalink":"https://lchml.com/tags/%E4%BC%A0%E8%AE%B0/"}]},{"title":"《革命与征服中的阿拉伯人：1516年至今》","slug":"gmyzfzdalbr","date":"2023-04-24T16:00:00.000Z","updated":"2023-04-27T03:16:30.878Z","comments":true,"path":"book/gmyzfzdalbr/","link":"","permalink":"https://lchml.com/book/gmyzfzdalbr/","excerpt":"这本书可能是我近年来阅读耗时最长的书，从去年底到现在，陆陆续续读了4个多月。书中人物名字冗长，历史事件纷杂，再加上对列强殖民的情绪，看起来确实不轻松。但是对穆斯林社会的认识，会让我的思维和观念时常受到强烈冲击，这是看书能得到的最宝贵的财富之一。 历史是理解世界任何地方的必要起点，中东作为当今世界动乱最多，冲突最激烈，势力最复杂的地区，伊斯兰文明也是中华文明、西方文明以外当今最为重要文明之一，了解其背后的历史和原因，我认为是有意义有价值的。在中东这500年的历史中，有很多我们作为局外人无法理解的地方，也有很多与中国2000多年来极其相似的历史，会愤怒列强的霸道，会愤怒宗教的暴力，会同情平民的悲惨。从中国历史的角度来看，阿拉伯人想要重现历史的辉煌，还有着漫漫长路。","text":"这本书可能是我近年来阅读耗时最长的书，从去年底到现在，陆陆续续读了4个多月。书中人物名字冗长，历史事件纷杂，再加上对列强殖民的情绪，看起来确实不轻松。但是对穆斯林社会的认识，会让我的思维和观念时常受到强烈冲击，这是看书能得到的最宝贵的财富之一。 历史是理解世界任何地方的必要起点，中东作为当今世界动乱最多，冲突最激烈，势力最复杂的地区，伊斯兰文明也是中华文明、西方文明以外当今最为重要文明之一，了解其背后的历史和原因，我认为是有意义有价值的。在中东这500年的历史中，有很多我们作为局外人无法理解的地方，也有很多与中国2000多年来极其相似的历史，会愤怒列强的霸道，会愤怒宗教的暴力，会同情平民的悲惨。从中国历史的角度来看，阿拉伯人想要重现历史的辉煌，还有着漫漫长路。 以下是全书的简要内容 序言哈姆迪是小城西迪布济德的市政巡视员，她被指控侮辱了一名街头小贩，后者的自焚在突尼斯激起全国范围的示威游行，并最终引发北非和中东地区的一系列群众性运动，统称“阿拉伯之春”。 她释放后，回到西迪布济德，继续供职于市政部门，但她不再巡视市场。她换下制服和贝雷帽，换上平民服装，包上伊斯兰头巾。她的新装束体现了一个从军事威权主义转向伊斯兰民主实验的阿拉伯世界。￼ 对于他们的历史，特别是伊斯兰教产生后5个世纪，也即公元7—12世纪的历史，阿拉伯人极为自豪。这是伊斯兰帝国的黄金时代，基于大马士革、巴格达、开罗和科尔多瓦的诸帝国主导了世界事务。可以说，在伊斯兰兴起之初的几个世纪，阿拉伯人被界定为一个在阿拉伯半岛各部落之间共享一种语言（阿拉伯语）的民族，其中大多数人共同信仰逊尼派伊斯兰教。 11世纪末起，外来入侵者糟蹋了伊斯兰的土地。1099年，在血腥围困之后，十字军占领耶路撒冷，开启了十字军王国长达两个世纪的外族统治。1258年，蒙古人洗劫阿拔斯哈里发的首都巴格达，当地居民的鲜血染红了底格里斯河。1492年，天主教收复失地运动（Catholic Reconquista）逐走了伊比利亚半岛最后的穆斯林。 1453年，征服者穆罕默德（Mehmed the Conqueror）占领拜占庭首都君士坦丁堡，将该城更名为伊斯坦布尔，自此开始从那里统治他们日益壮大的奥斯曼帝国。过去的5个世纪内，奥斯曼人统治了阿拉伯人4个世纪。 征服后的第一个世纪，奥斯曼人的统治并不太苛刻：阿拉伯人必须承认素丹的权威，遵守他的法律和真主的法律（sharia, “沙里亚”，即伊斯兰法）。 到19世纪，奥斯曼人开启了一个重大改革阶段，旨在平息帝国内部的挑战，遏制欧洲邻国的威胁。 1918年一战后奥斯曼帝国覆灭，对许多阿拉伯世界的人来说，这是开启独立与民族荣耀新纪元的分水岭。 英、法利用1919年的巴黎和会将现代国家体系施于阿拉伯世界，除了阿拉伯半岛中南部，所有阿拉伯地区都陷入了某种殖民统治。 莫斯科和华盛顿为争夺全球统治权而进行激烈竞争。美国和苏联都试图将阿拉伯世界纳入他们各自的势力范围，中东由此成为超级大国对抗的几个竞技场之一。 美国主导的单边主义时代的规则，被证明是自现代以来对阿拉伯世界最为不利的。没有其他强国来限制美国的权力，阿拉伯各国政府发现他们正面临切切实实的入侵和政权更迭的威胁。 1789年法国大革命，一个新的政治秩序产生了：法律限制了统治者的权力，臣民获得了具有更高法律地位的公民地位。 阿拉伯世界在过去5个世纪所经历的种种，与全球其他人所经历的相同。民族主义、帝国主义、革命、工业化、城乡移民、为妇女权益而斗争，所有这些人类现代历史的宏大主题都在阿拉伯世界得到呈现。 第一章，从开罗到伊斯坦布尔自1250年建立王朝以来，马木鲁克人一直统治着这个当时最古老、最强盛的伊斯兰国家。这个以开罗为首都的帝国，覆盖了埃及、叙利亚和阿拉伯半岛。 奥斯曼帝国源自13世纪同基督教拜占庭帝国进行“圣战”的一个突厥穆斯林小王国，地处安纳托利亚（现代土耳其的亚洲领土）。14—15世纪，奥斯曼人兼并了其他突厥王国，征服了拜占庭帝国在安纳托利亚和巴尔干的领土。1453年，奥斯曼帝国第七任素丹穆罕默德二世（Mehmed Ⅱ）成功攻占君士坦丁堡，完成对拜占庭帝国的征服，这是之前所有穆斯林政权都未曾做到过的。在此之后，穆罕默德二世将以“征服者”闻名于世。君士坦丁堡更名为伊斯坦布尔，成为奥斯曼帝国的首都。 随着马木鲁克王朝的覆灭，塞利姆完成了对马木鲁克帝国的征服，并将他们所有的财富、土地和荣耀都转到了他自己的王朝。在将叙利亚、埃及和阿拉伯半岛的希贾兹省纳入奥斯曼帝国之后，他现在可以荣归伊斯坦布尔了。希贾兹作为伊斯兰教的诞生地，意义非凡。穆斯林相信，正是在这里，在麦加城，真主第一次向先知穆罕默德降示《古兰经》，而正是在临近的麦地那，先知建立了第一个穆斯林社团。 奥斯曼人征服马木鲁克帝国是阿拉伯历史上的一个重大转折点。马木鲁克剑士和奥斯曼枪手之间致命的兵器冲突标志着阿拉伯世界中世纪的结束和现代的开始。奥斯曼人的征服还意味着，自伊斯兰教兴起以来，阿拉伯世界第一次被一个非阿拉伯国家的首都统治。公元661—750年间，伍麦叶王朝，伊斯兰教的第一个王朝，在大马士革统治着他们快速扩张的帝国。750—1258年，阿拔斯王朝哈里发在巴格达统治着当时最伟大的穆斯林帝国。建于969年的开罗，在1250年马木鲁克王朝兴起之前，曾是至少四个王朝的首都。从1517年起，阿拉伯人将通过外国首都制定的规则来商议他们的国际地位，这一政治现实将被证明是现代阿拉伯历史的一个决定性特征。 若阿拉伯人有更为宽泛的身份认同，则更有可能基于宗教而不是种族。大多数阿拉伯人是逊尼派穆斯林，对他们来说，奥斯曼人是完全可以接受的统治者。对当时的人们而言，行政中心从阿拉伯世界迁至横跨欧洲和亚洲大陆的伊斯坦布尔，似乎并不成问题。 （穆斯林中百分之八九十都是逊尼派，第二多的是什叶派，只有伊朗是以什叶派为主的穆斯林国家。两派的主要区别是对于穆罕默德合法继承人的认定不同，什叶派认为只有阿里是合法继承人，逊尼派则认为四大哈里发以及后续王朝的哈里发都是合法继承人。 在征服马木鲁克帝国后的头几年里，奥斯曼人基本上保全了前朝的机构，让马木鲁克埃米尔（或称“长官”）掌管。他们以阿勒颇、大马士革和开罗三大城市为中心，将前马木鲁克的领土划分为三个行省。 16世纪奥斯曼帝国的地方统治是一种封建主义形式，中央政府将土地授予军事指挥官们。获得该职位的人负责监督司法的运转，并从他的土地上征税。他用他的土地收益供养一定数量的骑兵，并向中央财政缴纳一笔固定数额的税款。与欧洲的封建主义不同，奥斯曼制度不是世袭的，因此没有产生一个与素丹的权力相抗衡的贵族阶层。这一制度非常适合迅速扩张的帝国，因为开疆拓土的速度超过了国家培养训练有素的官员来管理领土的能力。 然而，在当时，这是在一个流动性相当有限的社会中向上流动的唯一手段。通过男孩征募，农民的儿子可以成为将军或大维齐尔。事实上，奥斯曼军队和政府的精英队伍基本上只在征募的男孩中选录。大多数阿拉伯人是自由出生的穆斯林，他们被排除在这种征募之外，这意味着他们在奥斯曼帝国早期的权力精英中的代表性严重不足。 司法是除总督和军队之外，奥斯曼统治体系的第三个要素。 苏莱曼二世被证明是奥斯曼帝国最成功的统治者之一。在长达46年（1520—1566）的统治期间，他完成了他父亲开启的对阿拉伯世界的征服。1533—1538年，他从波斯萨法维帝国手中夺取了巴格达和巴士拉。那里的逊尼派民众遭受了什叶派萨法维人的多年迫害，他们视奥斯曼军队为解放者。对伊拉克的征服在战略和意识形态上都有重要意义。苏莱曼二世巩固了他的帝国，将古老的阿拉伯首都巴格达纳入麾下，并阻止了什叶派教义向逊尼派地区的扩张。 16世纪30—40年代，苏莱曼二世的部队从埃及向南推进，占领了阿拉伯半岛南部的也门地区。1525—1574年，在西地中海地区，苏莱曼将利比亚、突尼斯和阿尔及利亚等北非沿海地区以朝贡附属国的形式纳入奥斯曼帝国势力范围。到16世纪末，除了一直处于奥斯曼帝国势力范围之外的阿拉伯半岛中部和摩洛哥素丹国，阿拉伯世界的其余地区都在帝国某种形式的控制之下。 海伊尔丁（Khayr al-Din）也是如此。他是奥斯曼历史上最伟大的海军上将之一，因红胡子而被同时代的欧洲人称为“巴巴罗萨”（Barbarossa）。 16世纪初，西地中海是基督教和穆斯林军队之间激烈冲突的战场。1492年，格拉纳达沦陷，西班牙完成对伊比利亚半岛的征服，结束了穆斯林对西班牙近8个世纪的统治（711—1492）。 西班牙的君主，卡斯蒂利亚的伊莎贝拉（Isabella of Castile）和阿拉贡的费迪南德（Ferdinand of Aragon），无情地将“圣战”推向地中海对岸、摩里斯科人藏身的各穆斯林王国。从摩洛哥到利比亚，他们沿着北非海岸线建立了一系列堡垒殖民地，或称“要塞”，并迫使内陆城镇的地方首领向西班牙纳贡。其中两处殖民地，摩洛哥海岸线上的休达和梅利利亚至今仍是西班牙的属地。 奥斯曼帝国和西班牙在西地中海的争夺结束后很久，奥斯曼中央政府依然非常满意阿尔及尔的德伊们代其统治北非沿海地区。巴巴里海盗控制的沿海地区因距离伊斯坦布尔太远而无法被直接管理，也因人口稀少而无法负担更为复杂的治理体系的开销，因此，该地区成为奥斯曼人选择与当地精英合作统治的阿拉伯行省中的典型。这使得奥斯曼帝国能够在帝国国库几无损失的情况下，对具有战略价值的穆斯林地区宣示主权，并获得少量收入。 1629年，奥斯曼人和波斯人之间的战争结束，伊斯坦布尔再次将注意力转向黎巴嫩山叛逆的德鲁兹王，此时他已将他控制下的疆域向东延伸入叙利亚沙漠，向北延伸到安纳托利亚。1631年，法赫尔丁做出了一次傲慢的举动，拒绝一支奥斯曼军队在“他的”领土上过冬。从那时起，奥斯曼人下定决心要除去这名不顺从的封臣。 法赫尔丁和他的儿子们被抓获，并被带到伊斯坦布尔，于1635年处决。这终结了一份非凡的事业，也消除了阿拉伯世界对奥斯曼统治的重大威胁。 黎巴嫩的封建秩序将一直持续到19世纪，其间没有再给伊斯坦布尔带来麻烦。 多年的派系斗争使法卡里派和卡西米派都无力维持在开罗的领导地位。这两个敌对的派别被一个叫作卡兹杜厄里（Qazdughli）的马木鲁克家族推翻，在18世纪余下的时间内，该家族一直掌控奥斯曼埃及。 就奥斯曼人而言，他们从未全面掌控富裕但不守规矩的埃及行省。奥斯曼埃及形成了一种独特的政治文化，直到“冷酷者”塞利姆征服马木鲁克埃及数个世纪后，各马木鲁克家族依然拥有比伊斯坦布尔任命的总督更大的政治权力。在埃及，就像在黎巴嫩和阿尔及利亚一样，奥斯曼的统治适应了当地政治。 在征服马木鲁克帝国两个世纪之后，奥斯曼人成功地将他们的帝国从北非扩展到了阿拉伯半岛南部。整个过程并不是一帆风顺的。在许多情况下，奥斯曼人不愿或无法在各阿拉伯行省建立标准化的政府，而选择与本地精英合作统治。各阿拉伯行省同伊斯坦布尔的关系可能差异很大，各省的行政架构也千差万别，但它们毫无疑问都是同一个帝国的组成部分。这种多样性对当时多民族和多教派的帝国来说是很常见的，奥匈帝国和俄罗斯帝国也是如此。18世纪中叶前，奥斯曼人对这一多样性的掌控多多少少是成功的。他们面临过挑战，特别是来自黎巴嫩山和埃及的挑战，但他们使用多种策略，成功地确立了奥斯曼帝国的统治，并确保没有任何地方领袖对帝国的中心地位构成持久威胁。然而，18世纪后半叶，该中心与处于边缘地位的阿拉伯世界之间的动态关系发生了变化。新的地方领袖崛起，他们开始整合军力，寻求自治，公然违抗奥斯曼帝国的制度。他们往往同帝国在欧洲的敌对势力合作。这些新兴的地方领袖对奥斯曼政权构成了实质性挑战，将在19世纪危及帝国的生存。 （奥斯曼帝国的统治体系可分两种结构，一种是伊斯坦布尔的中央政府集权制，相对较近的领土。一种是和当地精英达成协议自治，相对较远的领土，如阿尔及尔，黎巴嫩山，埃及等。 第二章，阿拉伯人挑战奥斯曼统治根据奥斯曼人的治国理念，好的统治是四个相互依赖的要素之间的微妙平衡，这一平衡可被理解为一个“公正的循环”（circle of equity）。首先，国家需要一支庞大的军队来行使其权力。维持一支庞大的军队需要巨大的财富，而税收是国家唯一的常规财富来源。为了征税，国家必须促进国民生活的繁荣。为了国民生活的繁荣，国家必须维护法律的公正，这就回到了国家的责任上来，从而完成了一个完整的循环 在阿拉伯世界，地方领袖崛起，伊斯坦布尔的影响下降，因为更多的税收被用于地方军队和地方长官的建设工程。这一现象在许多阿拉伯行省蔓延，从而带来一种累积效应，对奥斯曼帝国的领土完整构成越来越大的威胁。因为在18世纪下半叶，地方领袖的快速壮大使得多个阿拉伯行省开始反抗伊斯坦布尔的统治。 相较于巴尔干半岛和安纳托利亚，奥斯曼人更少依靠各阿拉伯行省的收入和军队。此外，阿拉伯世界离伊斯坦布尔更远，中央政府不愿动用军队和资源镇压小规模叛乱。伊斯坦布尔更关心的是来自维也纳和莫斯科的挑战，而不是大马士革和开罗的地方领袖带来的麻烦。 帝国的中央政府面临一个两难处境，只有确保帝国的欧洲边境足够稳定，才能腾出必要的资源来应对各阿拉伯行省的挑战。 （这也是军事征服帝国的通病，一旦对外征服失利，停止，内部矛盾就会很快激化。 阿拉伯世界对奥斯曼统治的下一个真正挑战出现在帝国边界之外阿拉伯半岛的中部。 与扎希尔·欧麦尔和阿里贝伊不同，这场运动的领袖的独特之处在于，他在如今的中东和西方仍是一个家喻户晓的人物，他就是瓦哈比改革运动的创始人穆罕默德·本·阿卜杜·瓦哈卜（Muhammad ibn‘Abd al-Wahhab）。 他接受了伊斯兰教四大教法传统中最保守的罕百里学派的训练，并深受14世纪神学家伊本·泰米叶（Ibn Taymiyya）的影响。伊本·泰米叶主张恢复先知和他最初的继任者们（即哈里发）时期的穆斯林社团。他谴责一切与苏非主义有关的神秘主义做法，认为这些做法偏离了伊斯兰教的正道。 （一）马立克学派（二）沙斐尔学派（三）罕百里学派（四）哈乃斐学派 在阿拉伯世界，圣人崇拜很普遍，从先知穆罕默德的门徒到身份更低的本地村庄的圣人，都有自己的圣墓或圣树。（这些圣地至今仍在阿拉伯世界的许多地方得到保存和维护。）瓦哈比派反对穆斯林向圣人祈祷以代替他们向真主说情，因为这损害了真主的独一性。他们认为，向杰出的穆斯林表达敬意，应该以他们为楷模行事而不应敬拜他们的坟墓。 第三章，穆罕默德·阿里的埃及帝国穆罕默德·阿里（1770—1849）是阿尔巴尼亚人，生于马其顿的卡瓦拉，在埃及的奥斯曼军队里统领一支由6000人组成的强大而桀骜难驯的阿尔巴尼亚分遣队 到统治结束时，穆罕默德·阿里已经成功确立了他的家族对埃及和苏丹的世袭统治。他的王朝将统治埃及直到1952年革命推翻君主制。 将苏丹纳入埃及帝国后，穆罕默德·阿里将他控制的土地面积扩大了一倍，并控制了红海贸易。埃及对苏丹的霸权将持续136年，直到1956年苏丹重获独立。 穆罕默德·阿里没有实现他所渴望的独立。奥斯曼帝国把他牢牢地束缚在帝国的统治之下。但是他已经把奥斯曼帝国的大部分阿拉伯行省都置于他的家族统治之下，建立了一个埃及帝国，在19世纪30年代余下的时间里与奥斯曼帝国相抗衡。 从1805年到1841年，穆罕默德·阿里的雄心壮志经历了一个循环。他升为总督，成为埃及的主人。一旦他在埃及站稳了脚跟并增加了财政收入，他就开始建设现代军队。随后，他将自己的领土范围从苏丹和红海沿岸的希贾兹一度扩大到包括希腊的大部分地区和整个叙利亚。但外部干涉剥夺了他的战果，到1841年，他的势力范围又缩回到埃及和苏丹。埃及将拥有自己的政府，将制定自己的法律，但仍将受奥斯曼帝国外交政策的约束。虽然埃及人可以铸造自己的钱币，但他们的金币和银币上都须印有素丹的名字，而埃及统治者的名字则只能印在价值低廉的铜币上。埃及可以拥有自己的军队，但士兵人数不能超过1.8万人，这与埃及之前部署的10万至20万人的庞大军队相去甚远。穆罕默德·阿里取得了很大的成就，但他曾经的雄心更大。 奥斯曼帝国与欧洲邻国的关系正进入一个复杂的新时代。欧洲将成为榜样，成为军事和技术领域的典范。但欧洲也是一个威胁，既是觊觎奥斯曼帝国领土的好战者，也是危险的新意识形态的源头，因此必须与之保持距离。奥斯曼改革者面临如下挑战：如何在不损害自身文化完整性和价值观的情况下采纳欧洲的理念和技术。 第四章，改革的危险塔赫塔维对法国的反思充满了矛盾。作为一名穆斯林和埃及奥斯曼人，他对自己的信仰和文化的优越性充满信心。他认为法国是一个没有信仰的地方，那里“没有一个穆斯林定居”，而法国人自己则是“名义上的基督教徒”。然而，他的亲眼观察丝毫没让他怀疑欧洲在科学和技术方面的优越性。他回忆道：“法国拥有伊斯兰诸王国所缺乏的一切，说真的，在[法国]居住期间，我为此感到悲哀。” 19世纪期间，奥斯曼人及其阿拉伯公民与欧洲的互动日益增多，迫使中东人民认识到，在军事和经济实力上，欧洲已经超过了他们。尽管大多数奥斯曼人仍然相信他们所处的世界在文化上更为优越，但他们的改革者认为，有必要掌握欧洲的思想和技术，否则，欧洲就会掌控他们。 改革进程早已因其欧化的倾向而引起争议。但1856年法令颁布之前的各项改革都没有直接违背《古兰经》。穆斯林视《古兰经》为真主的原话，也是真主永恒的话语。违背《古兰经》就是违背真主，因此，毫不奇怪，在帝国的城市里宣读1856年法令激起了虔诚穆斯林的愤怒。 颁布1856年改革法令和确立不同信仰的奥斯曼公民间平等的法律地位，已经让穆斯林和基督徒之间的关系异常紧张。多位大马士革编年史家都注意到了基督徒获得法律权利后的变化。基督徒不再承认穆斯林一贯享有的特权，穿着的服饰开始使用一些先前只有穆斯林才能用的颜色。他们也变得越来越坚定自信。一位愤怒的穆斯林要人写道：“当基督徒与穆斯林发生争吵时，无论后者如何辱骂他，他都会以同样的甚至更多的脏话回骂。”大马士革的穆斯林认为，这样的行为是不可容忍的。 大马士革的基督徒公然藐视古老的惯例，无意间加剧了教派间的紧张关系，最终招致灭顶之灾。 米舍卡在事后提交给美国驻贝鲁特领事的报告中详细列举了屠杀造成的人员和财物损失。他声称，至少有5000名基督徒在暴力事件中丧生，占原先2万人基督徒社群的四分之一。约有400名妇女被绑架和强奸，许多妇女因此怀孕，其中包括米舍卡家里的一名佣人。财物损失十分严重。超过1500所房屋被夷为平地，基督徒拥有的商店全都被洗劫，基督徒区约200家商店付之一炬。教堂、学校和修道院被劫掠并破坏。基督徒区因偷窃、故意破坏和纵火而遭到大面积毁坏，这是这座城市近代史上前所未有的教派冲突。 奥斯曼政府在穆斯林和非穆斯林公民之间确立法律上的平等，主要是为了防止欧洲列强干涉其内政。但随后在黎巴嫩山和大马士革发生的针对基督徒的暴力事件，有可能招致欧洲大规模的干涉。 奥斯曼官员预想了欧洲列强可能提出的每一项不满，并在欧洲人有机会干涉之前就采取行动。奥斯曼帝国安然度过了这场危机，他们的主权完好无损。 当废奴运动和英国政府联合起来向奥斯曼帝国施压，要求废除奴隶制时，帝国政府表示反对。《古兰经》的经文鼓励奴隶主善待奴隶，允许他们结婚，并赋予他们自由身，但没有提及废除奴隶制。素丹怎么能宣布真主之书所允许的事非法呢？ 1856年萨义德给予他前导师法国人费迪南·德·莱塞普（Ferdinand de Lesseps）的特许权是其他项目无法匹敌的：修建一条连通地中海和红海的水上通道，即苏伊士运河。这是19世纪埃及最大的发展项目，也是对国库的最大消耗。 不计后果的政府开支让奥斯曼帝国和北非各地的改革者们忧心忡忡。欧洲技术的引进带来与预期相反的结果。发展非但没有使这些国家强大和独立，反而让中东地区的各政府变得贫穷和弱小，更易遭到欧洲的干涉。 埃及是最后一个宣布破产的中东国家，时间是1876年。埃及的状况同奥斯曼帝国惊人地相似。1876—1880年，埃及的财政由来自英国、法国、意大利、奥地利和俄国的专家负责，他们的首要关切是外国债券持有人的利益。同伊斯坦布尔一样，一个正式委员会成立了。一项项不切实际的方案接踵而来，给埃及纳税人带来了沉重的负担。在每一项方案中，外国经济顾问都设法更深入地参与埃及的财政管理。 随着突尼斯、伊斯坦布尔和开罗的破产，中东的改革进程兜了一圈后又回到了原点。改革运动的初衷是加强奥斯曼帝国及其属国，防止外部干涉，结果却让欧洲进一步掌控中东各国。随着时间的推移，非正式的帝国主义控制发展成直接的殖民统治，整个北非被日益强大的欧洲各帝国瓜分。 第五章 第一波殖民主义：北非欧洲技术的传播和让资金短缺的中东各国政府超越自身财力、过度开支的金融安排，扩大了欧洲在奥斯曼帝国各地——从北非到阿拉伯半岛的影响力。奥斯曼帝国及其北非自治行省的破产，为欧洲实行更为直接的控制扫清了阻力。 欧洲在北非的利益不断扩大，相应地，它们也更有动力开展彻底的帝国统治。到19世纪80年代，欧洲列强更加关心维护它们在南地中海的国家利益，而不是保持奥斯曼帝国的领土完整。1840年的所谓“自我否定协定”不过是一纸空文，瓜分北非的大幕随即拉开。1881年，法国将突尼斯纳入统治范围。1882年，英国占领埃及。1911年，意大利占据利比亚。1912年，欧洲列强同意摩洛哥（唯一一个一直独立于奥斯曼帝国统治的北非国家）成为法国和西班牙的被保护国。第一次世界大战爆发前，欧洲直接统治了整个北非。 1840—1881年，欧洲和奥斯曼帝国都发生了很大的变化，民族主义这个源自欧洲的新思想开始深入人心。民族主义是18世纪欧洲启蒙运动的产物，19世纪期间以不同的程度在欧洲传播。希腊是一个早期的皈依者，在经历了10年的战争之后，于1830年从奥斯曼帝国独立。其他欧洲国家，如德国和意大利，在民族主义的感召下，经过几十年的统一运动逐渐形成国家形态，到19世纪70年代初才以现代国家的形式出现在国际社会中。奥匈帝国内部也开始面临日益增长的民族主义挑战，奥斯曼帝国在东欧的领土走上同样的道路只是时间问题。 欧拉比和他的同僚们决定采取行动。他们起草了一份给赫迪威陶菲克的请愿书，陈述他们的不满和要求。1881年1月的这份请愿书标志着欧拉比参与国家政治的开始，开启了军人干政的危险先例，这将在整个20世纪的阿拉伯历史中重演。欧拉比和他的埃及军官们有三个主要目标：扩大埃及军队的规模，撤销财政掌控者强加给军队的裁员额度；修改条例，确立军人之间不分种族和宗教，一律平等；任命埃及本土军官担任军事大臣。 维多利亚时代的大英帝国如果向次发达国家的叛逆军官退让，那就不会自认为“大”了。西摩上将得到了政府的批准，7月11日，他向亚历山大的防御工事和城市开火。到日落时，亚历山大已陷入火海，埃及军队正在撤退。7月14日，一支英军占领了亚历山大。这不仅仅开启了一场战争，也开启了英国对埃及长达近四分之三世纪的占领。 艾哈迈德·欧拉比的起义政府同泰勒凯比尔的防御工事一起垮塌了。两天后，欧拉比在开罗被捕。他和他的同僚们以叛国罪受审，被判有罪。他们的死刑判罚被减为终身流放，流放地是英国殖民地锡兰（今斯里兰卡）。赫迪威陶菲克恢复了王位，但再没完全恢复统治权。由于英国军队占领了这个国家，英国的顾问被派往各级政府。埃及的真正统治者是英国常驻代表伊夫林·巴林爵士（Sir Evelyn Baring），他后来获得了伯爵爵位，被封为克罗默伯爵（Lord Cromer）。 他在1911年离世，尽管他百般努力，但有两项指控在他死后几十年内依然玷污着他的名声：应对挑起英国占领埃及负责，背叛埃及合法统治者穆罕默德·阿里王朝。只有当新一代的年轻埃及上校们在1952年革命中，推翻了穆罕默德·阿里王朝的最后一任统治者之后，欧拉比才得以恢复名誉，并被迎入埃及民族英雄的“万神殿”。 德国正凭借自身的实力成为一个帝国，在非洲和南太平洋拥有领地，摩洛哥将成为德法之间的竞争点。尽管德国尽最大努力使与会者反对法国，但3个与会国——意大利、英国和西班牙已经同意法国对摩洛哥的领土要求，德国政府被迫让步。1909年，德国终于承认法国在维护摩洛哥安全上发挥着特殊作用。 摩洛哥人对法国不断扩大在摩势力感到不满，他们开始攻击外国商店企业。而法国采取的报复行为是占领摩洛哥的城镇。最臭名昭著的是，1907年在一家法国工厂遭到暴力袭击后，法国从海上炮轰卡萨布兰卡，并用5000人的兵力占领了这座城市。 1912年3月，法国完成了对摩洛哥的占领，穆莱阿卜杜·哈菲兹签署了《非斯条约》，摩洛哥成为法国的被保护国。尽管谢里夫们仍在王位上（事实上，现任国王穆罕默德六世是他们的直系后裔），但在接下来的44年里，对摩洛哥的正式控制权移交给了法兰西帝国。法国终于可以原谅英国占领埃及了。 以奥斯曼帝国最后的北非领土为代价，和平得以恢复。欧洲国家充当了奥斯曼帝国和意大利之间的调停者，双方于1912年10月缔结正式和平条约，利比亚被纳入意大利的帝国统治。然而，即使在奥斯曼军队撤离后，意大利人仍面临着来自利比亚人的持续抵抗。利比亚人坚持反抗外国统治，反抗斗争在20世纪30年代依然持续。 到1912年底，从直布罗陀海峡到苏伊士运河，整个北非海岸都处于欧洲的殖民统治之下。其中阿尔及利亚和利比亚这两个国家被直接殖民统治。突尼斯、埃及和摩洛哥是被保护国，英法通过当地的世袭王朝间接统治。 直到欧洲人占领北非，民族的自我定义进程才真正开始。成为埃及人、利比亚人、突尼斯人、阿尔及利亚人或摩洛哥人意味着什么？对大部分阿拉伯世界的人来说，这些民族标签并不对应任何有意义的身份。如果被问到他们是谁，或者他们来自哪里，人们或者会用本地的身份来自称，如某个城镇（亚历山大人）或某个部落，至多是某个地区（卡比利亚山区），或者把自己看作一个更大的社群比如穆斯林“乌玛”即“社团”的一员。 如今，萨拉菲主义这个词与乌萨马·本·拉登和反西方的穆斯林激进主义中最激进的派别联系在一起。而在阿布笃的时代，情况并非如此。通过唤起伊斯兰教的先辈，阿布笃回溯历史去倾听那个黄金时代。那时，穆斯林“正确地”信奉他们的宗教，并因此成为主导世界的力量。在伊斯兰教兴起后，穆斯林统治整个地中海并深入南亚长达四个世纪。此后，他认为，伊斯兰思想僵化了。神秘主义悄然渗入，理性主义逐渐衰落，整个伊斯兰社团都陷入对法律的盲目尊崇之中。只有剥除这些附着在伊斯兰教之上的积淀，乌玛才能回归先辈们纯粹而理性的行为方式，才能恢复曾使伊斯兰世界主导世界文明的活力。 第六章 分而治之：第一次世界大战及战后解决方案20世纪初期，民族主义开始在奥斯曼帝国诸阿拉伯行省兴起。奥斯曼人治下近四个世纪之后，帝国内的阿拉伯民众起初甚至难以想象自身可以组建一个独立的国家。早期阿拉伯民族主义者面临着几乎无法跨越的困难。奥斯曼国家无处不在，对非法政治活动采取了无情的镇压。那些寻求阿拉伯地区独立的人缺乏实现其目标的手段。要想动摇奥斯曼人对阿拉伯世界的掌控显然需要某种巨变。事实证明，第一次世界大战将提供这样一场巨变。 1914年11月，奥斯曼帝国与德国结盟卷入第一次世界大战。这是一场奥斯曼人本希望避免的战争。在经历了1911年与意大利人争夺利比亚、爱琴海岛屿的战争，以及1912年、1913年与巴尔干诸国间两场毁灭性的战争后，奥斯曼帝国已然疲于应对战事。1914年夏，当又一场欧洲大战阴云笼罩之际，奥斯曼政府希望能够置身事外，与英国或法国达成一项防御性的盟约。然而，无论是英国还是法国，都不愿许下任何威胁到其协约国盟友俄国利益的有约束力的承诺，而后者的领土野心则是奥斯曼帝国的心头大患。 奥斯曼人撤退至安纳托利亚地区，自此未再踏入阿拉伯人的土地。1918年10月，最后一支土耳其部队从阿勒颇以北的边境地区撤出，这一地点正接近于402年前“冷酷者”塞利姆一世开始其对阿拉伯世界征服的起点。奥斯曼人对阿拉伯领土长 当整个世界都齐聚巴黎商讨和平的条款之时，阿拉伯人则将伍德罗·威尔逊视为他们诉求的旗手。 叙利亚议会成员要求叙利亚在其地理边界内的完全政治独立，这一边界保证其国家与土耳其、伊拉克、纳季德、希贾兹、埃及相分离；他们要求以埃米尔费萨尔为国王，在国内建立君主立宪制政体；并完全拒绝《国联宪章》第二十二条所规定的委任统治条款。他们声称阿拉伯人在天赋方面并不逊色于保加利亚、塞尔维亚、希腊、罗马尼亚等民族，后者在脱离奥斯曼帝国后全部获得了完全独立，并无类似的欧洲托管。叙利亚代表表示完全愿意接受一个仅限于提供技术和经济援助的托管方，且最信任由美国来履行这一角色，“相信美利坚民族离任何殖民化的想法距离最远，且对我们的国家不抱有政治野心”。如果美国拒绝承担这一责任，叙利亚人民愿意接受英国的委任统治，但拒绝法国扮演任何角色。决议同时也呼吁当时处于英国占领之下的伊拉克的独立。 英、法两国政府拒绝承认叙利亚独立宣言。当法国人着手准备占领大马士革，推翻其战时盟友而如今已是国王的埃米尔费萨尔之际，英国人则视若无睹。由于未能兑现其独立承诺，费萨尔在国内也日益孤立，因而仅能聚集一小支部队来对抗由黎巴嫩向叙利亚进发的法军。显然，大马士革人并不认为费萨尔的事业值得为之牺牲。 法军在横扫麦赛伦的抵抗者后进入大马士革，也开启了一段长达26年的悲惨的殖民占领。然而，麦赛伦战役的象征意义远远超出了叙利亚的疆域。对阿拉伯人而言，这场不大的战役不仅标志着英国对其战时承诺的背叛和美国总统伍德罗·威尔逊所倡导的民族自决理念的破产，也表明英、法殖民利益最终压倒了几百万阿拉伯人的希冀和愿望。当欧洲人试图在中东强加其民族国家体系，将一个渴望统一的民族分割肢解并违背其意愿地置于外国统治之下的时候，麦赛伦就等同为原罪。战后解决方案所制造的全新阿拉伯国家及其边界体系表现出惊人的持久性，其一手制造的问题也同样如此。 埃及各地的民众一致支持萨阿德·扎格卢勒的事业，迫不及待地希望在巴黎和会上确保埃及脱离英国而独立。随着该运动声势日涨，英国人曾尝试通过将埃及问题与巴黎和会脱钩的方式来终止民族主义者的煽动活动。温盖特宣布，关于埃及地位的任何变动都被英王政府视为“一个帝国内部的而非国际性质的问题”。换句话说，作为一个帝国内部问题，扎格卢勒及其同事必须在白厅与英国政府讨论其诉求，而非在巴黎向全世界陈诉埃及的情况。英国当局向扎格卢勒发出直接警告，要求他停止煽动活动，但后者对英国人的警告置若罔闻。1919年3月8日，扎格卢勒及其主要同事最终被捕，随后被流放至马耳他岛。这一举措在埃及激起了全国性暴动，也标志着1919年埃及革命的开端。 伊拉克人始终将托管地作为帝国主义一种改头换面的说法而加以反对，他们开始动员起来全力阻挠英国的计划。反对派由一个新的组织——伊拉克独立卫士领导，该组织1919年首先出现在什叶派社群之中。“卫士”要求伊拉克完全独立以及英国完全撤军，因而吸引了大量逊尼派支持者。为了避免英国当局干预，他们轮流在什叶派和逊尼派清真寺中举行会谈。伊拉克不同穆斯林社群间的这次合作是史无前例的，也为一个超越宗教边界的伊拉克民族共同体奠定了基础。 1920年大起义在伊拉克被称为“1920年革命”，它在伊拉克现代国家民族主义神话谱系中具有特殊地位，堪比1776年美国革命对美国历史的影响。二者与其说是社会革命，不如说是反抗外国占领者的民众起义；二者都标志着两国民族主义运动的开端。尽管绝大多数的西方人对1920年伊拉克起义缺乏了解，但一代又一代的伊拉克学童正是听着民族主义英雄如何在费卢杰、巴古拜、纳杰夫等城镇对抗外国军队和帝国主义的事迹长大的，这些故事相当于列克星敦和康科德的伊拉克版本。 阿拉伯人面临的新时代实际上将由欧洲殖民主义而非阿拉伯独立所形塑。欧洲列强确立了他们的战略需求，并通过战后和平进程解决了他们内部的所有分歧。法国将叙利亚、黎巴嫩并入了其在北非的阿拉伯属地，英国则成为埃及、巴勒斯坦、外约旦及伊拉克的主人。尽管对特定的边界还会做少量修正，但欧洲列强大体上划定了我们今天所知的现代中东国家的边界（巴勒斯坦是一个重要的例外）。阿拉伯人从未认同这一根本性的不公，在两次大战之间的剩余岁月中，他们将为追求长期企盼的独立地位而与其殖民主展开斗争。 第七章 大英帝国在中东1913年，一个新的阿拉伯国家突然在“英治和平”下的波斯湾地区崛起。沙特家族（其18世纪的联盟曾在自伊拉克至麦加、麦地那两圣城的广大区域对奥斯曼统治构成挑战，直至1818年被穆罕默德·阿里的军队击败）重建了与穆罕默德·本·阿卜杜·瓦哈卜后人的盟友关系，从而建立起一个新的沙特-瓦哈比联盟。联盟首领是一位名叫阿卜杜·阿齐兹·本·阿卜杜·拉赫曼·费萨尔·阿勒·沙特（Abd al-Aziz ibn Abd al-Rahman al-Faysal Al Sa‘ud,1880—1953）的富有个人魅力的年轻领袖，在西方更多以伊本·沙特（Ibn Saud）的名字闻名。 随着阿拉伯大起义的爆发，当谢里夫侯赛因于1916年10月宣布自己为“阿拉伯诸国的国王”之时，沙特人与哈希姆人之间的冲突已变得不可避免。即便是曾许诺他建立一个“阿拉伯王国”的英国盟友，在麦加谢里夫之外也只愿承认他为“希贾兹的国王”。伊本·沙特不太可能认可这位自封的侯赛因国王之主张的有效性。 征服希贾兹后，伊本·沙特被拥护为“纳季德素丹兼希贾兹国王”，其控制下的广阔领土使伊本·沙特不同于停战诸国的其他海湾统治者。英国承认了其地位的变化，于1927年与阿卜杜·阿齐兹国王签署了一项新的协议，承认其完全的独立与主权，且不含有休战诸国所接受的关于对外关系的任何限制。伊本·沙特继续扩张其治下的领土，并于1932年将其王国更名为沙特阿拉伯。 于其自身条件，英国人起初并未将外约旦视为一个独立的国家。这块领土最初是作为巴勒斯坦托管地的一部分被授予英国的，而将外约旦从巴勒斯坦中分离出来的决定成型于1923年，主要基于两点考虑：一方面，英国希望将《贝尔福宣言》所承诺的一个犹太民族家园限定在约旦河西岸的土地上；另一方面，英国希望将埃米尔阿卜杜拉的领土野心限定在可控的范围之内。 费萨尔完全清楚他不可能在独立于英国的情况下统治伊拉克：正如国联所规定的那样，他必须在英国的监护下进行统治，直至后者认为时机成熟从而承认伊拉克独立。此外，作为一名外来者，他在伊拉克的盟友仅限于在阿拉伯大起义以及短命的叙利亚王国期间一直追随于他的少数几名军官。因此，在成功巩固自己的位置之前，为了能生存下去，费萨尔尚需要英国的支持。对费萨尔而言，问题的关键在于对英国的依赖削弱了伊拉克民族主义者对他的支持；反讽的是，这种依赖也削弱了他赢取本国人民忠诚的能力，直到1933年他去世为止。 费萨尔国王身边围绕的是一些自阿拉伯大起义时期就在他身边效力的军人，这些人热切地期望在伊拉克建立一支军队，通过国民军役服务将库尔德人、逊尼派、什叶派团结在一起。然而，面对什叶派和库尔德社群的积极反对，这个计划很快便告搁浅。这两个社群反对强制兵役制，正如他们反对在其看来给予阿拉伯逊尼派少数群体超出其人口比例权力的任何政府倡议。 某些时候，唯一能将伊拉克民众团结在一起的就是他们对英国人存在的反对。费萨尔国王已经对其臣民感到绝望。1933年去世前，这位伊拉克首任国王在一封绝密备忘录中评论道：“我要满怀悲痛地承认，至今为止还没有什么伊拉克人民，只有无法想象的人群的集合；这些人没有任何爱国理想，却被灌输了宗教传统和荒谬的观念；没有任何共同的联系纽带，听信谗言，倾向混乱，随时准备起来反抗一切形式的政府。” 1930年《特惠同盟协议》批准后，英国人和伊拉克人一致同意终止委任统治状态。1932年10月3日，伊拉克加入国联，被认可为一个独立主权国家。然而，这仍是一种模糊的独立状态，因为英国文职和军事官员继续享有的广泛影响，与真正意义上的主权独立并不相容。英国的这种非正式控制也将削弱哈希姆王朝的合法性，直至该王朝在1958年被最终推翻。 英国坚持将关于埃及独立的讨论与苏丹的未来分离，埃及人则拒绝放弃苏丹版图的独立。英、埃谈判的失败为华夫脱党的政敌——国王和敌对政党呼吁重新组阁提供了一个机会。1930年夏，国王和英国人达成了一致：政府必须置于“一双安全的手”的管理之下。西德基就是那位明显的候选人。西德基丝毫不掩饰其强人政治倾向以及他对民主程序的蔑视。西德基论证其政治哲学合法性的理由是，在经济困难时期领导人不可能仅通过和平与命令就能实现繁荣进步。 西德基的革命已然熄火，现在就要彻底失败了。1933年9月，国王解除了西德基的首相职务。后者虽然下台但并没有出局，直至1950年去世前一直都是埃及国内最有影响的政治家之一。 新的《特惠同盟协议》扩展了埃及的主权和独立范围，尽管与伊拉克的协议类似，该文件也保证了英国享有其他国家所不具备的特殊地位，且有权保留其军事基地。协议同样将苏丹置于英国控制之下。但这些收获已足以确保埃及于1937年，即伊拉克加入5年之后，加入国联，进而成为其他阿拉伯国家中唯一加入这一国际组织的国家。然而，协议中的种种妥协以及长达20年的期限，实际上也将埃及人实现完全独立的梦想排除在政治视野之外。 英国在巴勒斯坦的委任统治从一开始就注定要失败。为正式确立英国在巴勒斯坦的地位，国联发布了一份委托文件，将《贝尔福宣言》的条款写入了其序言部分。与战后其他的托管地不同，英国人在巴勒斯坦既要在本地居民中建立一个切实可行的国家，同时又要为全世界的犹太人建立一个民族家园；而对其他托管地而言，相关大国仅被责成在一个新兴国家中建立自治的机制。 《贝尔福宣言》是一个导向社群冲突的方案。鉴于巴勒斯坦极为有限的资源，在那里建立一个犹太人的民族家园，同时又不损害本地非犹太居民的民事和宗教权利，这样的想法根本就不切实际。委任统治不可避免地催生了两种相互竞争的民族主义之间的冲突：一边是高度组织化的犹太复国主义运动，另一边则是在英国帝国主义和犹太复国殖民主义双重威胁下新生的巴勒斯坦民族主义。巴勒斯坦将成为英帝国在中东最惨痛的失败，而这一失败也将使整个中东地区陷入冲突与暴力，直至今日。 巴勒斯坦是古老土地上的一个新国家，由几个奥斯曼行省的土地拼凑而成，仅仅是为了帝国的方便。 1923年时，巴勒斯坦的人口构成已经相当多元。巴勒斯坦是基督徒、穆斯林、犹太教徒的共同圣地，数个世纪以来吸引着世界各地的朝圣者。穆斯林是占总人口85%的多数群体，而基督徒是约占总人口9%的少数群体。还有一个本地犹太社群不超过本地人口的3%。 来自巴勒斯坦的信号是明确的：本地的阿拉伯居民多年来一直反对犹太复国主义移民运动，也绝不接受英国人在其土地上建立一个犹太民族家园的承诺。然而，英国和国际社会对这一信号却置若罔闻，仍然在未咨询或考虑民众意愿的情况下就决定了巴勒斯坦的未来。和平手段既已失败，绝望的民众很快转向暴力。 1922—1935年间，犹太人占巴勒斯坦总人口的比重由9%猛增至27%。[插图]犹太人的土地收购已然使得大量巴勒斯坦农民被迫离开土地，早在几年之前，《帕斯菲尔德白皮书》就已指出了这一问题，而当时巴勒斯坦的犹太人口仅为1935年规模的一半。完全由城市精英所垄断的巴勒斯坦（阿拉伯）领导层的失败恶果，却直接落在了农村贫困人口的肩头。1935年，有一个人决定将巴勒斯坦农民群体的愤怒导向武装反叛。在这一过程中，他提供了点燃巴勒斯坦这个火药桶的最初火花。伊兹丁·卡萨姆 1941年拉希德·阿里政府倒台后，巴格达的犹太社群成为混乱局势的首要受害者。反英情绪、对犹太复国主义在巴勒斯坦计划的敌意同德国的反犹主义观念相叠加，酿出了阿拉伯历史上前所未有的大屠杀，在阿拉伯语中被称为“法尔胡德”（Farhud）。 在伊拉克人赢得其名义上的独立地位仅9年后，这次（军事）干预就使得英国和哈希姆王朝在伊拉克人民眼中彻底失去了信誉。然而，英国才是伊拉克土地上最终的失败者。曾几何时，英国在伊拉克的委任统治被传为佳话，而现在却只剩下一个摇摇欲坠的君主，一支危险的军队，一群如此仇视英国在中东的角色以至于不惜与其轴心国敌人并肩作战的民众。 随着阿拉伯世界逐渐脱离英国人的掌控，英国在中东的帝国越来越成为一个负担，而不是优势。对英国人而言，可能唯一的安慰就是：他们的帝国竞争对手法国，在其阿拉伯领土上似乎也并不比自己成功多少。 第八章 法兰西帝国在中东长久以来，法国为了其在阿拉伯世界的帝国觊觎大叙利亚地区——大概包含今天的叙利亚、黎巴嫩、巴勒斯坦、以色列、约旦等国领土。 这次选举也证明法国意图将黎巴嫩作为一块殖民地来进行统治，而非帮助后者实现独立。这些举措也说服了一些曾经最有力的法国支持者，转而加入反对法国统治的黎巴嫩民族主义斗争。而这也成为两次大战之间法兰西帝国在中东地区的一个不祥开端：如果法国在黎巴嫩都不能确保诸事顺利的话，那它在其他阿拉伯领土上又将如何做到呢？ 尽管在沦为被保护国之前曾享受过数个世纪的独立政治地位，但摩洛哥的统治者从未成功地将其权威延伸至全国所有领土之上。长期以来，素丹对全国领土的控制都是在城市地区最有力，而在农村地区最薄弱。 里夫战争失败后，法国和西班牙恢复了在摩洛哥的殖民统治，再也没有受到新的本地抵抗运动的困扰。尽管里夫战争并未引发对法国或西班牙在摩洛哥统治的持续反抗，但阿卜杜·克里姆及其抵抗运动却激发了整个阿拉伯世界民族主义者的想象力：里夫人被视为阿拉伯人的一支（而非柏柏尔人），他们领导了一场反对欧洲统治的英雄般的抵抗运动，为保卫自己的土地和信仰而多次击败了欧洲人的现代军队。 法国人很快做出回应。尽管正如盖伍格吉料想的那样，绝大多数法国军队都在德鲁兹山作战，但法国人还有空军力量。法国人开始了一场针对城市居民区的轰炸，将哈马市中心市场的一部分夷为平地，造成约400名平民死亡，其中很多是妇女和儿童。尽管最初承诺支持盖伍格吉的运动，但哈马的显贵们也是最早脱离反抗队伍、并与法国人就停止反叛和轰炸达成一致的人。起义后仅3天，盖伍格吉及其追随者就被迫撤离至农村地区，任由法国人重新占领哈马。 几天的时间内，起义已传播至大马士革周边的村庄。法国人试图通过展示极端暴力来遏制这场运动：整批的村庄在炮兵和飞机的轰炸下被摧毁；大马士革内陆地区近100名村民被处决，死者尸体作为可怕的战利品被运回大马士革，以便对其他起义的支持者形成震慑。可以预见的是，暴力行为引发了更多的暴力：作为对与殖民当局勾结的警告，12名为法国人服役的本地士兵残缺不全的尸体也被暴露在大马士革城门之外。 叙利亚大起义未能从法国统治下实现独立。之后，民族主义运动领导权落入一个新的城市精英领导层手中，后者回避武装斗争，试图通过谈判和非暴力抗议的政治程序来实现自己的目标。直至1936年，叙利亚民族主义者的种种努力都收效甚微。 阿尔及利亚穆斯林不但不受法国法律的保护，还受制于一套被称为《本土居民法典》的歧视性法规。与美国南北战争后通过的旨在维持非裔美国人隔离、从属地位的《吉姆·克劳法》相似，上述法典起草于1871年最后一次重要的阿尔及利亚反法起义之后，规定本土阿尔及利亚人可因部分欧洲人有权合法从事的行为而受到起诉，如批评法兰西共和国及其官员。该法典比其他任何司法区分都更加直接地提醒阿尔及利亚人，他们是自己土地上的二等公民。对于法尔哈特·阿巴斯这样深受法国共和思想熏陶的人而言，这种侮辱显然难以忍受。 1940年5月纳粹德国占领法国并推翻其政府后，法国几乎与其在黎凡特地区的两个托管国爆发重大冲突。 法国人用汽车将扈里押解到南部城镇拉什亚的城堡之中，在路上他们与另外几辆汽车会合，车上则押解着总理里亚德·苏勒哈（Riyad al-Solh）以及内阁的主要成员。当天下午，黎巴嫩政府的6名成员已被囚禁至拉什亚。逮捕的消息传开后，立即在贝鲁特引发了激烈的示威活动。扈里的妻子加入了示威人群，以声援那些抗议其丈夫和黎巴嫩政府所遭遇不公的示威者。黎巴嫩人向英国人提出申诉，后者正是1941年7月自由法国政府宣布黎巴嫩独立时的担保人。英国政府迅速介入，迫使法国人释放了扈里总统及其他黎巴嫩政治家。黎巴嫩宪法的变动得到了保留，但法国通过对安全部队的控制仍执意维持其在黎凡特的托管国。为了确保对其军队和警察部队的控制，在之后3年的时间内黎巴嫩政府仍将与法国人展开一场持久的战役。 1941年7月自由法国政府的宣言发布后，叙利亚人对实现独立前景的估计并没有黎巴嫩人那样乐观。大马士革的自由法国当局已向叙利亚政治领导层明确表示，在保证法国在叙、黎两国利益的一系列条约达成前，法国无意承认叙利亚或黎巴嫩的独立地位。叙利亚民族集团还需要动员一次与法国人的重大对抗，以便实现其独立诉求。 1944年冬至1945年春，大规模的反法示威游行在两国举行。当法国宣布在叙利亚政府签订协议之前不会放弃对叙国民军的控制时，叙、黎两国政府拒绝进一步谈判。1945年5月，法国人的固执在叙利亚全国引发了广泛的示威和反法抗议活动。作为首都和全国政治的中心，大马士革成为反对派的中心。鉴于法国当局不具备足够的武装部队来维持秩序，随着局势的快速恶化和失控，法国人开始诉诸致命的武力，试图通过斩首和轰炸迫使叙利亚政府及其公民屈服。 1945年7月，法国最终承认自己的失败，同意将军事和安全部队的控制权移交给独立的叙利亚和黎巴嫩政府。法国向两国强加一份协议的问题也不复存在。当1945年10月24日两国以创始成员国这个与法国平等的身份加入联合国之时，国际社会便承认了叙利亚和黎巴嫩的独立。所剩的工作只是法国从黎凡特地区撤出其部队。1946年春法国军队撤离叙利亚，同年8月从贝鲁特登船回国。 第九章 巴勒斯坦灾难及其后果犹太定居者与英国政府兵戎相见似乎令人难以置信，因为正是后者将犹太复国主义在巴勒斯坦建立一个犹太民族家园的梦想变为现实。然而，第二次世界大战期间，英国越来越多地受到巴勒斯坦犹太社群的攻击。对犹太移民施加严格限制、呼吁在1949年实现（阿拉伯）多数统治下巴勒斯坦独立的《1939年白皮书》，已然彻底激怒了犹太复国主义领导层。 直到二战结束后，伊尔贡、莱希、哈加纳才开始联合力量对抗巴勒斯坦的英国人。纳粹死亡集中营被解放后，大屠杀骇人听闻的罪行逐渐浮出水面。伊休夫的领导人决心将种族灭绝中的犹太幸存者由欧洲的难民营迁至巴勒斯坦。他们拒绝遵守《1939年白皮书》对犹太移民的限制，宣布发动一场反对英国委任统治的起义。1945—1946年间的一个短暂时期，哈加纳与莱希和伊尔贡秘密协调行动，试图通过暴力强迫英国人改变政策。 二战之后，英国既没有资源也没有意愿继续留在巴勒斯坦。巴勒斯坦犹太人与阿拉伯人之间的分歧不可调和：如果英国人向犹太人让步，他们担心阿拉伯人又会发起一场与1936—1939年起义相似的大起义；如果他们向阿拉伯人做出让步，现在已经很清楚犹太人会做些什么。英国人试图撮合阿拉伯和犹太领袖1946年9月在伦敦举行会谈，但因双方都拒绝参会而以失败告终。考虑到阿拉伯人和犹太人相互矛盾的建国要求，1947年2月在伦敦举行的一系列双边会谈也都无果而终。 英国人陷入了绝境，而《贝尔福宣言》的悖谬现在也体现得清晰无比：英国人不可能在实现一个“犹太人的民族家园”的同时，不损害“巴勒斯坦既有非犹太社群的利益”。 英国人甚至来不及等待联合国正式讨论特别委员会的提议。“出埃及号”丑闻、英国中士被绞死、随后的反犹骚乱、特别委员会报告，这一系列前后相连的事件已完全动摇了英国继续留在巴勒斯坦的决心。1947年9月26日，英国政府宣布将单方面从巴勒斯坦撤军，并将自身的托管责任委托给联合国。英国撤军的日期被设定在1948年5月14日。 1947年11月，特别委员会报告被提交联合国大会进行讨论。讨论的议题主要围绕委员会多数成员的提议，即将巴勒斯坦分割为一个犹太国家和一个阿拉伯国家而展开。分治决议将巴勒斯坦分为一个由六部分组成的棋盘格，其中犹太区、阿拉伯区各三个，耶路撒冷处于国际共管之下。该计划将巴勒斯坦55%的领土划分给了犹太国家，包括全部加利利狭长地带直至东北部的领土、从海法到雅法的具有战略意义的地中海沿岸地区，以及直至亚喀巴湾的亚拉巴荒漠。 犹太复国主义活动分子积极游说联合国成员，争取获得三分之二多数票，以便执行分治决议和建立犹太国家的承诺。美国犹太复国主义者在争取杜鲁门政府对决议支持方面发挥了关键作用。哈里·杜鲁门在其回忆录中称自己“在白宫从未经历过像这次这样巨大的压力和宣传攻势”。[插图]在最后一刻，美国政府推翻了之前的不干涉立场，积极向其他（联合国）成员施压支持分治方案。1947年11月29日，分治方案以33票赞成、13票反对、10票弃权的结果最终获得通过。 巴勒斯坦人从未从失去阿卜杜·卡迪尔·侯赛尼的损失中完全恢复过来，再没有一位本地领袖能够调动一场反抗巴勒斯坦犹太军队的全国性抵抗运动，因而侯赛尼之死构成了对公众士气的巨大打击。更糟糕的是，结果证明他的死亡也是徒然：士气不振的阿拉伯部队仅留下40名防御者来守卫盖斯塔勒，结果在不到48小时的时间内，犹太军队就重新夺取了该镇——这次是永久性的。 英国委任统治的最后一天，巴勒斯坦内战也告一段落。1948年5月14日，巴勒斯坦犹太人宣布建国，自此以后他们将被称为以色列人。战败的阿拉伯人没有国家来尊崇他们的巴勒斯坦身份，他们将所有的信任寄托在阿拉伯邻国身上。后者正在巴勒斯坦边境集结军队，等待英国人最后撤离。正如之前承诺的那样，英国人于5月14日站完了“最后一班岗”，降下国旗登船离去，将他们在巴勒斯坦制造的一切悲剧都抛在了身后。 阿拉伯国家在第一次阿以战争前夕已然完全陷入混乱。所有的阿拉伯国家都面临一个严肃的两难选择。一方面，他们将巴勒斯坦发生的冲突视为阿拉伯人共同的事业，感觉有道德义务进行干预，并保护巴勒斯坦的阿拉伯同胞；所有阿拉伯国家在阿拉伯国家联盟的框架内协调行动这一事实，更强化了这一点。另一方面，每一个独立的阿拉伯国家都有自己的国家利益，他们是以埃及人、约旦人、叙利亚人而非阿拉伯人的身份参战。他们将阿拉伯国家的内部竞争也带到了战场之上。阿拉伯国家最终参战与其说是为了拯救阿拉伯巴勒斯坦，不如说是为了防止改变阿拉伯世界现有的势力均衡。 因此，阿拉伯联军参加巴勒斯坦战争的目的基本上是消极的：防止在他们中间建立起一个外来的犹太国家，防止外约旦扩张至巴勒斯坦，同时防止穆夫提侯赛尼成立一个独立自主的巴勒斯坦国家。基于这样的战争目标，阿拉伯军队被决意要建立自己国家的犹太军队完全打垮也就不足为奇了。 阿拉伯世界的政客们完全忽视了那个仍启发着如此众多民众的更广大的阿拉伯民族。阿拉伯人在巴勒斯坦（战争中）灾难性的表现已然揭示了他们政治的破产。也正因如此，阿莱米和祖雷克提出的补救方案，即一个由被解放的公民所组成、以统一的力量来面对现代世界诸多挑战的更广阔的阿拉伯民族，才会打动许多的阿拉伯人，成为他们解决积弱现状的主要方案。巴勒斯坦的教训表明，在分裂的状况下阿拉伯人必将衰落，只有团结起来才有希望承受现代世界的挑战。 分别于1949年、1952年、1958年在叙利亚、埃及和伊拉克上台的年轻军官们与英国或法国并没有联系，相反他们转向了新的世界强权——美国及其超级大国对手苏联。这是帝国时代的结束，也是冷战新时代的开端。阿拉伯人不得不适应一套新的游戏规则。 第十章 阿拉伯民族主义的兴起在20世纪50年代剩余的岁月中，法国放弃了阿拉伯世界，开始全力支持以色列。事实上，苏伊士运河危机结束伊始，法国就开始给以色列人提供武器，并帮助后者建立了核项目。1957年，法国向以色列提供了一座两倍于其原先承诺容量的反应堆。 这套信条于1957年1月首次提交给美国国会，后成为冷战在中东地区发展的一个重要里程碑。作为遏制苏联在中东地区扩张的一套新的政策倡议，该信条呼吁美国向中东国家提供发展援助和军事支持，以帮助这些国家维护其民族独立。更重要的是，艾森豪威尔主义授权“部署美国武装部队来确保和保护地区国家的领土完整与政治独立……免遭国际共产主义控制之下任何国家的公然武装侵犯”。 黎巴嫩成为美国人和纳赛尔主义者争夺的战场，前者试图支持亲西方政权，后者则致力于联合阿拉伯力量反对外部干预。随着议会选举的临近，美国政府担心埃及、叙利亚会支持民族阵线，削弱亲西方的夏蒙的地位。因此，美国人开始插手破坏选举活动。中央情报局提供了巨额资金，以担负夏蒙集团内候选人选举攻势的开销。 在埃及革命的推动下，阿拉伯世界经历了彻底的转型。20世纪50年代，埃及已跃居为该地区最强大的国家，纳赛尔则成为阿拉伯世界无可争议的领袖。随着1958年埃及和叙利亚合并为阿拉伯联合共和国，纳赛尔的权力也达到顶峰。合并事件在阿拉伯世界引发冲击波，几乎推翻了邻近的黎巴嫩和约旦两国脆弱的政府。阿拉伯民族主义者则翘首期盼着约旦哈希姆王室以及黎巴嫩亲西方的基督徒政府的倒台，期待两国加入阿拉伯联合共和国。1958年伊拉克革命推翻了巴格达的哈希姆王室，似乎预示着一个全新的阿拉伯秩序的到来——将埃及与新月地区联合起来，在一个团结、进步的阿拉伯超级大国中实现阿拉伯民族主义者的愿望。在一个短暂、兴奋的时刻，似乎阿拉伯世界将打破那种作为奥斯曼、殖民帝国和冷战时期标志的外部统治的循环，实现真正意义上的独立。 第十一章，阿拉伯民族主义的衰落至20世纪60年代，纳赛尔非凡的胜利进程却戛然而止。1961年，埃及与叙利亚的合并宣告解体，埃及军队深陷也门内战的泥潭。1967年，纳赛尔率领其国家和阿拉伯盟友步入了一场与以色列的灾难性战争。以色列对巴勒斯坦剩余领土、埃及西奈半岛以及叙利亚戈兰高地的占领，使得解放巴勒斯坦的长久许诺进一步遭遇挫败。1970年纳赛尔去世之际，阿拉伯世界在10年前的种种雄心壮志已然被消磨为一股幻灭与激愤的情绪。 广而言之，那些受西方支持的国家如摩洛哥、约旦、沙特等保守君主国，以及突尼斯、黎巴嫩等自由主义共和国，都被划为“反动”国家（在西方被视为“温和”国家）。革命的阿拉伯国家都与莫斯科结盟，追随后者的社会经济模式。这些国家在阿拉伯世界被称为“进步”国家（在西方则被归为“激进”阿拉伯国家）。起初，“进步”国家的名单十分有限——埃及、叙利亚和伊拉克，但随着阿尔及利亚、也门、利比亚革命的胜利，这一阵营也将有所扩大。 阿尔及利亚获得了独立，但代价是高昂的：阿尔及利亚人口遭遇了大规模的伤亡和流离失所，其规模在阿拉伯历史上前所未有；其经济受到战争的摧残以及撤离中定居者蓄意的破坏；其政治领导层为派系斗争所割裂；其社会也因对于男性和女性在独立后的阿尔及利亚建设中所应扮演角色的不同期待而发生分裂。但阿尔及利亚很快开始组建政府，并作为一个脱胎于反帝革命斗争的共和国而跻身于进步阿拉伯国家的行列。 艾哈迈德素以冷酷无情著称，因在掌权过程中将其竞争对手囚禁或处决而恶名更著。为了寻求发展支持和军事援助，艾哈迈德抛弃了其父亲的仇外立场，与苏联和中国建立了外交关系。 1967年战争彻底改变了美国在中东的地位。从那时起，美国和以色列之间的特殊关系就开始了，这一关系有多好，阿拉伯人对美国的敌意就有多深。双方之间的分歧必然会出现，因为彼此的地缘战略优先关切不同：美国人无法说服阿拉伯人站在自己一边对抗苏联威胁，阿拉伯人也无法让美国人认同他们关于犹太复国主义威胁的看法。 喀土穆峰会因划定了阿拉伯外交中“三不原则”而闻名于世，即不承认犹太国家、不与以色列官员进行谈判、阿拉伯国家和以色列之间不缔结和约。 20年以来，巴勒斯坦人始终将他们的事业托付给阿拉伯兄弟，寄希望于通过阿拉伯人的联合行动来实现被占家园的解放。1967年阿拉伯人的集体失败，最终说服巴勒斯坦的民族主义者去把握主导权。受第三世界革命者的启发，巴勒斯坦民族主义团体发起了自己的武装斗争，其斗争对象不仅是以色列，还包括那些阻碍他们的阿拉伯国家 至1970年，阿拉伯世界彻底分裂为众多维护自身利益的独立国家。1970年之后，阿拉伯国家之间还会有一些高调的统一方案，但没有一个方案对所涉国家的完整性构成挑战，而且没有一个持续下来。 第十二章，石油时代在现代历史中，石油在阿拉伯人的财富与权力的界定方面超出了任何其他商品的影响力。但石油也象征着某种虚假的权力：石油产出的巨大财富使一个国家更容易遭受外部威胁；石油财富既可用于发展，又可通过军备竞赛和地区冲突而被用于毁灭。石油的作用好坏参半，但最终，在动荡的20世纪70年代，石油没有给阿拉伯国家带来多少安定，甚至反而让整个地区动荡不宁。 1960年9月14日，伊朗、伊拉克、科威特、沙特和委内瑞拉宣布成立石油输出国组织，以欧佩克（OPEC）而闻名。 一个人是无法通过文字、声明、外交准则来改变公众意见的，一个人是通过那些可以直接向每个人内心发出呼声的戏剧性事件来改变公众意见的，人们可以亲自在电视上看到、在广播中听到、在报纸标题上读到这些事件。” 阿拉法特并没有利用联合国讲台向以色列人伸出和平之手，而是以一个夸张的威胁结束了他的讲话：“今天，我来到这里，一手拿着橄榄枝，一手拿着自由战士的枪，不要让橄榄枝从我手中滑落。我再说一遍：不要让橄榄枝从我手中滑落。”￼ 巴以和平的机遇期现在已经结束。1975年4月13日，基督徒民兵在贝鲁特市郊的艾因·鲁曼尼伏击了一辆满载着巴勒斯坦人的大巴，车上28人全部罹难。该事件也成为一场长达15年的内战的开端，这场内战将使黎巴嫩化为一片废墟，也将巴勒斯坦运动逼到了生死存亡的边缘。 第十三章，伊斯兰的力量20世纪80年代，一些伊斯兰运动发起武装斗争来推翻世俗统治者或击退外国侵略者。伊斯兰主义者希望建立一个按照伊斯兰法统治的伊斯兰国，他们坚信这是真主的法律。他们的灵感来自1979年伊朗革命的成功和伊朗伊斯兰共和国的建立。在埃及，一个分裂运动成功地刺杀了总统安瓦尔·萨达特。在叙利亚，穆兄会对哈菲兹·阿萨德领导的复兴党政府发动了内战。深受伊朗伊斯兰共和国影响的黎巴嫩什叶派武装运动真主党，视美国和以色列为同一枚硬币的两面，并试图大败两者于黎巴嫩。阿富汗的“圣战”同时针对内部和外部的敌人，打击对象是苏联占领军和公开敌视伊斯兰教的阿富汗共产主义政府。加沙和约旦河西岸的伊斯兰主义者呼吁对犹太国家展开长期的“圣战”，以在伊斯兰政府的领导下使巴勒斯坦回归伊斯兰世界。真主党在迫使美国全部撤军和以色列重新部署，以及阿富汗“圣战者”在1989年迫使苏联人撤离他们的国家上取得的军事成功，并没有带来他们的理论家所希望的理想的伊斯兰国。黎巴嫩和阿富汗在外敌被迫撤退很久之后仍然深陷内战。 阿拉伯世界各地的伊斯兰主义者对建立伊斯兰国的最终目标采取了长期战略。埃及伊斯兰主义者宰奈卜·安萨里提出13年的准备周期，该周期将不断反复直到绝大多数埃及人支持伊斯兰政府。哈马斯发誓要为解放整个巴勒斯坦而斗争，“不管花多长时间”。伊斯兰国的最终胜利是一项旷日持久的工程，需要耐心。 即便伊斯兰主义者在“真主之道上的斗争”中输掉了一些战斗，但他们仍然相信他们最终会获胜。与此同时，伊斯兰主义团体在重塑阿拉伯社会方面取得了一些成功。伊斯兰主义组织在整个阿拉伯世界兴起，在20世纪八九十年代吸引了越来越多的追随者。伊斯兰主义价值观在阿拉伯社会蔓延开来，越来越多的年轻男子开始蓄须，越来越多的妇女开始戴头巾、穿着端庄的遮体时装。伊斯兰出版物占据了书店的主要位置。世俗文化被迫退却，伊斯兰复兴方兴未艾，愈发强势，一直持续至今。 伊斯兰主义者从1989年末世界政治的重大变化中获得了勇气。冷战的种种必然如柏林墙一样迅速崩塌。11月9日，柏林墙倒塌，标志着美苏对抗的结束，并迎来了一个新的世界秩序。许多伊斯兰主义者认为苏联政权的崩溃预示着一个新的伊斯兰时代的到来。但现实情况是，他们发现自己面对的是一个单极世界，主导这个世界的是最后一个幸存的超级大国——美利坚合众国。 第十四章，冷战之后伊拉克曾经以其世俗的价值观、高识字率和两性平等著称，但到1989年已退化为一个恐怖共和国。 更糟糕的是，一些海湾国家的产量远远超过了欧佩克的配额。科威特是违反配额最严重的国家之一。 本·拉登谴责此举是对伊斯兰教的背叛。阿特万记录道：“本·拉登告诉我，沙特政府邀请美国军队来保卫王国和解放科威特的决定是他一生中遭受的最大的冲击。” 第二天，美国发动了“沙漠风暴”行动，对巴格达和伊拉克军队在科威特与伊拉克的营地展开大规模的空中轰炸。 当伊拉克入侵科威特时，美国却援引联合国安理会的决议，似乎这些决议是神圣不可侵犯的。占领有的是对的，有的是错的；联合国的决议有的具有约束力，有的不具有约束力。对同为占领者的伊拉克和以色列实施了双重标准，这是不言而喻的。 在简要的情报汇报中，特尼特向当选的总统介绍了美国面临的三大威胁：大规模杀伤性武器、乌萨马·本·拉登和正在崛起为军事和经济强国的中国。 布什进入椭圆形办公室时，深信伊拉克大规模杀伤性武器的威胁已经得到控制，且似乎并不特别关注本·拉登及其网络所构成的恐怖威胁。在他上任的头9个月里，布什的首要关注是中国。2001年9月11日发生的非同寻常的事件将改变布什的优先事项，并将开启美国现代史上与中东最大程度的接触，这也将是阿拉伯现代史上最为紧张的时刻。 第十五章，21世纪的阿拉伯人阿拉伯世界的许多人感觉，公元第三个千年的最初十几年，已经像是一个世纪。在20世纪，重大的转折，一个人一辈子才经历一次：1914—1918年的第一次世界大战标志着奥斯曼时代的结束和欧洲帝国主义之下现代国家体系的引入；1948年的巴勒斯坦战争既开启了阿以冲突，也开启了中东的冷战；1991年的海湾战争宣告冷战的终结和一个崭新的美国霸权时代的开始。 而这个新千年已然见证了中东两个重大转变时刻：2001年的“9·11”袭击引发了美国领导的反恐战争，2011年的“阿拉伯之春”。这两个转折点的到来将决定21世纪中东的面貌。我们依然生活在两者的后续发展之中。在反恐战争和“阿拉伯之春”的压力之下，说2001年9月11日以来的岁月是阿拉伯现代史上最糟糕的时期，毫不夸张。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"政治","slug":"政治","permalink":"https://lchml.com/tags/%E6%94%BF%E6%B2%BB/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"中东","slug":"中东","permalink":"https://lchml.com/tags/%E4%B8%AD%E4%B8%9C/"},{"name":"国际","slug":"国际","permalink":"https://lchml.com/tags/%E5%9B%BD%E9%99%85/"}]},{"title":"《ClickHouse原理解析与应用实践》","slug":"clickhouse","date":"2022-12-15T16:00:00.000Z","updated":"2022-12-16T02:32:11.548Z","comments":true,"path":"technology/clickhouse/","link":"","permalink":"https://lchml.com/technology/clickhouse/","excerpt":"由于业务上要用到ClickHouse，因此花了两三天看了此书，讲的不是特别深，但是挺适合作为ClickHouse使用者的入门，常用的使用姿势和应用需要了解的一些原理都有讲到。","text":"由于业务上要用到ClickHouse，因此花了两三天看了此书，讲的不是特别深，但是挺适合作为ClickHouse使用者的入门，常用的使用姿势和应用需要了解的一些原理都有讲到。 ClickHouse在线文档：(https://clickhouse.com/docs/zh/)[https://clickhouse.com/docs/zh/] 第一部分，背景篇OLTP→OLAP ROLAP，直接使用关系模型构建。海量数据问题。 MOLAP，使用多维数组的形式保存数据，其核心思想是借助预先聚合结果，使用空间换取时间的形式最终提升查询性能。数据膨胀和滞后性问题。 HOLAP，混合上面两种 数据立方体概念 MyISAM引擎使用B+树结构存储索引，而数据则使用另外单独的存储文件；InnoDB引擎使用B+树同时存储索引和数据，数据直接挂载在叶子节点中。 HBase使用LSM树索引结构，发源于Google的BigTable。LSM本质上可以看做是将一颗大树拆成了许多小树。先在内存中构建一颗小树，小树构建过程中会进行排序，小树的数量达到某个阈值输入磁盘生成一小段数据。在每个数据段中，数据局部有序。 发展历程：mysql→Metrage→OLAPServer→ClickHouse 不适用场景： 1、不支持事务 2、不擅长根据主键按行粒度进行查询（虽然支持） 3、不擅长按行删除数据（虽然支持） ClickHouse拥有完备的管理功能，是一个DBMS（数据库管理系统），而不仅仅是一个数据库。 列式存储和数据压缩通常是伴生的，ClickHouse默认使用L4Z算法压缩，在Yandex的生成环境，数据总体压缩比可以达到8:1。 ClickHouse目前利用SSE4.2指令集实现向量化执行 ClickHouse架构设计中的核心模块：（图） Data Streams，Server，Parsers、Interpreters，Storages，Columns，DataTypes，Functions ClickHouse的1个节点只能拥有1个分片，也就是说如果要实现1分片、1副本，则至少需要部署2个服务节点。 分片只是一个逻辑概念，其物理承载还是由副本承担的。 SIMD被广泛应用于文本转换、数据过滤、数据解压和JSON转换等场景。 第二部分，基础篇基础类型：数值、字符串、时间（没有Boolean） 数值类型分为：整数（Int）、浮点数（Float）、定点数（Decimal） 字符串类型分为：String、FixedString、UUID 时间类型：DateTime、DateTime64、Date，最高精度是秒 复合类型：数组（Array）、元组（Tuple）、枚举（Enum）、嵌套（Nested） 特殊类型： Nullable，只能和基础类型搭配使用，不能作为索引字段 Domain，IPv6、IPv6 数据库引擎类型： Ordinary：默认引擎 Dictionary：字典引擎，自动为所有数据字典创建他们的数据表 Memory：内存引擎，临时数据，只停留在内存中 Lazy：日志引擎，只能使用Log系列的表引擎 MySQL：MySQL引擎，会自动拉取远端MySQL中的数据，并为它们创建MySQL表引擎的数据表 三种基本的建表方法：常规定义、复制其他表结构、SELECT字句形式 表字段支持三种默认值表达式的定义方法：DEFAULT、MATERIALIZED、ALIAS 临时表 create temporary table …，只支持Memory表引擎，优先级大于普通表 分区表，数据分区（partition）和数据分片（shard）是完全不同的两个概念。数据分区是针对本地数据而言的，是数据的一种纵向切分。而数据分片是数据的一种横向切分。 只有合并树（MergeTree）家族系列的表引擎才支持数据分区，通过partition by指定分区键 普通视图：create view view_name as select … 不存储任何数据，只是一层单纯的SELECT查询映射，简化查询、明晰语义的作用，对查询性能不会有任何增强。 物化视图：create materialized view table_name to name engine&#x3D;xxx populate as select … 支持表引擎，如果源表被写入新数据，那么物化视图也会同步更新。populate修饰符觉得初始化策略，是否连带源表中已存在的数据一并导入。 物化视图本质上是一张特殊的数据表 目前只有MergeTree、Merge、Distribute三类表引擎支持ALTER查询 RENAME可以用于移动数据表，仅限单个节点范围内 分布式DDL，只需要在DDL后面加上 ON CLUSTER cluster_name 数据写入方式： 常规：INSERT INTO table_name VALUES (xxx) 指定格式：INSERT INTO table_name FORMAT format_name data_set SELECT子语句：INSERT INTO table_name SELECT … 数据删除与修改 ClickHouse的Delete和Update能力被成为Mutation查询，它可以看做ALTER语句的变种，是一种很重的操作，不支持事务，执行是异步的后台过程，语句提交之后就会立即返回，执行进度需要通过system.mutaitons系统表查询。每执行一条ALTER DELETE语句，都会在mutations系统表中生成一条对应的执行计划。数据删除过程是以数据表的每个分区目录为单位，将所有目录重写为新的目录，新目录的命名规则是在原有名称上加上system.mutaitions.block_numbers.number。数据在重写过程中会将需要删除的数据去掉。旧的数据目录不会立即删除，而是会被标记成非激活状。等到MergeTree引擎下次合并动作触发时，这些非激活目录才会真正从物理意义上删除。 ClickHouse多种实时更新方法总结：https://www.modb.pro/db/197765 ClickHouse拥有内置和扩展两类数据字典，目前内置的只有YM字典，扩展的有7种类型，其中flat、hashed、range_hashed依次拥有最高的性能。 第三部分，原理篇分区规则，分区目录合并规则 一级索引，稀疏索引 二级索引，跳数索引 如果把MergeTree比作一本书，primary.idx一级索引就好比这本书的一级章节目录，.bin（数据存储文件）中的数据就好比这本书中的文字，.mrk（数据标记文件）会为一级章节目录和具体的文字之间建立关联。 数据TTL，分为列级别和表级别，默认合并频率1天，可以通过merge_with_ttl_timeout来控制 多路径存储策略：默认，JBOD，HOT&#x2F;COLD ReplacingMergeTree处理逻辑 1、使用ORDER BY排序键作为判断重复数据的逻辑 2、只有在合并分区的时候才会触发删除重复数据的逻辑 3、以数据分区为单位删除重复数据。当分区合并时，同一分区内的重复数据才会被删除；不同分区之间的重复数据不会被删除 4、在进行数据去重时，因为分区内的数据已经基于ORDER BY进行排序，所以能够找到那些相邻的重复数据 5、数据去重策略有两种： 如果没有设置ver版本号，则保留同一组重复数据中的最后一行 如果设置了ver版本号，则保留同一组重复数据中ver字段取值最大的那一行 如果同时声明了ORDER BY和PRIMARY KEY，MergeTree会强制要求PRIMARY KEY列字段必须是ORDER BY的前缀 SummingMergeTree处理逻辑 1、用ORDER BY排序键作为聚合数据的条件Key 2、只有在合并分区的时候才会触发汇总的逻辑 3、以数据分区为单位来聚合数据。当分区合并时，同一数据分区内聚合Key相同的数据会被合并汇总，而不同分区之间的数据则不会被汇总 4、如果在定义引擎时指定了columns汇总列（非主键的数值类型字段），则SUM汇总这些列字段，如果未指定，则聚合所有非主键的数值类型字段 5、在进行数据汇总时，同一分区内，相同聚合Key的多行数据会合并成一行。其中，汇总字段会进行SUM计算，对于那些非汇总字段，则会使用第一行数据的取值 6、支持嵌套结构，但列字段名称必须以Map后缀结尾。嵌套类型中，默认以第一个字段作为聚合Key。除第一个字段外，任何名称以Key、Id或Type为后缀结尾的字段，都将和第一个字段组成复合Key AggregatingMergeTree处理逻辑 1、用ORDER BY排序键作为聚合数据的条件Key 2、使用AggregateFunction字段类型定义聚合函数的类型以及聚合的字段 3、只有在合并分区的时候才会触发汇总的逻辑 4、以数据分区为单位来聚合数据。当分区合并时，同一数据分区内聚合Key相同的数据会被合并汇总，而不同分区之间的数据则不会被汇总 5、在进行数据计算时，因为分区内的数据已经基于ORDER BY进行排序，所以能够找到那些相邻且拥有相同聚合Key的数据 6、在聚合数据时，同一分区内，相同聚合Key的多行数据会合并成一行。对于那些非主键、非AggregateFunction类型字段，则会使用第一行数据的取值 7、AggregateFunction类型的字段使用二进制存储，在写入数据时，需要调用State函数；而在查询数据时，则需要调用相应的Merge函数。其中，*表示定义时使用的聚合函数 8、AggregatingMergeTree通常作为物化视图的表引擎，与普通MergeTree搭配使用 另外还有CollapsingMergeTree、VersionedCollapsingMergeTree、GraphiteMergeTree，以及整个MergeTree家族引擎的关系 其他常见表引擎 外部存储类型：HDFS、MySQL、JDBC、Kafka、File 内存类型：Memory、Set、Join、Buffer 日志类型：TinyLog、StripeLog、Log 接口类型：Merge、Dictionary、Distributed 其他类型：Live View、Null、URL 对于列式存储数据库，应尽量避免使用select *查询 ClickHouse支持的查询语法 12345678910111213141516[WITH expr_list|(subquery)]SELECT [DISTINCT] expr_list[FROM [db.]table | (subquery) | table_function] [FINAL][SAMPLE sample_coeff][ARRAY JOIN ...][GLOBAL] [ANY|ALL|ASOF] [INNER|LEFT|RIGHT|FULL|CROSS] [OUTER|SEMI|ANTI] JOIN (subquery)|table (ON &lt;expr_list&gt;)|(USING &lt;column_list&gt;)[PREWHERE expr][WHERE expr][GROUP BY expr_list] [WITH TOTALS][HAVING expr][ORDER BY expr_list] [WITH FILL] [FROM expr] [TO expr] [STEP expr][LIMIT [offset_value, ]n BY columns][LIMIT [n, ]m] [WITH TIES][UNION ALL ...][INTO OUTFILE filename][FORMAT format] WITH：定义变量、调用函数、定义子查询、在子查询中重复使用WITH FROM： SAMPLE：数据采样 ARRAY JOIN：支持INSERT和LEFT两种JOIN策略，同时对多个数组字段进行ARRAY JON操作时，查询的计算逻辑是按行合并而不是产生笛卡尔积 JOIN：按精度可以分为ALL、ANY、ASOF三种，按类型可以分为外连接、内连接、交叉连接三种 WHERE和PREWHERE：PREWHERE只能用于MergeTree系列引擎，它首先会读取PREWEHRE指定的列字段，用于数据过滤的条件判断。待数据过滤后再读取SELECT声明的列字段以补全其余属性。性能更高。 GROUP BY：SELECT如果声明了列字段，则只能使用聚合键包含的字段。WITH ROLLUP，WITH CUBE，WITH TOTALS三种额外汇总信息 HAVING：需要和GROUP BY同时使用，不能单独使用。在聚合计算之后实现二次过滤数据 ORDER BY：全局排序，可以通过NULL FIRST&#x2F;LAST修饰NULL值的排序 LIMIT BY：和LIMIT不同，运行于ORDER BY之后和LIMIT之前，能够按指定分组，最多返回前n行数据，常用于TOP N的查询场景 LIMIT： SELCT： DISTINCT： UNION ALL：联合左右两边的两组子查询，将结果一并返回。 Replicated前缀表引擎才能应用副本的能力，增加了zk监听的部分，通过zk存储mutaions操作日志 Distributed表引擎，本身不存储任何数据，它能够作为分布式表的一层透明代理。 多副本的路由规则，四种负载均衡算法：random、nearest_hostname，in_order、first_or_random 多分片查询的核心流程：查询各个分片数据，合并返回结果 使用Global优化分布式查询 服务监控可以从两个方面入手： 系统表：metrics、events、asynchronous_metrics 查询日志：query_log、query_thread_log、part_log、text_log、metric_log","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"数据库","slug":"数据库","permalink":"https://lchml.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"服务器","slug":"服务器","permalink":"https://lchml.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"大数据","slug":"大数据","permalink":"https://lchml.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"《卓有成效的管理者》","slug":"zycxdglz","date":"2022-12-10T16:00:00.000Z","updated":"2022-12-12T06:43:24.958Z","comments":true,"path":"book/zycxdglz/","link":"","permalink":"https://lchml.com/book/zycxdglz/","excerpt":"管理深深触及一些精神层面关切的问题——像人性的善与恶。在一个由多元的组织所构成的社会中，使我们的各种组织机构负责任地、独立自治地、高绩效地运作，是自由和尊严的唯一保障。有绩效的、负责任的管理是对抗和替代极权专制的唯一选择。","text":"管理深深触及一些精神层面关切的问题——像人性的善与恶。在一个由多元的组织所构成的社会中，使我们的各种组织机构负责任地、独立自治地、高绩效地运作，是自由和尊严的唯一保障。有绩效的、负责任的管理是对抗和替代极权专制的唯一选择。 目前看过的管理类书籍，其实内容和表达的思想都比较类似，这本书虽然是号称管理学教父的彼得德鲁克所写，但也还是并没有让人觉得眼前一亮，为之惊艳的感觉，也可能管理本身就是这样吧。 全书主要有四个重点：时间管理，重视贡献，用人之长，有效决策。个人感觉前两部分的内容更有输入，特别是重视贡献的视角，作为技术人员，有些内容颇有拨开迷雾的效果。如其中关于通才得论述：所谓“通才”，应该也是一位专家，是一位能将其所专的一个小领域与其他广大知识领域联系的专家。有少数人也许可以精通几门知识，但这并不意味着他们便是通才，他们不过是精通几门知识的专家而已。专业人员必须使他本人有效，必须使他的专才有效。他必须考虑到他的产出供什么人使用，也必须了解用户应该知道些什么才能有效使用他的产出，从而产生成果。例如关于贡献，只有外部世界才是产生成果的地方，只有重视贡献，才能使管理者的注意力不为其本身的专长所限，不为其本身的技术所限，不为其本身所属的部门所限，才能看到整体的绩效，同时也才能使他更加重视外部世界。其实不仅是管理者，在互联网这种以知识工作者为主的企业中，每个人都一样适用。特别是技术思维的同学经常掉入的陷阱，可以从这个角度改变思考方式。 本书的主题是关于如何自我管理才能成为卓有成效的管理者。 智力、想象力及知识，都是我们重要的资源。但是资源本身仅是限制性因素，只有通过管理者卓有成效的工作，才能将这些资源转化为成果。 知识工作者的工作动力，取决于他是否具有有效性及他在工作中能否有所成就。如果他的工作缺少有效性，那么他对做好工作和做出贡献的热情很快就会消退，他将成为朝九晚五在办公室消磨时间的人。 再伟大的智慧，如果不能应用在行动上，也将只是毫无意义的资料。 一位管理者，不能仅以执行命令为满足，他必须能做决策，并承担起做出贡献的责任。他既然学识渊博，就应该比其他人更能做出正确的决策。他的决定可能会被取消，他也可能被降职，甚至可能丢掉饭碗。但是，只要他有一天身为管理者，他就不能忘记他的标准、目标和贡献。 一个机构里面的管理者都必须面对四类非其本人所能控制的现实难题。每一项现实难题都在像他施加压力，使他的工作难以取得成果和绩效。（1）管理者的时间往往只属于别人，不属于自己。（2）管理者往往被迫忙于”日常运作“，除非他们敢于采取行动来改变周围一切。（3）管理者本身处于一个”组织“之中，只有当别人能够利用管理者的贡献时，管理者才算有效。（4）管理者收到组织本身的局限。一切成果都存在于组织之外。 对于管理者的有效性而言，最重要的人物，往往并不是管理者直接控制的下属，而是其他部门的人，即所谓”旁系人士“，或是管理者本人的上司。一位管理者如果不能与这些人主动接触，不能使这些人有效利用他的贡献，他本身就没有有效性可言。 一个组织绝不能像生物一样，以自身的生存为目的，仅仅把能够延续后代视作成功。组织是社会的一种器官，只有能为外部环境做出自己的贡献，才能算有所成就。但是，当组织的规模日益扩大，并且看来日益成功时，其内部的种种事务也将变得更多，这些事务将占据管理者更多的兴趣、精力和能力，使其难以顾及自己的真正任务，无法为外界提供有效的服务。 我们不能一味的拔高能力的标准来期望管理者的绩效，更不能期望万能的天才来达成绩效。我们只有通过改进工作的手段来充分发挥人的能力，而不应该寄望于人的能力突然提高。 下列5项是要成为一个卓有成效的管理者，必须在思想上养成的习惯。（1）有效的管理者知道应该将他们的时间用在什么地方。他们所能控制的时间非常有限，他们会有系统地工作，来善用这有限的时间。（2）有效的管理者重视对外界的贡献。他们并非为工作而工作，而是为成果而工作。他们不会一接到工作就一头钻进去，更不会一开头就探究工作的技术和手段，他们会首先自问：“别人期望我做出什么成果？”（3）有效的管理者善于利用长处，包括自己的长处、上司的长处、同事的长处和下属的长处。他们还善于抓住有利形势，做他们能做的事。（4）有效的管理者集中精力于少数重要的领域，在这少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。他们会按照工作的轻重缓急设定优先次序，而且坚守优先次序。（5）最后，有效的管理者必须善于做有效的决策。他们知道有效的决策事关处事的条理和秩序问题，也就是如何按正确的次序采取正确的步骤。 有效的管理者并不是一开始就着手工作，他们往往会从时间安排上着手。他们并不以计划为起点，认识清楚自己的时间用在什么地方才是起点。 每一位知识工作者，尤其是每一位管理者，要想有效就必须能将时间做整块的运用。如果将时间分割开来零星使用，纵然总时间相同，结果时间也肯定不够。 知识工作者要想取得成果和绩效，就必须着眼于整个组织的成果和绩效。换句话说，他还得匀出时间来，将目光由自己的工作转到成果上；由他的专业转到外部世界，因为只有外部世界才有绩效可言。 这样的轻松交流，不管是在政府、企业、研究机构，还是在军事单位，都同样很有必要。如果没有这样的交流，知识工作者就容易丧失热情，成为得过且过的人，或者是只关注自己的专业领域，看不到整个组织的需要和机会。 系统的时间管理1）首先要找出什么事根本不必做，这些事做了也完全是浪费时间，于最终的成果无助。2）哪些活动可以由别人代为参加而又不影响效果。3）哪些事情是在浪费别人的时间。 原则上，一位管理者的时间，绝不能让开会占用太多。会议太多，表示职位结构不当，也表示单位设置不当。会议太多，表示本应由一个职位或一个单位做的工作，分散到几个职位或几个单位去了。同时表示职责混乱以及未能将信息传递给需要的人员。 一位管理者的职位越高，其不能自行支配的时间也一定越多。组织的规模越大，其用于维系组织运行，而非用于发挥组织功能及生产的时间也一定越多。 时间是最稀有的资源。若不将时间管理好，要想管理好其他事情就只是空谈。而分析自己的时间，也是系统地分析自己的工作，鉴别工作重要性的一种方法。 管理理论中早就有所谓“管理幅度”之说。所谓管理幅度，是指一个管理者能有效地管理多少个工作上互有关联的人。 毫无疑问的是：一起工作的人数越多，工作者用于彼此协调关系的时间肯定越多，而真正用于工作的时间就越少了。因此大型组织只有在大量耗用其管理者的时间之后，才能变得强大有力。 判断人数是否过多，有一个靠得住的标准。如果一个高级管理人员，尤其是经理，不得不将他工作时间的1&#x2F;10花在处理所谓“人际关系问题”上，花在处理纠纷和摩擦上，花在处理争执和合作等问题上，那么这个单位人数就过多了。 会议太多，表示职位结构不当，也表示单位设置不当。会议太多，表示本应由一个职位或一个单位做的工作，分散到几个职位或几个单位去了。同时表示职责混乱以及未能将信息传送给需要的人员。 消除浪费时间的活动（1）首先要做的是，找出由于缺乏制度或远见而产生时间浪费的因素。（2）人员过多，也常造成时间的浪费。（3）另一个常见的浪费时间的原因，是组织不健全。其表现就是会议太多。（4）最后一项浪费时间的因素，是信息功能不健全。 有效的管理者一定注重贡献，并懂得将自己的工作与长远目标结合起来。 重视贡献是有效性的关键。所谓有效性，表现在以下三个方面：①自己的工作，包括工作内容、工作水准、工作标准及其影响；②自己与他人的关系，包括对上司、同事和下属；③各项管理手段的运用，例如会议或报告等。 重视贡献，才能使管理者的注意力不为其本身的专长所限，不为其本身的技术所限，不为其本身所属的部门所限，才能看到整体的绩效，同时也才能使他更加重视外部世界。 一位管理者能重视贡献，是人才发展最大的动力，因为人可以随外加的要求调整自己。重视贡献的管理者还可以帮助那些与他共事的人将眼光放得更远，这样也就提高了他们的工作水准。 专业人员必须使他本人有效，必须使他的专才有效。他必须考虑到他的产出供什么人使用，也必须了解用户应该知道些什么才能有效使用他的产出，从而产生成果。 所谓“通才”，应该也是一位专家，是一位能将其所专的一个小领域与其他广大知识领域联系的专家。有少数人也许可以精通几门知识，但这并不意味着他们便是通才，他们不过是精通几门知识的专家而已。 在一个组织中，管理者拥有良好的人际关系，绝不是因为他们有“与人交往的天赋”，而是因为他们在自己的工作和人际关系上都注重贡献，他们的工作也因此而富有成效，这也许是所谓“良好的人际关系”的真义所在。 有效的人际关系，有下列4项基本要求，而着眼于贡献，正可满足这些条件：互相沟通、团队合作、自我发展、培养他人 重视贡献的管理者必然会同时启发他人寻求自我发展。这样的管理者设定的标准，一定不是他个人认定的标准，而是以任务需求为基础的标准。而且，他设定的标准，一般来说要求很高，是高度的期望，是远大的目标，是具有重大冲击力的工作。 重视贡献，就是重视有效性。 为实现目标，必须用人所长——用其同事之所长、用其上级之所长和用其本身之所长。 管理者要运用人的长处，面临的第一关即在于择人。有效的管理者择人任事和升迁，都以一个人能做些什么为基础。所以，他的用人决策，不在于如何克服人的短处，而在于如何发挥人的长处。 用人应着眼于机会，而非着眼于问题，这样做不但能开创一个有效的组织，也能够激发热情和忠诚。 总结一句：用人所长是卓有成效的管理者必须具备的一种素质，是一个组织工作是否有效的关键，也是知识工作者和社会不可或缺的素质。 卓有成效的管理者还要设法充分发挥上司的长处，这也是非常重要的。 要使上司能发挥其所长，不能靠唯命是从，应该从正确的事情着手，并以上司能够接受的方式向其提出建议。 要使上司有效其实不难。问题只在于应了解上司的长处，知道上司能做些什么。只在于重视上司的长处，使其弱点不产生影响。协助上司发挥其所长，是促使管理者有效的最好方法。 管理者的任务不是去改变人。管理者的任务，在于运用每一个人的才干。 有效的管理者打算做一项新的业务时，一定要先删除一项原有的业务。这对控制组织的“膨胀”是非常必要的。“膨胀”如不加以控制，组织就会变得涣散、难以管理。社会组织恰如生物有机体，必须保持“瘦且有肌肉”的状态。 以下是几条可帮助确定优先次序的重要原则，每条都与勇气密切相关：重将来而不重过去；重视机会，不能只看到困难；选择自己的方向，而不盲从；目标要高，要有新意，不能只求安全和容易。 这就是有效决策的五个要素：（1）要确实了解问题的性质，如果问题是经常性的，那就只能通过一项建立规则或原则的决策才能解决。（2）要确实找出解决问题时必须满足的界限，换言之，应找出问题的“边界条件”。（3）仔细思考解决问题的正确方案是什么以及这些方案必须满足哪些条件，然后再考虑必要的妥协、适应及让步事项，以期该决策能被接受。（4）决策方案要同时兼顾执行措施，让决策变成可以被贯彻的行动。（5）在执行的过程中重视反馈，以印证决策的正确性及有效性。 有效的管理者会运用反面意见。只有这样，他才能避免为“似是而非”的看法所征服；他才能得到“替代方案”，以供他选择和决定；他也才能在万一决策行不通时不至于迷惘。同时，鼓励反面意见，可以启发他本人的想象力，启发与他共事者的想象力。反面意见能把“言之有理”者转化为“正确”，再把“正确”转化为“良好的决策”。 有效的管理者绝不认为某一行动方向为“对”，其他行动方向均为“错”。他也绝不坚持己见，以自己为“对”，以他人为“错”。有效的管理者第一步会先找出为什么各人有不同的意见。 全书总结：（1）要做到卓有成效，首先要做的第一步，是记录好时间的使用情况。分析时间记录以及消除不必要的时间浪费。（2）是管理者应把眼光集中在贡献上。（3）充分发挥人的长处。（4）有效的决策，重心在于合理的行动","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"},{"name":"领导力","slug":"领导力","permalink":"https://lchml.com/tags/%E9%A2%86%E5%AF%BC%E5%8A%9B/"}]},{"title":"历史中的诗人们","slug":"shiren","date":"2022-12-06T16:00:00.000Z","updated":"2022-12-12T05:47:46.392Z","comments":true,"path":"book/shiren/","link":"","permalink":"https://lchml.com/book/shiren/","excerpt":"智慧生命的精华和本质，真的是技术所无法触及的吗？ —— 刘慈欣《诗云》","text":"智慧生命的精华和本质，真的是技术所无法触及的吗？ —— 刘慈欣《诗云》 好久没手写过字了，兴之所至，把钢笔翻出来试着抄了一篇《将进酒》，生疏的不行。抄写诗词的时想到可以把历史中具有代表性的诗人诗句做个简单总结，于是就有了此文。 周《诗经》中国古代诗歌的开端，最早的一部诗歌总集，收集了西周初年至春秋中叶的诗歌 诗经名句桃之夭夭，灼灼其华。之子于归，宜其室家。——《诗经·桃夭》执子之手，与子偕老。——《诗经·击鼓》战战兢兢，如临深渊，如履薄冰。——《诗经·小旻》关关雎鸠，在河之洲。窈窕淑女，君子好逑。——《诗经·关雎》蒹葭苍苍，白露为霜。——《诗经·蒹葭》青青子衿，悠悠我心。纵我不往，子宁不嗣音。——《诗经·子衿》一日不见，如三秋兮！——《诗经·采葛》南有乔木，不可休思。 汉有游女，不可求思。——《诗经·汉广》高山仰止，景行行止。——《诗经·车舝》死生契阔，与子成说。——《诗经·击鼓》知我者，谓我心忧；不知我者，谓我何求。——《诗经·黍离》呦呦鹿鸣，食野之苹。——《诗经·鹿鸣》岂曰无衣，与子同袍。——《诗经·无衣》所谓伊人，在水一方。——《诗经·蒹葭》溥天之下，莫非王土；率土之滨，莫非王臣。——《诗经·北山》知我者，谓我心忧；不知我者，谓我何求。——《诗经·黍离》 春秋战国屈原前339年，芈姓，屈氏，名平，字原，又自云名正则，字灵均 《离骚》《九歌》名句长太息以掩涕兮，哀民生之多艰。亦余心之所善兮，虽九死其犹未悔。路曼曼其修远兮，吾将上下而求索。身既死兮神以灵，魂魄毅兮为鬼雄。与天地兮同寿，与日月兮齐光。举世皆浊我独清，众人皆醉我独醒。沧浪之水清兮，可以濯吾缨。沧浪之水浊兮，可以濯吾足。 秦汉刘邦前256年，字季 《大风歌》大风起兮云飞扬。威加海内兮归故乡。安得猛士兮守四方。 项羽前232年，名籍，字羽 《垓下歌》力拔山兮气盖世。时不利兮骓不逝。骓不逝兮可奈何。虞兮虞兮奈若何。 司马相如前179年，字长卿 《凤求凰》有一美人兮，见之不忘。一日不见兮，思之如狂。凤飞翱翔兮，四海求凰。无奈佳人兮，不在东墙。将琴代语兮，聊写衷肠。何时见许兮，慰我彷徨。愿言配德兮，携手相将。不得於飞兮，使我沦亡。凤兮凤兮归故乡，遨游四海求其凰。时未遇兮无所将，何悟今兮升斯堂。有艳淑女在闺房，室迩人遐毒我肠。何缘交颈为鸳鸯，胡颉颃兮共翱翔。凰兮凰兮从我栖，得托孳尾永为妃。交情通意心和谐，中夜相从知者谁。双翼俱起翻高飞，无感我思使余悲。 李延年西汉音乐家 《李延年歌》北方有佳人。绝世而独立。一顾倾人城。再顾倾人国。宁不知倾城与倾国。佳人难再得。 三国曹操155年，字孟德，一名吉利，小字阿瞒 《观沧海》东临碣石，以观沧海。水何澹澹，山岛竦峙。树木丛生，百草丰茂。秋风萧瑟，洪波涌起。日月之行，若出其中；星汉灿烂，若出其里。幸甚至哉，歌以咏志。 《短歌行》对酒当歌，人生几何。譬如朝露，去日苦多。慨当以慷，忧思难忘。何以解忧，唯有杜康。青青子衿，悠悠我心。但为君故，沉吟至今。呦呦鹿鸣，食野之苹。我有嘉宾，鼓瑟吹笙。明明如月，何时可掇。忧从中来，不可断绝。越陌度阡，枉用相存。契阔谈讌，心念旧恩。月明星稀，乌鹊南飞。绕树三匝，何枝可依。山不厌高，海不厌深。周公吐哺，天下归心。 诸葛亮181年，字孔明，号卧龙 《前出师表》先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必能裨补阙漏，有所广益。将军向宠，性行淑均，晓畅军事，试用于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐托付不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。今当远离，临表涕零，不知所言。 曹植192年，字子建，与曹操、曹丕并称三曹 《七步诗》煮豆持作羹，漉菽以为汁。萁在釜下燃，豆在釜中泣。本自同根生，相煎何太急。 《洛神赋》节选其形也，翩若惊鸿，婉若游龙，荣曜秋菊，华茂春松。仿佛兮若轻云之蔽月，飘颻兮若流风之回雪。远而望之，皎若太阳升朝霞；迫而察之，灼若芙蓉出渌波。 魏晋南北朝阮籍210年，字嗣宗，竹林七贤之一 《咏怀八十二首·其一》夜中不能寐，起坐弹鸣琴。薄帷鉴明月，清风吹我襟。孤鸿号外野，翔鸟鸣北林。徘徊将何见，忧思独伤心。 嵇康223年，字叔夜，竹林七贤之一 《赠秀才入军·其十四》息徒兰圃，秣马华山。流磻平皋，垂纶长川。目送归鸿，手挥五弦。俯仰自得，游心太玄。嘉彼钓翁，得鱼忘筌。郢人逝矣，谁与尽言。 陶渊明365年，名潜，字元亮，别号五柳先生，卒后私谥靖节，世称靖节先生。 《饮酒·其五》结庐在入境，而无车马喧。问君何能尔，心远地自偏。采菊东篱下，悠然见南山。山气日夕佳，飞鸟相与还。此中有真意，欲辩已忘言。 《桃花源记》晋太元中，武陵人捕鱼为业。缘溪行，忘路之远近。忽逢桃花林，夹岸数百步，中无杂树，芳草鲜美，落英缤纷。渔人甚异之。复前行，欲穷其林。林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。土地平旷，屋舍俨然，有良田美池桑竹之属。阡陌交通，鸡犬相闻。其中往来种作，男女衣着，悉如外人。黄发垂髫，并怡然自乐。见渔人，乃大惊，问所从来，具答之。便要还家，设酒杀鸡作食。村中闻有此人，咸来问讯。自云先世避秦时乱，率妻子邑人来此绝境，不复出焉，遂与外人间隔。问今是何世，乃不知有汉，无论魏晋。此人一一为具言所闻，皆叹惋。余人各复延至其家，皆出酒食。停数日，辞去。此中人语云：“不足为外人道也。”既出，得其船，便扶向路，处处志之。及郡下，诣太守，说如此。太守即遣人随其往，寻向所志，遂迷，不复得路。南阳刘子骥，高尚士也，闻之，欣然规往。未果，寻病终，后遂无问津者。 《归去来兮辞》归去来兮，田园将芜胡不归。既自以心为形役，奚惆怅而独悲。悟已往之不谏，知来者之可追。实迷途其未远，觉今是而昨非。舟遥遥以轻飏，风飘飘而吹衣。问征夫以前路，恨晨光之熹微。乃瞻衡宇，载欣载奔。僮仆欢迎，稚子候门。三径就荒，松菊犹存。携幼入室，有酒盈樽。引壶觞以自酌，眄庭柯以怡颜。倚南窗以寄傲，审容膝之易安。园日涉以成趣，门虽设而常关。策扶老以流憩，时矫首而遐观。云无心以出岫，鸟倦飞而知还。景翳翳以将入，抚孤松而盘桓。归去来兮，请息交以绝游。世与我而相违，复驾言兮焉求。悦亲戚之情话，乐琴书以消忧。农人告余以春及，将有事于西畴。或命巾车，或棹孤舟。既窈窕以寻壑，亦崎岖而经丘。木欣欣以向荣，泉涓涓而始流。善万物之得时，感吾生之行休。已矣乎！寓形宇内复几时，曷不委心任去留，胡为乎遑遑欲何之。富贵非吾愿，帝乡不可期。怀良辰以孤往，或植杖而耘耔。登东皋以舒啸，临清流而赋诗。聊乘化以归尽，乐夫天命复奚疑！ 谢眺464年，字玄晖，斋号高斋，与“大谢”谢灵运同族，世称“小谢”。因曾经担任安徽宣城的太守、尚书礼部郎，所以世人也称呼谢朓为“谢宣城”。李白最敬仰的诗人之一。 《晚登三山还望京邑》灞涘望长安，河阳视京县。白日丽飞甍，参差皆可见。余霞散成绮，澄江静如练。喧鸟覆春洲，杂英满芳甸。去矣方滞淫，怀哉罢欢宴。佳期怅何许，泪下如流霰。有情知望乡，谁能鬒不变。 隋薛道衡540年，字玄卿 《昔昔盐》垂柳覆金堤，蘼芜叶复齐。水溢芙蓉沼，花飞桃李蹊。采桑秦氏女，织锦窦家妻。关山别荡子，风月守空闺。恒敛千金笑，长垂双玉啼。盘龙随镜隐，彩凤逐帷低。飞魂同夜鹊，倦寝忆晨鸡。暗牖悬蛛网，空梁落燕泥。前年过代北，今岁往辽西。一去无消息，那能惜马蹄。 唐王勃649年，字子安，与杨炯、卢照邻、骆宾王共称“初唐四杰”。 《送杜少府之任蜀州》城阙辅三秦，风烟望五津。与君离别意，同是宦游人。海内存知己，天涯若比邻。无为在歧路，儿女共沾巾。 《滕王阁序》节选时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨，雁阵惊寒，声断衡阳之浦。 孟浩然689年 《春晓》春眠不觉晓，处处闻啼鸟。夜来风雨声，花落知多少。 王维699年，字摩诘，号摩诘居士，世称“王右丞”，因笃信佛教，有“诗佛”之称 《送元二使安西》渭城朝雨浥轻尘，客舍青青柳色新。劝君更尽一杯酒，西出阳关无故人。 《九月九日忆山东兄弟》独在异乡为异客，每逢佳节倍思亲。遥知兄弟登高处，遍插茱萸少一人。 《山居秋暝》空山新雨后，天气晚来秋。明月松间照，清泉石上流。竹喧归浣女，莲动下渔舟。随意春芳歇，王孙自可留。 《相思》&#x2F;《江上赠李龟年》红豆生南国，春来发几枝。愿君多采撷，此物最相思。 《鸟鸣涧》人闲桂花落，夜静春山空。月出惊山鸟，时鸣春涧中。 《使至塞上》单车欲问边，属国过居延。征蓬出汉塞，归雁入胡天。大漠孤烟直，长河落日圆。萧关逢候骑，都护在燕然。 李白701年，字太白，号青莲居士，又号“谪仙人”，被后人誉为“诗仙”。代表作很多，如《望庐山瀑布》《行路难》《蜀道难》《将进酒》《早发白帝城》《清平调》等。 《将进酒》君不见黄河之水天上来，奔流到海不复回。君不见高堂明镜悲白发，朝如青丝暮成雪。人生得意须尽欢，莫使金樽空对月。天生我材必有用，千金散尽还复来。烹羊宰牛且为乐，会须一饮三百杯。岑夫子，丹丘生，将进酒，杯莫停。与君歌一曲，请君为我倾耳听。钟鼓馔玉不足贵，但愿长醉不复醒。古来圣贤皆寂寞，惟有饮者留其名。陈王昔时宴平乐，斗酒十千恣欢谑。主人何为言少钱，径须沽取对君酌。五花马、千金裘，呼儿将出换美酒，与尔同销万古愁。 《望庐山瀑布》日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。 《静夜思》床前明月光，疑是地上霜。举头望明月，低头思故乡。 《早发白帝城》朝辞白帝彩云间，千里江陵一日还。两岸猿声啼不住，轻舟已过万重山。 《赠汪伦》李白乘舟将欲行，忽闻岸上踏歌声。桃花潭水深千尺，不及汪伦送我情。 《望天门山》天门中断楚江开，碧水东流至此回。两岸青山相对出，孤帆一片日边来。 《清平调》云想衣裳花想容，春风拂槛露华浓。若非群玉山头见，会向瑶台月下逢。一枝秾艳露凝香，云雨巫山枉断肠。借问汉宫谁得似，可怜飞燕倚新妆。名花倾国两相欢，长得君王带笑看。解释春风无限恨，沉香亭北倚阑干。 《黄鹤楼送孟浩然之广陵》故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，唯见长江天际流。 《月下独酌四首·其一》花间一壶酒，独酌无相亲。举杯邀明月，对影成三人。月既不解饮，影徒随我身。暂伴月将影，行乐须及春。我歌月徘徊，我舞影零乱。醒时相交欢，醉后各分散。永结无情游，相期邈云汉。 《行路难·其一》金樽清酒斗十千，玉盘珍羞直万钱。停杯投箸不能食，拔剑四顾心茫然。欲渡黄河冰塞川，将登太行雪满山。闲来垂钓碧溪上，忽复乘舟梦日边。行路难，行路难，多歧路，今安在。长风破浪会有时，直挂云帆济沧海。 《夜宿山寺》危楼高百尺，手可摘星辰。不敢高声语，恐惊天上人。 《蜀道难》噫吁嚱，危乎高哉！蜀道之难，难于上青天！蚕丛及鱼凫，开国何茫然！尔来四万八千岁，不与秦塞通人烟。西当太白有鸟道，可以横绝峨眉巅。地崩山摧壮士死，然后天梯石栈相钩连。上有六龙回日之高标，下有冲波逆折之回川。黄鹤之飞尚不得过，猿猱欲度愁攀援。青泥何盘盘，百步九折萦岩峦。扪参历井仰胁息，以手抚膺坐长叹。 问君西游何时还，畏途巉岩不可攀。但见悲鸟号古木，雄飞雌从绕林间。又闻子规啼夜月，愁空山。蜀道之难，难于上青天，使人听此凋朱颜！连峰去天不盈尺，枯松倒挂倚绝壁。飞湍瀑流争喧豗，砯崖转石万壑雷。其险也如此，嗟尔远道之人胡为乎来哉！ 剑阁峥嵘而崔嵬，一夫当关，万夫莫开。所守或匪亲，化为狼与豺。朝避猛虎，夕避长蛇；磨牙吮血，杀人如麻。锦城虽云乐，不如早还家。蜀道之难，难于上青天，侧身西望长咨嗟！ 《古朗月行》小时不识月，呼作白玉盘。又疑瑶台镜，飞在青云端。仙人垂两足，桂树何团团。白兔捣药成，问言与谁餐。蟾蜍蚀圆影，大明夜已残。羿昔落九乌，天人清且安。阴精此沦惑，去去不足观。忧来其如何，凄怆摧心肝。 《登金陵凤凰台》凤凰台上凤凰游，凤去台空江自流。吴宫花草埋幽径，晋代衣冠成古丘。三山半落青天外，二水中分白鹭洲。总为浮云能蔽日，长安不见使人愁。 《宣州谢朓楼饯别校书叔云》弃我去者，昨日之日不可留；乱我心者，今日之日多烦忧。长风万里送秋雁，对此可以酣高楼。蓬莱文章建安骨，中间小谢又清发。俱怀逸兴壮思飞，欲上青天览明月。抽刀断水水更流，举杯消愁愁更愁。人生在世不称意，明朝散发弄扁舟。 《南陵别儿童入京》白酒新熟山中归，黄鸡啄黍秋正肥。呼童烹鸡酌白酒，儿女嬉笑牵人衣。高歌取醉欲自慰，起舞落日争光辉。游说万乘苦不早，著鞭跨马涉远道。会稽愚妇轻买臣，余亦辞家西入秦。仰天大笑出门去，我辈岂是蓬蒿人。 《侠客行》赵客缦胡缨，吴钩霜雪明。银鞍照白马，飒沓如流星。十步杀一人，千里不留行。事了拂衣去，深藏身与名。闲过信陵饮，脱剑膝前横。将炙啖朱亥，持觞劝侯嬴。三杯吐然诺，五岳倒为轻。眼花耳热后，意气素霓生。救赵挥金槌，邯郸先震惊。千秋二壮士，烜赫大梁城。纵死侠骨香，不惭世上英。谁能书阁下，白首太玄经。 杜甫712年，字子美，自号少陵野老，世称杜工部、杜少陵等，被后人誉为“诗圣”。 《春望》国破山河在，城春草木深。感时花溅泪，恨别鸟惊心。烽火连三月，家书抵万金。白头搔更短，浑欲不胜簪。 《登高》风急天高猿啸哀，渚清沙白鸟飞回。无边落木萧萧下，不尽长江滚滚来。万里悲秋常作客，百年多病独登台。艰难苦恨繁霜鬓，潦倒新停浊酒杯。 《春夜喜雨》好雨知时节，当春乃发生。随风潜入夜，润物细无声。野径云俱黑，江船火独明。晓看红湿处，花重锦官城。 《望岳》岱宗夫如何，齐鲁青未了。造化钟神秀，阴阳割昏晓。荡胸生曾云，决眦入归鸟。会当凌绝顶，一览众山小。 《蜀相》丞相祠堂何处寻，锦官城外柏森森。映阶碧草自春色，隔叶黄鹂空好音。三顾频烦天下计，两朝开济老臣心。出师未捷身先死，长使英雄泪满襟。 白居易772年，字乐天，晚年号香山居士，又号醉吟先生，唐代三大诗人之一 《钱塘湖春行》孤山寺北贾亭西，水面初平云脚低。几处早莺争暖树，谁家新燕啄春泥。乱花渐欲迷人眼，浅草才能没马蹄。最爱湖东行不足，绿杨阴里白沙堤。 《草》离离原上草，一岁一枯荣。野火烧不尽，春风吹又生。远芳侵古道，晴翠接荒城。又送王孙去，萋萋满别情。 《长恨歌》汉皇重色思倾国，御宇多年求不得。杨家有女初长成，养在深闺人未识。天生丽质难自弃，一朝选在君王侧。回眸一笑百媚生，六宫粉黛无颜色。春寒赐浴华清池，温泉水滑洗凝脂。侍儿扶起娇无力，始是新承恩泽时。云鬓花颜金步摇，芙蓉帐暖度春宵。春宵苦短日高起，从此君王不早朝。承欢侍宴无闲暇，春从春游夜专夜。后宫佳丽三千人，三千宠爱在一身。金屋妆成娇侍夜，玉楼宴罢醉和春。姊妹弟兄皆列土，可怜光彩生门户。遂令天下父母心，不重生男重生女。骊宫高处入青云，仙乐风飘处处闻。缓歌慢舞凝丝竹，尽日君王看不足。渔阳鼙鼓动地来，惊破霓裳羽衣曲。九重城阙烟尘生，千乘万骑西南行。翠华摇摇行复止，西出都门百余里。六军不发无奈何，宛转蛾眉马前死。花钿委地无人收，翠翘金雀玉搔头。君王掩面救不得，回看血泪相和流。黄埃散漫风萧索，云栈萦纡登剑阁。峨嵋山下少人行，旌旗无光日色薄。蜀江水碧蜀山青，圣主朝朝暮暮情。行宫见月伤心色，夜雨闻铃肠断声。天旋地转回龙驭，到此踌躇不能去。马嵬坡下泥土中，不见玉颜空死处。君臣相顾尽沾衣，东望都门信马归。归来池苑皆依旧，太液芙蓉未央柳。芙蓉如面柳如眉，对此如何不泪垂。春风桃李花开夜，秋雨梧桐叶落时。西宫南苑多秋草，落叶满阶红不扫。梨园弟子白发新，椒房阿监青娥老。夕殿萤飞思悄然，孤灯挑尽未成眠。迟迟钟鼓初长夜，耿耿星河欲曙天。鸳鸯瓦冷霜华重，翡翠衾寒谁与共。悠悠生死别经年，魂魄不曾来入梦。临邛道士鸿都客，能以精诚致魂魄。为感君王辗转思，遂教方士殷勤觅。排空驭气奔如电，升天入地求之遍。上穷碧落下黄泉，两处茫茫皆不见。忽闻海上有仙山，山在虚无缥渺间。楼阁玲珑五云起，其中绰约多仙子。中有一人字太真，雪肤花貌参差是。金阙西厢叩玉扃，转教小玉报双成。闻道汉家天子使，九华帐里梦魂惊。揽衣推枕起徘徊，珠箔银屏迤逦开。云鬓半偏新睡觉，花冠不整下堂来。风吹仙袂飘飖举，犹似霓裳羽衣舞。玉容寂寞泪阑干，梨花一枝春带雨。含情凝睇谢君王，一别音容两渺茫。昭阳殿里恩爱绝，蓬莱宫中日月长。回头下望人寰处，不见长安见尘雾。惟将旧物表深情，钿合金钗寄将去。钗留一股合一扇，钗擘黄金合分钿。但令心似金钿坚，天上人间会相见。临别殷勤重寄词，词中有誓两心知。七月七日长生殿，夜半无人私语时。在天愿作比翼鸟，在地愿为连理枝。天长地久有时尽，此恨绵绵无绝期。 《琵琶行》节选浔阳江头夜送客，枫叶荻花秋瑟瑟。主人下马客在船，举酒欲饮无管弦。醉不成欢惨将别，别时茫茫江浸月。忽闻水上琵琶声，主人忘归客不发。寻声暗问弹者谁，琵琶声停欲语迟。移船相近邀相见，添酒回灯重开宴。千呼万唤始出来，犹抱琵琶半遮面。 《忆江南词三首》江南好，风景旧曾谙；日出江花红胜火，春来江水绿如蓝。能不忆江南？江南忆，最忆是杭州；山寺月中寻桂子，郡亭枕上看潮头。何日更重游！江南忆，其次忆吴宫；吴酒一杯春竹叶，吴娃双舞醉芙蓉。早晚复相逢！ 刘禹锡772年，字梦得 ，晚年自号庐山人 《陋室铭》山不在高，有仙则名。水不在深，有龙则灵。斯是陋室，惟吾德馨。苔痕上阶绿，草色入帘青。谈笑有鸿儒，往来无白丁。可以调素琴，阅金经。无丝竹之乱耳，无案牍之劳形。南阳诸葛庐，西蜀子云亭。孔子云：何陋之有？ 《酬乐天扬州初逢席上见赠》巴山楚水凄凉地，二十三年弃置身。怀旧空吟闻笛赋，到乡翻似烂柯人。沉舟侧畔千帆过，病树前头万木春。今日听君歌一曲，暂凭杯酒长精神。 《乌衣巷》朱雀桥边野草花，乌衣巷口夕阳斜。旧时王谢堂前燕，飞入寻常百姓家。 柳宗元773年，字子厚 《江雪》千山鸟飞绝，万径人踪灭。孤舟蓑笠翁，独钓寒江雪。 《捕蛇者说》节选永州之野产异蛇：黑质而白章，触草木尽死；以啮人，无御之者。然得而腊之以为饵，可以已大风、挛踠、瘘疠，去死肌，杀三虫。其始太医以王命聚之，岁赋其二。募有能捕之者，当其租入。永之人争奔走焉。 李商隐813年，字义山，号玉溪生 《夜雨寄北》君问归期未有期，巴山夜雨涨秋池。何当共剪西窗烛，却话巴山夜雨时。 《无题·相见时难别亦难》相见时难别亦难，东风无力百花残。春蚕到死丝方尽，蜡炬成灰泪始干。晓镜但愁云鬓改，夜吟应觉月光寒。蓬山此去无多路，青鸟殷勤为探看。 《锦瑟》锦瑟无端五十弦，一弦一柱思华年。庄生晓梦迷蝴蝶，望帝春心托杜鹃。沧海月明珠有泪，蓝田日暖玉生烟。此情可待成追忆，只是当时已惘然。 《乐游原》向晚意不适，驱车登古原。夕阳无限好，只是近黄昏。 《贾生》宣室求贤访逐臣，贾生才调更无伦。可怜夜半虚前席，不问苍生问鬼神。 《无题·昨夜星辰昨夜风》昨夜星辰昨夜风，画楼西畔桂堂东。身无彩凤双飞翼，心有灵犀一点通。隔座送钩春酒暖，分曹射覆蜡灯红。嗟余听鼓应官去，走马兰台类转蓬。 《无题·飒飒东风细雨来》飒飒东风细雨来，芙蓉塘外有轻雷。金蟾啮锁烧香入，玉虎牵丝汲井回。贾氏窥帘韩掾少，宓妃留枕魏王才。春心莫共花争发，一寸相思一寸灰！ 五代十国李煜961年，五代十国时南唐国君，字重光，初名从嘉，号钟隐、莲峰居士 《虞美人·春花秋月何时了》春花秋月何时了，往事知多少。小楼昨夜又东风，故国不堪回首月明中。雕栏玉砌应犹在，只是朱颜改。问君能有几多愁，恰似一江春水向东流。 《相见欢·无言独上西楼》无言独上西楼，月如钩。寂寞梧桐深院锁清秋。剪不断，理还乱，是离愁，别是一般滋味在心头。 《相见欢·林花谢了春红》林花谢了春红，太匆匆。无奈朝来寒雨晚来风。胭脂泪，相留醉，几时重。自是人生长恨水长东。 《浪淘沙令·帘外雨潺潺》帘外雨潺潺，春意阑珊。罗衾不耐五更寒。梦里不知身是客，一晌贪欢。独自莫凭栏，无限江山，别时容易见时难。流水落花春去也，天上人间。 《长相思·一重山》一重山，两重山。山远天高烟水寒，相思枫叶丹。菊花开，菊花残。塞雁高飞人未还，一帘风月闲。 《破阵子·四十年来家国》四十年来家国，三千里地山河。凤阁龙楼连霄汉，玉树琼枝作烟萝，几曾识干戈。一旦归为臣虏，沈腰潘鬓消磨。最是仓皇辞庙日，教坊犹奏别离歌，垂泪对宫娥。 宋林逋967年，字君复，后人称为和靖先生、林和靖，林逋隐居西湖孤山，终生不仕不娶，惟喜植梅养鹤，自谓 “以梅为妻，以鹤为子”，人称“梅妻鹤子”。 《山园小梅·其一》众芳摇落独暄妍，占尽风情向小园。疏影横斜水清浅，暗香浮动月黄昏。霜禽欲下先偷眼，粉蝶如知合断魂。幸有微吟可相狎，不须檀板共金樽。 苏轼1037年，字子瞻，号“东坡居士”，世称“苏东坡”。 《水调歌头》明月几时有，把酒问青天。不知天上宫阙，今夕是何年。我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间。转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆。人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。 《念奴娇·赤壁怀古》大江东去，浪淘尽，千古风流人物。故垒西边，人道是，三国周郎赤壁。乱石穿空，惊涛拍岸，卷起千堆雪。江山如画，一时多少豪杰。遥想公瑾当年，小乔初嫁了，雄姿英发。羽扇纶巾，谈笑间，樯橹灰飞烟灭。故国神游，多情应笑我，早生华发。人生如梦，一尊还酹江月。 《饮湖上初晴后雨二首·其二》水光潋滟晴方好，山色空蒙雨亦奇。欲把西湖比西子，淡妆浓抹总相宜。 《题西林壁》横看成岭侧成峰，远近高低各不同。不识庐山真面目，只缘身在此山中。 《江城子·密州出猎》老夫聊发少年狂，左牵黄，右擎苍，锦帽貂裘，千骑卷平冈。为报倾城随太守，亲射虎，看孙郎。酒酣胸胆尚开张，鬓微霜，又何妨！持节云中，何日遣冯唐？会挽雕弓如满月，西北望，射天狼。 《赤壁赋》壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。 于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉，余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。 于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉，余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。 苏子愀然，正襟危坐而问客曰：“何为其然也？”客曰：“月明星稀，乌鹊南飞，此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。” 苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎!且夫天地之间，物各有主,苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。” 客喜而笑，洗盏更酌。肴核既尽，杯盘狼籍。相与枕藉乎舟中，不知东方之既白。 《江城子·乙卯正月二十日夜记梦》十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。 《六月二十七日望湖楼醉书》黑云翻墨未遮山，白雨跳珠乱入船。卷地风来忽吹散，望湖楼下水如天。 《定风波·莫听穿林打叶声》三月七日，沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉。已而遂晴，故作此词。莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。 《蝶恋花·春景》花褪残红青杏小。燕子飞时，绿水人家绕。枝上柳绵吹又少。天涯何处无芳草。墙里秋千墙外道。墙外行人，墙里佳人笑。笑渐不闻声渐悄。多情却被无情恼。 《食荔枝》罗浮山下四时春，卢橘杨梅次第新。日啖荔枝三百颗，不辞长作岭南人。 《春宵》春宵一刻值千金，花有清香月有阴。歌管楼台声细细，秋千院落夜沉沉。 《望江南·超然台作》春未老，风细柳斜斜。试上超然台上望，半壕春水一城花。烟雨暗千家。寒食后，酒醒却咨嗟。休对故人思故国，且将新火试新茶。诗酒趁年华。 李清照1084年，号易安居士，有“千古第一才女”之称 《声声慢》寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，最难将息。三杯两盏淡酒，怎敌他，晚来风急。雁过也，正伤心，却是旧时相识。满地黄花堆积，憔悴损，如今有谁堪摘。守着窗儿，独自怎生得黑。梧桐更兼细雨，到黄昏、点点滴滴。这次第，怎一个愁字了得。 《一剪梅》红藕香残玉簟秋。轻解罗裳，独上兰舟。云中谁寄锦书来，雁字回时，月满西楼。花自飘零水自流。一种相思，两处闲愁。此情无计可消除，才下眉头，却上心头。 《夏日绝句》生当作人杰，死亦为鬼雄。至今思项羽，不肯过江东。 《武陵春·春晚》风住尘香花已尽，日晚倦梳头。物是人非事事休，欲语泪先流。闻说双溪春尚好，也拟泛轻舟。只恐双溪舴艋舟，载不动许多愁。 《醉花阴》薄雾浓云愁永昼，瑞脑销金兽。佳节又重阳，玉枕纱厨，半夜凉初透。东篱把酒黄昏后，有暗香盈袖。莫道不销魂，帘卷西风，人比黄花瘦。 《如梦令》昨夜雨疏风骤，浓睡不消残酒。试问卷帘人，却道海棠依旧。知否，知否？应是绿肥红瘦。 《点绛唇·闺思》寂寞深闺，柔肠一寸愁千缕。惜春春去。几点催花雨。倚遍阑干，只是无情绪。人何处。连天衰草，望断归来路。 陆游1125年，字务观，号放翁 《卜算子·咏梅》驿外断桥边，寂寞开无主。已是黄昏独自愁，更着风和雨。无意苦争春，一任群芳妒。零落成泥碾作尘，只有香如故。 《示儿》死去元知万事空，但悲不见九州同。王师北定中原日，家祭无忘告乃翁。 《游山西村》莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。 《冬夜读书示子聿》古人学问无遗力，少壮工夫老始成。纸上得来终觉浅，绝知此事要躬行。 《秋夜将晓出篱门迎凉有感二首·其二》三万里河东入海，五千仞岳上摩天。遗民泪尽胡尘里，南望王师又一年。 《临安春雨初霁》世味年来薄似纱，谁令骑马客京华。小楼一夜听春雨，深巷明朝卖杏花。矮纸斜行闲作草，晴窗细乳戏分茶。素衣莫起风尘叹，犹及清明可到家。 辛弃疾1140年，原字坦夫，改字幼安，别号稼轩 《青玉案·元夕》东风夜放花千树。更吹落、星如雨。宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。蛾儿雪柳黄金缕。笑语盈盈暗香去。众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。 《西江月·夜行黄沙道中》明月别枝惊鹊，清风半夜鸣蝉。稻花香里说丰年，听取蛙声一片。七八个星天外，两三点雨山前。旧时茅店社林边，路转溪桥忽见。 《破阵子·为陈同甫赋壮词以寄之》醉里挑灯看剑，梦回吹角连营。八百里分麾下炙，五十弦翻塞外声，沙场秋点兵。马作的卢飞快，弓如霹雳弦惊。了却君王天下事，赢得生前身后名。可怜白发生！ 《南乡子·登京口北固亭有怀》何处望神州？满眼风光北固楼。千古兴亡多少事？悠悠。不尽长江滚滚流。年少万兜鍪，坐断东南战未休。天下英雄谁敌手？曹刘。生子当如孙仲谋。 《永遇乐·京口北固亭怀古》千古江山，英雄无觅孙仲谋处。舞榭歌台，风流总被雨打风吹去。斜阳草树，寻常巷陌，人道寄奴曾住。想当年，金戈铁马，气吞万里如虎。元嘉草草，封狼居胥，赢得仓皇北顾。四十三年，望中犹记，烽火扬州路。可堪回首，佛狸祠下，一片神鸦社鼓。凭谁问，廉颇老矣，尚能饭否？ 《丑奴儿·书博山道中壁》少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。而今识尽愁滋味，欲说还休。欲说还休，却道天凉好个秋。 文天祥1236年，字履善，又字宋瑞，自号文山，浮休道人 《过零丁洋》辛苦遭逢起一经，干戈寥落四周星。山河破碎风飘絮，身世浮沉雨打萍。惶恐滩头说惶恐，零丁洋里叹零丁。人生自古谁无死，留取丹心照汗青。 元马致远1264年，字千里，一说字致远，号东篱 《天净沙·秋思》枯藤老树昏鸦，小桥流水人家，古道西风瘦马。夕阳西下，断肠人在天涯。 张养浩1270年，字希孟，号云庄，又称齐东野人 《山坡羊·潼关怀古》峰峦如聚，波涛如怒，山河表里潼关路。望西都，意踌躇。伤心秦汉经行处，宫阙万间都做了土。兴，百姓苦；亡，百姓苦。 《山坡羊·骊山怀古》骊山四顾，阿房一炬，当时奢侈今何处？只见草萧疏，水萦纡。至今遗恨迷烟树。列国周齐秦汉楚，赢，都变做了土；输，都变做了土。 明刘基1311年，字伯温，谥曰文成 《卖柑者言》节选盗起而不知御，民困而不知救，吏奸而不知禁，法斁而不知理，坐糜廪粟而不知耻。观其坐高堂，骑大马，醉醇醴而饫肥鲜者，孰不巍巍乎可畏，赫赫乎可象也？又何往而不金玉其外，败絮其中也哉？今子是之不察，而以察吾柑！ 于谦1398年，字廷益，号节庵 《石灰吟》千锤万凿出深山，烈火焚烧若等闲。粉骨碎身浑不怕，要留清白在人间。 唐寅1470年，字伯虎，一字子畏，号六如居士、桃花庵主、鲁国唐生、逃禅仙吏等，与祝允明、文征明、徐祯卿并称“江南四大才子” 《桃花庵歌》桃花坞里桃花庵，桃花庵里桃花仙。桃花仙人种桃树，又摘桃花卖酒钱。酒醒只在花前坐，酒醉还来花下眠。半醒半醉日复日，花落花开年复年。但愿老死花酒间，不愿鞠躬车马前。车尘马足富者趣，酒盏花枝贫者缘。若将富贵比贫贱，一在平地一在天。若将贫贱比车马，他得驱驰我得闲。别人笑我太疯癫，我笑他人看不穿。不见五陵豪杰墓，无花无酒锄作田。 杨慎1488年，字用修，号升庵，后因流放滇南，故自称博南山人、金马碧鸡老兵，明代三大才子（解缙、徐渭）之首。 《临江仙·滚滚长江东逝水》滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。 清王士祯1634年，原名王士禛，字子真、贻上，号阮亭，又号渔洋山人，人称王渔洋，谥文简。 《题秋江独钓图》一蓑一笠一扁舟，一丈丝纶一寸钩。一曲高歌一樽酒，一人独钓一江秋。 《江上》吴头楚尾路如何？烟雨秋深暗自波。晚趁寒潮渡江去，满林黄叶雁声多。 查慎行1650年，初名嗣琏，字夏重，号查田；后改名慎行，字悔余，号他山，赐号烟波钓徒，晚年居于初白庵，所以又称查初白。当代著名作家金庸先祖。 《舟夜书所见》月黑见渔灯，孤光一点萤。微微风簇浪，散作满河星。 纪昀1724年，字晓岚，一字春帆，晚号石云，道号观弈道人。 《富春至严陵山水甚佳》浓似春云淡似烟，参差绿到大江边。斜阳流水推篷坐，翠色随人欲上船。 龚自珍1792年 《己亥杂诗·其五》浩荡离愁白日斜，吟鞭东指即天涯。落红不是无情物，化作春泥更护花。 《己亥杂诗·其二百二十》》九州生气恃风雷，万马齐喑究可哀。我劝天公重抖擞，不拘一格降人材。 《咏史》金粉东南十五州，万重恩怨属名流。牢盆狎客操全算，团扇才人踞上游。避席畏闻文字狱，著书都为稻粱谋。田横五百人安在，难道归来尽列侯。 《漫感》绝域从军计惘然，东南幽恨满词笺。一箫一剑平生意，负尽狂名十五年。 民国鲁迅1881年，原名周樟寿，1898年改名为周树人，笔名鲁迅，字豫山、豫亭，后改名为豫才。 《自嘲》运交华盖欲何求，未敢翻身已碰头。破帽遮颜过闹市，漏船载酒泛中流。横眉冷对千夫指，俯首甘为孺子牛。躲进小楼成一统，管他冬夏与春秋。 《自题小像》灵台无计逃神矢，风雨如磐暗故园。寄意寒星荃不察，我以我血荐轩辕。 当代海子1964年，原名查海生，中国新诗史上最有影响力的诗人之一。 《面朝大海，春暖花开》从明天起，做一个幸福的人喂马，劈柴，周游世界从明天起，关心粮食和蔬菜我有一所房子，面朝大海，春暖花开 从明天起，和每一个亲人通信告诉他们我的幸福那幸福的闪电告诉我的我将告诉每一个人 给每一条河每一座山取一个温暖的名字陌生人，我也为你祝福愿你有一个灿烂的前程愿你有情人终成眷属愿你在尘世获得幸福我只愿面朝大海，春暖花开","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"诗词","slug":"诗词","permalink":"https://lchml.com/tags/%E8%AF%97%E8%AF%8D/"}]},{"title":"《人间杭州》","slug":"rjhz","date":"2022-11-29T16:00:00.000Z","updated":"2022-12-06T08:58:51.926Z","comments":true,"path":"book/rjhz/","link":"","permalink":"https://lchml.com/book/rjhz/","excerpt":"阅读一座城市的历史，会让人获得另一种时间感，你可以从任何一个段落回忆过往或眺望未来。如果你恰巧是一个正生活在这里的人，城市的历史将让你产生身不由己的连接。","text":"阅读一座城市的历史，会让人获得另一种时间感，你可以从任何一个段落回忆过往或眺望未来。如果你恰巧是一个正生活在这里的人，城市的历史将让你产生身不由己的连接。 读后感多年前杭州专门因为G20推出了《杭州简史》一书，当时看完觉得颇有收获。这次看到微信读书推荐的《人间杭州》马上就有了兴趣，作者是著名的财经作家吴晓波，代表作《激荡三十年》很多人可能都听过。这本书跳出作者一贯的商业视角，而是以人文角度，以杭州的人角度在感受和体会这座城市。看书的时候，你可能会发出很多“哦，原来是这样啊”的感叹。 原来在遥远的夏商周时期，杭州还隶属属于天下九州之一的扬州。原来余杭是来源于“禹杭”。原来如今房价上天的滨江西兴街道正是当年吴越争霸，范蠡送西施入吴的渡口。原来钱唐之名自秦才有。原来是慧理和尚给第一次杭州注入了城市灵魂“灵隐”。原来西湖最早叫钱塘湖，是东汉时兴修水利，从钱塘江隔出的一个泻湖，而曲院风荷最早是人们酿酒的地方。原来日本的茶道是源自径山寺。原来西湖的名字是白居易起的，而如今的白堤其实不是白居易的白堤。原来钱镠的吴越王是灭唐的朱温封的。原来钱学森、钱伟长都是钱镠的后人，钱家是杭州的千年士族。原来三潭印月是苏轼担心人们围湖造田，侵占湖面才造的。原来葱包桧儿这名字还和秦桧有关。原来易安居士李清照在西湖边的马塍路住了二十年却过眼西湖无一句。原来马可波罗游记中提到最多的城市就是杭州。原来雷峰塔是被倭寇焚毁的。原来灵隐寺里的云林禅寺，是因为康熙写错了字。原来毛泽东在西子宾馆住了五百多天。原来是王国平决定拆除环西湖的政府机构，免费开放西湖，实现了“还湖于民”。原来杭州是一座属于平民的城市。 摘录每个城市都有很多灵魂 松木场，明清的时候，这里是秋决犯人的刑场。 金祝路，1130年，元兵进入临安的时候，城里有军民反抗，带头的是两个叫金胜和祝威的下级军尉，为了纪念他们，杭州人建了一个义士祠，它早就不见了，就留下了一个路名。 马塍chéng路，是吴越国时候，钱镠养军马的地方，南宋时是一个热闹的花市。 李清照在马塍路住了二十多年，没有为西湖写下一句诗词。 坝子桥，是京杭大运河最南端的标志之一。 任何一座城市，与其说存在于空间，不如说存在于时间，而时间本无意义，仅仅因为灵魂们的出没而得以呈现不同的叙述价值。 从一千多年前至今，杭州就一直是一座属于新型中产阶级的消费型城市，自然的美好风景、复杂的人文历史与商业的繁荣天衣无缝的交融在一起。 史学界有一个常识，作为四大古老文明之一的华夏文明起源于黄河流域，历史约为3000年。然而，近数十年来，长江中上游的三星堆和下游良渚文明的发现，让这一常识面临致命的挑战。 这个时候，如果良渚王向西眺望，穿越到7000公里之外，他会在幼发拉底河下游的一个河谷“看见”另外一座城市的存在。在西方文明史上，它被叫作乌鲁克，是人类历史上的“城市之母”。 古书《说文》中解释“杭”，只有很简洁的一句话：“杭，渡也。”把这个字解开来，左边是个“木”，右边是个“亢”。“亢”字很古老，在甲骨文里就有了，指的是人的咽喉。 到1350年，画家黄公望在六张宣纸上画了一幅约七米长的山水长卷《富春山居图》，这可能是中国最著名的山水画了。此画数百年间被人巧取豪夺，到1949年，一分为二，半截藏在台北，半截留于大陆，竟成了两岸分离的一个沉默的见证者。 治水既成，大禹部落的统治疆域也就逐渐形成了。约公元前2070年，禹受禅让为帝，建立夏朝，定都阳城。 大禹把天下分为九州，基本上确立了以后2000年华夏帝国的治理空间，其中的很多名称至今仍在使用，比如豫、冀、扬、荆等。今日杭州所在的区域地处王朝的东南隅，隶属于扬州。 大禹去会稽山，必须要经过钱塘江，传说他至此造舟以渡，就留下一个地名，叫“禹杭”，千百年后，口语相传，讹“禹”为“余”，是为“余杭”。 夏、商、周三朝，杭地都属扬州管辖。 春秋时期，天下诸侯攻伐，杭地的北面是吴，国都在苏州，东南面是越，国都在会稽。钱塘江是越国的天然屏障，江南的渡口是西兴[8]，江北的渡口是柳浦[9]。公元前6世纪，吴越争霸，打了二十多年。 （其实吴国是晋国小弟，越国是楚国小弟，打得是代理人战争，越国虽然赢了吴国，但最后大哥楚国翻脸，被吞并） 今日杭城东南有一个小山脉，据传当年为吴国的西部边境，迄今叫吴山。山上为传奇的吴国大臣伍子胥建了一个子胥祠，还把他封为钱塘潮的“潮神”。由此看来，杭人还是跟苏州人更亲近一些。 因钱塘江多次改道及围垦，今天的西兴古镇距离江面已有四公里之远。 秦推行郡县制，杭地属会稽郡，从此有了一个县名，叫钱唐。 公元前210年的十月，它又迎来了一个堪比帝禹的大人物，那就是秦始皇。 始皇此次莅临，在杭州留下了一处遗迹，便是宝石山麓的“始皇缆船石”，据传他在附近泊舟，系缆绳于一块大石头上。 在唐代之前，西湖还没有被白居易和苏东坡们点化，并不出名，甚至连西湖这个名词都没有出现。而灵隐寺则已经声名远播了，它可以说是杭州的第一个文化核心。 种下灵隐这颗文化种子的，是一位叫慧理的和尚。 他是在东晋咸和初年（326年）来到东土，由中原云游南下，328年，到了钱唐的武林山。他望着一座奇石独秀的山峰叹了一口气，说了一句话。 此乃中天竺国灵鹫山一小岭，不知何时飞来？佛在世日，多为仙灵所隐。 而慧理五刹的修建，则打造出一个至高无上的文化地标，从此，这座城市有了灵魂，古杭州正式进入中国文化地理史的叙述范畴。 南朝四百八十寺，多少楼台烟雨中。 据传，慧理当年经常晏坐在龙泓洞口的一块岩石上冥思，后人称之为理公岩。人们又在岩上建了一座高约八米、六面七层的理公塔。 东汉时期，时人兴修水利，从宝石山至万松岭修筑了一条海塘，从此出现了一片与江海隔断的泻湖。这便是日后滋润杭州千年的西湖。因为它是从钱塘江隔绝出来的，就被叫作钱塘湖。很长的时间里，农民在湖里种植茭莲，在水浅的地方围湖造田，湖水用来饮用和酿酒。“西湖十景”之一的曲院风荷，“曲”字原为“麯”，便是酿米酒的地方。 到了天下纷乱的三国，东吴割据江南约半个世纪，国主孙权一族出身钱唐附近的富春县。今天富阳龙门古镇的居民，仍以孙氏后裔自居。 3世纪末至4世纪初，统一了三国的晋朝爆发“八王之乱”，匈奴趁机内侵，北方陷入空前的兵祸。317年，士人大族“衣冠南渡”，在金陵另建汉人政权，是为东晋。在中华史上，这一事件是中国文化重心由北南迁的转折性时刻。 从东晋到之后的南朝四代——宋、齐、梁、陈，270余年，钱塘江北岸的人口渐渐增加。549年，梁武帝升钱唐县为临江郡——相当于现在的地级市，这是钱唐升级郡治之始。587年，取代梁朝的陈朝又将这里改为钱唐郡，郡治就在钱唐县。 如果杭州有所谓的“城市性格”，它是由“人间佛风”“人文西湖”“偏安岁月”和“运河商流”这四个元素构成的。佛禅是灵魂，西湖是筋骨，偏安是个性，商流是皮肉，它们在不同的时代以各自戏剧性的方式生成，从而塑造了每一个生活在这个世俗空间里的人。 东晋之后的南朝时期，佛学极度昌盛，所谓“南朝四百八十寺，多少楼台烟雨中”，杭州与金陵正是当时香火最为旺盛的城市。 当时，圆尔辨圆、南浦昭明等日本僧人远渡来径山学禅。归国后，他们带回的中国茶经典籍及径山茶具，日后演化为“日本茶道” 近代史上最后一位传奇的杭州僧人是李叔同。这位风流绝代的津门才子，在33岁的时候到杭州当音乐和绘画教师，38岁时（1918年）在虎跑寺剃度出家，法号弘一法师。1942年，弘一圆寂于泉州，骨灰迁回虎跑寺修建舍利塔。 这种可有可无的角色，倒给了杭州一个意外的安全性。所以，后来即便筑起了城墙，也不够高不够厚，根本经不起战车和掷石机的猛烈冲击。每一次的改朝换代，杭州都是被“顺便”占领的城池，而大多数的场面是“稍事抵抗、主动投降”。 第一件事：589年（开皇九年），隋文帝杨坚进行行政区划改革，把州、郡、县三级更改为州、县两级，全国共有241个州，其中之一为杭州，下辖钱唐、余杭、富阳、盐官、于潜、武康六个县。这是“杭州”之名的第一次出现。 第二件事：590年，会稽人高智慧起兵造反，大将军杨素东征平叛，它一开始是一个驻扎军队的军事性城堡，建成之后，钱唐县的行政治所就从灵隐山迁到了此处，这便是日后杭州城的雏形。杭州从此进入了漫长的凤凰山时代。 第三件事：610年（大业六年），隋炀帝杨广下令开凿贯穿南北的大运河，以洛阳为中心，北部起点为涿郡[18]，南部终点就在钱塘江边的杭州。 这是一个决定了杭州命运的工程。可以说，没有大运河，就肯定不会有后来的杭州城。 运河对杭州的第一个也是最显著的改造，是城市的功能和格局。城内出现了十多个以桥梁为中心的商埠区，比如拱宸桥、大关、小河、湖墅、观音关和七贤弄等。 如果没有运河，就没有杭州 有两位刺史则在建城史上无法绕过去，一是李泌，一是白居易，而他们的治杭时间都在安史之乱以后的中晚唐。 当时杭州城外西面的那片湖水，官方文牒中的名称为钱塘湖，是白居易第一次在诗歌中以“西湖”称之。在这个意义上，他是“西湖”的定名人和重新发现者。 据考证，白公所筑之堤，在钱塘门外，自东往西，经昭庆寺（今天的少年宫）前，直至宝石山麓。后世，此堤与内陆相连，不复存在。人们便把附近的白沙堤定名为白堤。 朱温称帝之后，拿着王爵笼络各地桀骜不驯的节度使，他把东南一片当作顺水人情割给了钱镠，封吴越王。923年，钱镠在杭州设置百官，建吴越国，下辖十四州，统治范围为今天的浙江全境、苏南的苏州、上海和福建东北部的福州市。 为了解决钱塘江的“潮患”，钱镠修筑“捍海石塘”。每年农历八月十五的时候，大潮最为汹涌，钱镠便在这时举行“射潮”仪式，数千军士张弓开弩，逆潮而射，以示勇武。 钱氏的“独立王国”存续了七十余年，凡三代五王。其间正值乱世，杀戮攻伐是寻常之事，中国史书上最混乱和残忍的年代就是分裂的南北朝和五代十国时期。而钱镠坚持“偏安”国策，遇强示弱，友好周边，居然保全了江南的半壁太平。978年，宋太祖赵匡胤灭南唐李煜，兵锋直指吴越，钱镠的孙子钱弘俶“纳土归宋”，让杭州和苏州避免了一场似难逃脱的战祸。 现在城内最著名的三塔——雷峰塔、六和塔和保俶塔，都是吴越时期的遗物。 钱家有两个同代人绝没有的功绩。其一，他们以偏安的姿态力保江南的半世平安，在中原频频发生“人相食”惨剧的时候，这里却是歌舞升平，民生安逸。其二，吴越的王位先传弟，再传子，五轮传承没有发生过一次手足相残的流血事件。钱家后来成为江南的千年望族，名士人才辈出，直到近世还出了钱穆、钱学森和钱伟长等。 有一年，钱镠的一位妃子在乡下久留不归，他便写了一个帖子让人送去，情长纸薄，只寥寥九字：陌上花开，可缓缓归矣。 “苏子瞻要来了。”1071年（北宋熙宁四年） 神宗熙宁年间，王安石变法，苏轼上书提了一堆意见，执拗的王相公脸色很不好看，苏轼自觉无趣，便自请出京外放，到杭州来当通判。 通判是一方州府的副职，掌管粮运、家田、水利和诉讼等事项。苏轼此番在杭州任职三年，到底干了些什么政务，没有太多的记载。估计他放逐南下，心意不平，更多的时间是在游山玩水。对于杭州而言，这却是一个意外的福祉。 苏轼担心以后还会有人围湖造田，侵占湖面，便在湖中心立了三座瓶形石塔，以此为标，约束后世。后来，每当月圆，好事者点烛于塔心，水月交映，难分难解，成了“三潭印月”。 慧理注入了佛禅的基因，白居易“重新发现”了西湖，钱镠在空间上定格了杭州城，到了苏东坡的手上，则完成了一次文化符号学上的升华。 赵构的皇宫，是以钱镠的吴越王宫为基础改建的，位于凤凰山东麓，呈现西高东低的不规则方形。东至中河南段，西至凤凰山，北至万松岭，南至笤帚湾。皇宫依山势而建，殿阁叠进，建有殿、堂、楼阁130余座，宫墙高三丈，周回约九里。 皇城图 临安图 由于政治上的悲愤压抑和商贸的繁荣，南宋的思想出现了两个大的分叉，一是以福建朱熹为代表的理学，内求“天命之性”，“去人欲，存天理”，另一则是温州叶适的永嘉学派，他们反对“重本抑末”，讲究“功利之学”，认为“既无功利，则道义者乃无用之虚语”。 今天杭州人的某些城市性格——追求安逸、避谈政治、热衷投资做买卖和街谈巷议，或许都是那一百多年的“临安岁月”打下的底子，而它们分明也烙下了“偏安”的气质。 青山有幸埋忠骨，白铁无辜铸佞臣。杭州人把油条叫作“油炸桧儿”，表达对秦桧的愤怒。还有一个特色小吃，是把油条和小葱裹在面饼内，在铁锅上压烤或油炸至脆黄，叫作“葱包桧儿”。秦先生因为害死了岳飞，已经被杭州人在油锅里翻来覆去地炸了几百年。 李清照，易安居士 因为靖康之变，从汴京南逃，丈夫死于金陵，自己辗转定居到临安。 过眼西湖无一句，易安心事岳王知。 在杭州很少有人知道，中国文学史上最伟大的女词人曾经在这座城市里居住了二十多年。 人间的繁华与美景，投射到不同的人生里，自有迥异的颜色。在白居易和苏东坡的眼里，西湖是天下第一等风景，他们愿意用数百首诗歌来吟唱它，甚至觉得自己前世就是杭州人。而在李清照的眼里，临安的天空是灰色而屈辱的，西湖的山水寡淡无趣。人间的模样，其实就是命运的倒影，人间的意义，其实就是活着的趣味，一旦生命萎缩，它们便空空荡荡，不值得哪怕用一个字来记录描述。 大元帅伯颜率元兵控制巴蜀，沿长江南下，一路势如破竹，偏安百年的岁月终于到了尽头。伯颜的兵锋抵达皋亭山时，5岁的宋恭帝奉表投降，大批宋军撤离临安，右丞相文天祥入元营谈判。 《马可·波罗游记》中，出现最多的城市当然是北京和杭州，Cambalu和Quinsay。其中，杭州的篇幅超过了北京，约占全书的十五分之一。 元朝一位叫阿老丁的伊斯兰长老在老御街的边上建了一座很大的清真寺——凤凰寺 是1555年农历五月二十八日，时值明嘉靖三十四年。 年初，一千多名倭寇从乍浦港入侵，一路南下，窜犯海盐、德清、嘉兴等府县，沿途烧杀抢掠。五月侵扰省城杭州。倭寇们驻扎在钱塘门外，先是烧毁了千年名刹昭庆寺，到了晚上，又怕雷峰塔里埋伏着官兵，便纵火焚塔。经此一祸，原本是五层八面楼阁式的雷峰塔只残留下砖体塔身，后来的几百年间一直没有重修，成了精致的西湖风景中少有的一种“废墟之美”。1924年9月25日，老塔轰然倒塌，在上海的鲁迅还很感慨地写了一篇《论雷峰塔的倒掉》。 就在雷峰塔被焚毁的半年后，杭州城里来了两位新的长官，他们是嘉靖帝踌躇之后的一个“两全”决定。他从湖广调来胡宗宪出任浙江巡抚，他是汪直老家歙县邻近的绩溪人，是一位主张安抚政策的温和派。嘉靖希望他通过乡谊的渠道，用和平的方式解决倭寇问题。另外，他从山东登州调来骁勇善战的戚继光，出任杭州参将，主持军事行动。 1557年（嘉靖三十六年）初秋，胡宗宪派出的两位代表，与汪直在日本松浦津进行了最后一轮谈判。明朝代表承诺，一旦汪直归顺朝廷，不但可以免除他的死罪，放回家属，还可以免罪通商，继续做他的海外生意。 胡宗宪迫于巨大压力，于1559年十二月毁约，将汪直一族数十口，斩决于巡抚衙门前的官巷口闹市。 雷峰塔 湖墅的大运河边有一座香积寺，是净土宗的江南祖庭，里面有一尊紧那罗王菩萨，他是佛教里的天龙八部之——“音乐天”。但因为手中举着一根拨火棍一样的东西，硬是被杭州人“重新定义”成了“灶火菩萨”，来这里拜一拜，可以保佑一年家里灶头红火，人畜两旺。 杭州的城隍确有其人，名叫周新，是永乐年间（1403年～1324年）的浙江提刑按察使，据说他廉明刚直，为民申冤，号称“冷面寒铁”，后来冤死于宦官之手。杭州人把他封为城隍神，建庙吴山之上，每年农历的五月十七和除夕，都有很多市民前往设祭。 西湖边的爱情故事，都奇奇怪怪的，女主角主要有三种，要么是妓，要么是妾，要么是妖。 明代最为著名的话本作品是“三言二拍”。“三言”的作者为苏州人冯梦龙，分别是《喻世明言》《警世通言》和《醒世恒言》，“二拍”则是湖州人凌濛初创作的《初刻拍案惊奇》《二刻拍案惊奇》。 中国古代民间四大爱情故事，分别是孟姜女哭长城、牛郎织女、白蛇传、梁山伯与祝英台。其中，有两个发生在杭州的西湖之畔 之所以叫断桥，则是因为在早年，桥上有一个凉亭，每当冬季下雪，桥上积雪似断未断，好事人就把它叫作了断桥。 苏小小，湖山此地曾埋玉，风月其人可铸金。 苏小小的故事，是西湖爱情的主要模式。你知道的，从古代到民国，西湖边那一栋一栋的小别墅，大多是用来储妓养妾的。林和靖墓旁原有一个冯小青墓，她便是一个大户小妾，才情绝代，18岁就挂掉了 冷雨幽窗不可聆，挑灯闲看牡丹亭人间亦有痴于我，岂独伤心是小青。 梁山伯与祝英台的故事，则发生在西湖的东面。祝英台是上虞祝家村的大小姐，她女扮男装到杭州来读书，路上遇到了绍兴书生梁山伯。他们结伴过钱塘江进城，走的是东城的望江门，城门旁的贴沙河上有一座草桥，是运送草料的卸货地，盖有一个草桥亭，他俩便在这里结拜为兄弟。在戏文中，这一出叫“草桥结拜”。进城之后，他们赴万松书院读书。它在凤凰山北坡的万松岭上，唐宋时候为报恩寺，到了1498年（弘治十一年）改为书院，是杭城四大书院之首。这里高踞岭巅，左江右湖，山野明秀，是读书的好去处，也是谈恋爱的绝佳地方，梁祝在这里同窗三年 “你倒是告诉我，在你们杭州发生的这些故事里，为什么男主角要么是个懦夫，要么是个负心汉，要么就直接是一个呆子？” 徐光启、李之藻和杨廷筠三人被称为明末清初“中国天主教的三柱石”。 然而到1721年，罗马教廷严禁中国信徒参加祭祖祀孔，从而引发礼仪之争，康熙帝盛怒，下了一道口谕：既然那么爱嚼舌头，以后洋人就不必来中国传教了，禁止了吧，免得多事。 数以百计的像约翰·司徒这样的年轻传教士来到了杭州，他们建成了新的教堂，在六和塔下建了浙江的第一所现代大学——之江大学，今天杭州著名的医院——浙大附属第二医院，其前身是教会的广济医院。传教士们聚集居住在当年杨廷筠建的教堂周围，那里就被叫成了耶稣堂弄。 六和塔 约翰·司徒和他的太太在杭州生了四个孩子，其中长子叫司徒雷登。他在中国整整生活了50年，当过传教士，是燕京大学的创始人，并出任过美国驻华大使。毛泽东写于1949年8月的《别了，司徒雷登》，是中美外交史上的一个转折性事件。 明军只在涌金门外稍稍抵抗了一阵就主动出降，未见惨烈的记录，杭州城再次因“顺从”而被屈辱地保全了下来。 千万人头落地，又有新的会长出来，弱柳夭桃被摧，自有春风再植嫩枝，这番无奈的轮回，张岱这辈子算是碰到了，之前有很多人碰到过，以后还会有很多人碰到。 世人都说书生没用，“无事袖手谈性情，有难一死报君王”，如此而已。 延安路原来叫延龄路，是清朝驻兵的旗下营。到20世纪60年代，大家都还叫它“旗下”，住在武林门外的人进城，都说“到旗下去”。 赵士麟上书朝廷，将营债数额削减到原来的十分之一，并明令永禁营债。杭州人感念其恩，在西湖孤山的北麓为他建造了一座赵公祠，比邻林和靖墓。日久之后，市民想当然地把“赵公”演绎成了财神爷赵公明，赵公祠成了香火甚旺的财神庙。赵士麟若在天有灵，应该会哭笑不得。 在那个革命党人攻击满城的惊恐之夜，一位七岁的旗人男孩大哭不已，他后来回忆道：“家人把我单独藏在南高峰上的一所小寺庙，叮嘱我有人来切不可承认是旗人，但是我脑袋后边有一条小辫子，生怕被认出来，那种幼时的恐慌是久久都忘不掉的。”这个男孩是满族伊尔根觉罗氏，长大后有了一个汉人名字，叫常书鸿。他在浙江省立甲种工业学校完成学业，1943年到敦煌，从此一生成了那里的“守护人”。 龙井因“龙井泉”而得名。传说井与海相通，其中有龙，故名龙井泉。 有的时候，皇帝把字写错了，也会留下一则风流轶事。有一次，康熙为灵隐寺题写匾额，一时兴起把繁体“靈”字的“雨”字头写得过大，下面的纸不够用了，一位机灵的大学士便悄悄在手心上写了“雲林”二字递过去。从此，灵隐寺天王殿上的那块大匾额就变成了“云林禅寺”。 1862年，胡雪岩因机缘攀上时任浙江巡抚的左宗棠，此后20年里他一直是左宗棠的采运官，为之筹措钱粮、军饷，成了后者的“钱袋子”。 高墙古朴的胡庆余堂国药店人声鼎沸，它与京城的同仁堂并称南北两大药号。这是胡雪岩当年造宅子的同时，顺手办的一桩善事和“小生意” 孤山的占地约20公顷，高38米，怎么看，都是一个弹丸之地。自林和靖“暗香浮动”之后，千年以降，这里从来是文人徘徊惆怅的风流地：白居易等人都曾结庐于此；康熙和乾隆在此建了一个孤山行宫；光绪年间，吴昌硕等人在这里办了西泠印社。然而，自从秋瑾葬于此地之后，孤山突然平起凌厉之气，革命者竞相追随而至，这里成为他们最理想的埋骨之地。 张静江被孙中山称为“中华第一奇人”。他出身湖州南浔巨富之家，1905年冬天，28岁的张静江在一艘海轮上邂逅孙中山，他递给孙一本《圣经》，内夹一张小纸条，两人约定，日后如果孙需要钱，可以拍电报给他，如拍“A”即是一万元，如拍“B”即两万元，“C”则三万元。两年后，孙中山为发动广州起义筹钱，试着发了一封电报，居然真的收到了钱。之后，张静江成了孙中山最积极的“金主”。 自胡雪岩的那场收丝豪赌失败后，整个杭嘉湖的丝商集团就全面覆灭了。与杭州相比，苏南地区的丝织业虽然也被严重波及，但是在后来的几十年里，那里出现了一批杰出人物，比如苏州状元陆润庠、南通状元张謇，以及无锡的荣氏兄弟。他们筹建全面西化的纺织厂和机器面粉厂，从而完成了产业的现代化转型。而杭嘉湖则一直无类似人物出现。与此同时，原本以杭州为大本营的徽商集团及宁波、绍兴商人则集体投奔上海滩，成为那里的航运及金融业的主力。在现代工业文明的冲击下，杭州赖以为本的丝绸、茶叶及钱庄等产业黯然失色。事实上，在整个20世纪，杭州产业的空心化问题一直没有得到解决，直到21世纪电子商务出现后，才突然柳暗花明。 西湖边的民国别墅，最出名的应该是报业巨子史量才的秋水山庄。史量才青年时在杭州蚕学馆读书，后来到上海闯荡，创办《申报》，提出“人有人格，报有报格，国有国格”，因立场独立和新闻及时，报纸发行量最高达日销15万份，为国内第一大报，言论足以影响时局。史量才有一房二太太沈秋水，原是上海滩的雏妓，擅长鼓琴度曲。就在2021年，秋水山庄被改造成了杭州最昂贵的精品酒店，每晚的住费高达1.2万元。不知旅者中有多少人，知晓它的前生今世。 史量才葬于龙井附近的积庆山马婆岭。在灵堂上，沈秋水白衣素服，抱着夫君生前最喜爱的七弦琴，弹了一曲《广陵散》。曲终弦断，秋水将古琴投入火中，一段情缘从此焚灭。此后，秋水出家为尼，把山庄捐出，办了一家妇孺医院，如今它是国营新新饭店的一部分。 陈布雷出生浙江慈溪耕读世家，那里地处宁绍，自古人文渊薮，明清期间，绍兴师爷行遍天下，便有“无绍不成衙，无宁不成市”的谚语，是一个锋芒毕露的才子。1927年，37岁的他被推荐给北伐总司令蒋介石，从此开始了长达21年的鞍马追随，被后者视为“文胆”。1936年12月，发生了改变中国命运的西安事变，蒋介石归来后，他在杭州北山路的新新旅馆关门数日，完成《西安半月记》，塑造了领袖处惊不乱的形象。第二年，抗日战争全面爆发，蒋介石在庐山发表全国演讲，讲稿即出自他手，一句“地不分南北，人不分老幼，皆有守土抗战之责”展示国人死战到底的决心。为了征募新兵，他撰写宣传口号，“一寸山河一寸血，十万青年十万军”，引发全国热血青年的从军潮。他是民国一代最著名的师爷，也可能是最后一位传统意义上的师爷。他的激越、曲折和无奈的一生，总让人叹息中国文人的宿命。 西湖边的千年昭庆寺改成了少年宫。 红卫兵要打砸灵隐寺，杭州市委紧急上报北京，周恩来总理两次批示：灵隐寺是文物不是“四旧”，红卫兵们才心有不甘地散去。灵隐寺封闭四年，终得侥幸保全。 整个西湖都被围了起来。周围出现了各个部委的疗养院，有军队的、总工会的，等等。所有的风景点都成了公园，只有买票才能进入。 《中美联合公报》敲定处：西湖边的刘庄，如今这里是西湖国宾馆。 在所有的现当代政治家中，对西湖最情有独钟的是毛泽东，新中国成立之后，他先后39次来这里疗养和工作，居留时间长达500多天。第一次看到这个数字的时候，我也是大吃一惊。他常住的地方是西子宾馆，也叫汪庄，是一位安徽茶商于20世纪20年代建成的，它面对西湖，背靠雷峰塔。毛泽东在杭州期间，经常主持召开政治局会议或政治局扩大会议，许多重要的政策文件都在这里讨论决议，包括《全国农业发展纲要四十条》以及关于开展“文化大革命”的决定等。 我觉得，很多年后，杭州人应该还会记得王国平，就如同他们记得为杭州做出过贡献的钱镠、白居易和苏东坡等人一样。他是一个地道的杭州人，父亲王平夷是华野干部，1949年随军到杭州，第二年就生了个大胖儿子，起名王国平，取“国家太平”的意思，王平夷曾担任杭州的市委书记，一直干到“文革”爆发。 在他的治理下，环西湖的政府机构几乎被全数拆迁，实现了“还湖于民”。通过大规模的排淤治理工程，西湖面积扩大了一倍多。2002年，倒塌了78年的雷峰塔重建，人们没有找到白娘子，却意外地挖到了一个藏有诸多宝物的地宫。2002年，西湖所有的公园宣布取消门票，是全中国第一个免费向公众开放的5A级景区。这一决定看上去每年少了一千多万元的门票收入，却数倍级地增加了游客量，进而推动了环西湖商业圈的繁荣。 在城市格局上，杭州市政府做出了东进西拓的战略性决策。向东，市政府提出杭州从“西湖时代”向“钱塘江时代”迈进。自从民国初年城墙被拆除，西湖入城之后，杭州的城市重心就向西湖的北岸一线倾斜，这造成了极大的局促，在很长时间里，杭州是城区面积最小的省会城市之一。所以，只有“摆脱”西湖，才能舒展杭州。2001年，杭州市划出钱塘江北岸的四平方公里，设立钱江新城，在那里先后建设了新的国际会议中心、图书馆和市民中心等。在城市的西部，保留了西溪湿地，使之成为城市的“绿肺”。 如同钱镠所说：千百年后，知我者以此城，罪我者亦以此城。苟得之于人而损之己者，吾无愧欤！ 2016年，杭州市政府由武林门搬迁至钱江新城。同年，杭州承办G20峰会。 阿里巴巴对于杭州的意义是非凡的，它如同挖通了一条新的“通天大运河”，让杭州成为全国互联网商品交易的巨型集散地，更可怕的是，这个“大运河”没有物理空间的限制。 那天，我骑着自行车，从武林门出发，沿着解放路到西湖边，然后右转骑向断桥和孤山。我看见儒生张煌言和倭寇汪直在相距不远的地方被砍头，马可·波罗、张岱和秋瑾站在同一个角度各怀心事地眺望西湖，几位中学生从建兰中学的校门嬉笑着走出来，在他们的身后，有一位将军带着十几位亲人举火自焚，那条被叫作白堤的长堤其实与白居易没有关系，在香格里拉饭店的门前，有一位大和尚在一棵松树上打坐了40年。 在这个意义上，杭州不是一座属于权力的城市，它一直被平民所统治。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"人文","slug":"人文","permalink":"https://lchml.com/tags/%E4%BA%BA%E6%96%87/"}]},{"title":"《祥瑞：王莽和他的时代》","slug":"xrwmhtdsd","date":"2022-10-26T16:00:00.000Z","updated":"2022-10-31T08:08:31.480Z","comments":true,"path":"book/xrwmhtdsd/","link":"","permalink":"https://lchml.com/book/xrwmhtdsd/","excerpt":"其实中国一直都是内法外儒，法家是中国的政治体制，儒家是中国的意识形态，自秦之后几千年，甚至当今社会，莫不如是。","text":"其实中国一直都是内法外儒，法家是中国的政治体制，儒家是中国的意识形态，自秦之后几千年，甚至当今社会，莫不如是。 看历史最有趣的事情之一就是对我们自己的三观或者说哲学思想自我认知的拷问，当看到很多历史人物基于他们的思想做出不同的选择产生不同的后果，我们会直觉的认为他们是对的或错的，是高尚德或卑鄙的，是不可接受的或可以理解的等等，而这些直觉的结论其实就是我们自己的三观所在，然后我们可以再进一步想为什么我会这么人为，如果换成我会怎么样？而这种感觉在本书中由于王莽的偏执型人格会显得特别强烈。另外一件事当你看着历史中形形色色，起起落落的各种人物，你不禁会问自己，我更愿意做那种人，是位极人臣却可能一朝覆灭，还是阿谀奉承，用尽手段上位，亦或是刚正不阿却可能一生悲惨，又或者做好本分，明哲保身。你会发现无论哪一种都不是那么简单。最后，书中对孔休的描述虽然只有短短几句话，但却让我印象深刻，可能这就是我的选择？ 王莽在上位前，通过儒家包装营销自己，把自己打造成儒家第一人的人设（感觉可以作为营销行业的祖师爷了），来谋求社会地位和名誉，恰好又有个长寿的皇太后姑妈，加上他的偏执型人格，种种机缘巧合造就了属于他的时代，然而上位后的王莽，偏执性格大爆发，再加上没有足够的政治能力（毕竟原来是靠营销作秀上位的），直接把帝国带入了深渊，社会动荡，边境动乱，流民四起。新朝的崩溃从他上位那一天起就已经注定。 以下内容是书中的一些摘抄： 各大家族的世系图： 西汉刘氏（上） 西汉刘氏（下） 新朝王氏 舂陵侯家族 呼韩邪单于，王昭君家族 西汉的历代帝王：高祖（刘邦）-惠帝（政变被废）-文帝（刘恒）-景帝（刘启）-武帝（刘彻）-昭帝（刘弗陵）-刘贺（海昏侯，被霍光废）-宣帝（刘病已，后改名刘询）-元帝（刘奭）-成帝（刘骜）-哀帝（刘欣）-平帝（刘箕子）-皇太子（刘婴，禅位给王莽） 一般来说，王朝的覆灭往往与政治的败坏、经济的崩溃、文化的腐朽、版图的分裂、御外的失败相关联。 秦始皇只比刘邦大三岁，刘邦其实是战国时代的人。 汉初刘邦称帝的联邦制的列国文化，后战国时代的思想。功臣，外戚，诸侯。 高祖死后，吕后当政，吕后一死，诸侯发动政变，功臣里应外合，吕氏被诛，汉惠帝被废，立文帝刘恒。 刘恒从诛灭诸吕的政变中吸取的教训，并不是防范外戚，而是避免再次出现诸侯王领兵叩关，或是功臣发动政变废立皇帝这样的事。 功臣会随着时间的推移而老去，威胁性是下行的；但诸侯王却恰恰相反，随着血缘的疏远以及年龄的长成，威胁性是上行的。 汉景帝刘启即位，用晁错，法家出生，继续加强中央集权。 七国之乱，主要由文帝之前的政变人齐王的后代发起，名号清君侧，晁错被赐死，平定七国之乱后进一步削弱诸侯王实力。 武帝刘彻即位，重用主父偃继续削藩，推行著名的推恩令，进一步削弱诸侯国，再通过著名的酎金案解决列侯。 秦制总的来说就是三条：律法、文法吏、编户齐民。 这些律法和现代国家的“法律”在根子上不是一回事。秦制的律法是一种“刑名之学”，世界上任何事，只要它被命名了，就得做到“名实相符”，就需要有律法来规定怎么达到名实相符。 文法吏，或者叫作刀笔吏，就是掌握、维护这些律令法条，懂得使用“刑名之学”来管理天下事务的行政官僚。他们不是后世的士大夫，而是粗通文墨、精通律条的职业官僚。 中国社会从战国到汉朝的历程，就是老百姓从奴隶加自由民变成农民的历程。汉朝在继承秦制的同时抛弃了秦政，删减秦法，减租减税，也就是后世所说的休养生息。秦制就好比一台齿轮严丝合缝的机器，秦朝驾驭的时候，采用“秦政”，功率开到最大，超负荷运转，直到机器过热而崩溃；汉朝驾驭的时候，拿掉一些不必要的零件，低功率运行，稳定至上。但无论是秦还是汉，都是同样的一台国家机器。 征和二年（公元前91年），丞相公孙贺之子公孙敬声被人告发为巫蛊咒武帝，与阳石公主通奸，公孙贺父子下狱死，诸邑公主与阳石公主、卫青之子长平侯卫伉皆坐诛。武帝宠臣江充奉命查巫蛊案，用酷刑和栽赃迫使人认罪，大臣百姓惊恐之下胡乱指认他人犯罪，数万人因此而死。巫蛊之乱，刘彻将卫皇后家几近灭族，太子、儿媳、公主及皇孙全部死难。长安城内，丞相刘屈氂和太子的军队发生了激烈的巷战，死伤枕藉，天下震怖。 江充与太子刘据有隙，遂趁机陷害太子，并与案道侯韩说、宦官苏文等四人诬陷太子，太子恐惧，起兵诛杀江充，后遭武帝镇压兵败，皇后卫子夫和太子刘据相继自杀。壶关三老和田千秋等人上书讼太子冤，终于清醒过来的武帝夷江充三族，烧死苏文。又修建“思子宫”，于太子被害处作“归来望思之台”，以志哀思。此事件牵连者达数十万人，史称巫蛊之祸。 立三岁的刘弗陵为太子，为了防止外戚，同时把刘弗陵的亲妈赵婕妤赐死。巫蛊之祸后刘彻才逐渐醒悟，改弦更张，决定休养生息，颁布了罪己诏。 刘弗陵8岁即位，汉昭帝，20岁就晏驾了，没有子嗣。首席辅政霍光（霍去病弟弟），迎立昌邑王刘贺（海昏侯），由于新皇帝提拔王国旧臣与前朝旧臣冲突，被霍光废掉，立卫太子刘据的孙子刘病已（后改名刘询）。 汉宣帝汉朝中兴之主，汉宣帝依旧坚持采用霸王道杂之的治国思路。等霍光死后，诛灭霍氏家族，真正自己掌权，笼络儒家，同时启用外戚担任中朝官（外戚不必学习儒术即可从政），与外朝的儒臣形成平衡。但是他没有预料到，有一天，儿媳妇的侄子王莽身为外戚，居然儒家化了，甚至成为儒家的代表，从而得以收拢内外两朝，架空皇权。 汉元帝刘奭，作为第一个接受了完备的儒家教育的帝王。他的老师都是有名的大儒，所传授的都是儒家的齐学，也就是最讲究天人感应、祥瑞灾异等近乎神学的那一派学问。（差不多时间，西方正在用耶稣的神迹进行推广。）汉元帝基本上让汉朝从霸王道杂之真正转向了独尊儒术。 刘奭的御史大夫贡禹，建议进行宗庙改制，因为到这个时候，全国宗庙数量有176所，产生巨大的人事费用和维护开支，成为很重的财政负担。改制的目标：首先把各郡国的皇室宗庙都撤销；在中央，把宗庙分成三类，刘邦是立国者、最早受命的皇帝，是始祖，庙号太祖，独为一类“祖庙”；文帝、武帝比较有功德，庙号分别为太宗、世宗，为第二类“宗庙”；其他的按照血缘关系，只保留四世，为第三类“亲庙”，超过四世说明亲缘已尽，原先立的庙就要“毁庙”，“毁”不是破坏摧毁，而是不再单独祭祀、不再维护的意思。祭祀要遵照“禘袷（jiá）”之礼，遵循“昭穆”之序。 谥号和庙号的区别，谥号是皇帝死后大臣给的，一般会受到下任皇帝的影响。庙号就是类似太祖、高祖、太宗之类的，有功德才配享。唐朝以前一般用谥号，后面用庙号，主要是唐朝之后的谥号就非常长了。 汉成帝刘骜的丞相匡衡（凿壁偷光那个）改制郊祀，汉成帝把刘邦亲手确立的郊祀制度毫不留情的废除，如此不尊重先王旧典，意味着皇室统治的合法性将不再来自先王的征服和功德，而是由儒家说了算。匡衡因贪赃被贬为庶人，各地又有灾异出现，不久后恢复旧制。 另外儒家还首次尝试了“通三统”，就是汉家天下里同时保存前面两个朝代的祭祀不灭。对汉朝来说，秦朝是“闰”，不承认其合法性，所以三统即商、周、汉。成帝首次封孔子的后裔孔吉——孔子是商朝贵族的后代，又是儒家眼中的“素王”——为殷绍嘉侯，很快又进为宋公。 建三公，汉家最初的三公是丞相、御史大夫、太尉。其中丞相最尊，御史大夫虽然与丞相并称两府，实际低于丞相；太尉时至时废，汉武帝用内朝官大司马大将军实际履行太尉的武职；汉宣帝取消了大司马的印绶和官署。何武认为应该建立符合儒经的三公，于是汉廷把御使大夫改为大司空，大司马给予印绶并改为外朝官，地位与丞相等同，新的三公制度建立起来。 由于儒家齐学在全国的发展壮大，灾异谶纬之类的学说猖獗，天下都在议论要改姓易代了，甚至儒辰当面质问哀帝灾异频出，天子失德，根据五德学说，刘姓是尧的后代，应该要禅让给舜的后代，陈姓或王姓。皇权的政治危机到了非常严重的地步，汉哀帝刘欣即位后想要扭转局势，试图效仿武宣。恢复宗庙和祭祀制度。 但病痛的身体、早逝的时运、阴鸷的心理，使他心有余而力不足。哀帝以区区二十几岁的年龄，承受着有汉以来所有的代价。 哀帝身死，王莽仓促掌权。又把宗庙和祭祀制度改回来。三十年间，皇室对这宗庙和郊祀的改制反反复复不能定夺，又没有能力置之不理，意味着皇室已然失去了主导政教的权威。而这两件事最终成就于王莽，又恰好证明了王莽既能够稳定政局，又有资格定夺改制。 至此，汉室的权力已经彻底被王莽掌握。人们也更加相信，选择王莽就等于选择了理想、选择了正义。只有王莽，才能将儒家改制从这些宗庙祭祀的礼仪制度向实质性的经济、财政、文化、内政、外交等全方位的变革大踏步迈进。 距离刘欣晏驾整整六十四天，刘箕子正式即皇帝位，平帝。当日大赦天下。箕子孤身入朝为帝，母亲舅舅都不在身边，形成了王政君临朝、王莽执政的局面。这将是汉朝残存岁月的基本政治格局。 要是此时王莽突然暴毙，他在史书上说不定还能单独进列传，毕竟做事论迹不论心。也还是那句 “周公恐惧流言日，王莽谦恭下士时。若使当时便身死，古今忠馁有谁知？” 刘秀在舂陵起兵。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"传记","slug":"传记","permalink":"https://lchml.com/tags/%E4%BC%A0%E8%AE%B0/"},{"name":"中国史","slug":"中国史","permalink":"https://lchml.com/tags/%E4%B8%AD%E5%9B%BD%E5%8F%B2/"}]},{"title":"《时间从来不语，却回答了所有问题》","slug":"sjclbyqhdlsywt","date":"2022-09-18T16:00:00.000Z","updated":"2022-09-20T02:14:49.838Z","comments":true,"path":"book/sjclbyqhdlsywt/","link":"","permalink":"https://lchml.com/book/sjclbyqhdlsywt/","excerpt":"书名”时间从来不语，却回答了所有问题“，不仅仅是书中文字的提炼，更是季老的一生经历感悟。也许当时间足够长的时候，很多问题都早已不是问题，不论是政治，战争，矛盾，感情，大概都已随风飘散。","text":"书名”时间从来不语，却回答了所有问题“，不仅仅是书中文字的提炼，更是季老的一生经历感悟。也许当时间足够长的时候，很多问题都早已不是问题，不论是政治，战争，矛盾，感情，大概都已随风飘散。 当时只道是寻常 不为无益之事，何以遣有涯之生 对荣誉的另一种追求，是我们对自己的长处评价过高。这是我们对自己怀有的本能的爱，这种爱使我们把自己看得和我们的实际情况全完不同。 德国大学的制度，没有入学考试，只要高中毕业就可以进入任何大学，德国学生往往是先入几个大学，过一段时间以后，自己认为某个大学、某个教授，对自己最合适，于是才安定下来。先听教授的课，后参加他的研讨班。最后教授认为你”孺子可教“，才会给你一个博士论文题目。写博士沦为有一个形式上简单而实则极为严格的过程，一切决定于教授。在德国大学里，学术问题是教授说了算。论文写成至少也要三四年，拿到题目十年八年写不出论文，也不是稀见事。 根据我个人的观察，对世界上绝大多数人来说，人生一无意义，二无价值。他们也从来不考虑这样的哲学问题。走运时，手里攥满了钞票，白天两顿美食城，晚上一趟卡拉OK，玩一点小权术，耍一点小聪明，甚至恣睢骄横，飞扬跋扈，昏昏沉沉，浑浑噩噩；等到钻入了骨灰盒，也不明白自己为什么活过一生。其中不走运的则穷困潦倒，终日为衣食奔波，愁眉苦脸，长吁短叹。即使日子还能过得去的，不愁衣食，能够温饱，然而也终日忙忙碌碌，被困于名缰，被缚于利锁。同样是昏昏沉沉，浑浑噩噩，不知道为什么活过一生。对这样的芸芸众生，人生的意义与价值从何处谈起呢？ 如果人生真的有意义与价值的话，其意义与价值就在于对人类发展的承上启下、承前启后的责任感。 一个人活在世界上，必须处理好三个关系：第一，人与大自然的关系；第二，人与人的关系，包括家庭关系在内；第三，个人心中思想与感情矛盾与平衡的关系。 人生不如意事常八九，可与人言无二三 纵浪大化中不喜亦不惧应尽便须尽无复独多虑","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"文学","slug":"文学","permalink":"https://lchml.com/tags/%E6%96%87%E5%AD%A6/"},{"name":"散文","slug":"散文","permalink":"https://lchml.com/tags/%E6%95%A3%E6%96%87/"}]},{"title":"《管理百年》","slug":"glbn","date":"2022-09-12T16:00:00.000Z","updated":"2022-09-13T12:21:09.695Z","comments":true,"path":"book/glbn/","link":"","permalink":"https://lchml.com/book/glbn/","excerpt":"赚钱有多容易，管理就有多混乱。管理不是企业的附属或者束缚，而是其核心竞争力和长久生命力的基础。","text":"赚钱有多容易，管理就有多混乱。管理不是企业的附属或者束缚，而是其核心竞争力和长久生命力的基础。 全书总结了管理学从1900年到现在的发展历程 第一个10年法约尔的14条”管理的一般原则“： 劳动分工原则 权力和责任原则 纪律原则 统一指挥原则 统一领导原则 个人利益服从整体利益原则 人员的报酬原则 集中的原则 等级制度原则 秩序原则 公平原则 人员的稳定原则 首创精神 团队精神 第二个10年最初的管理学，主要针对劳动密集型的场景关注提高效率，降低成本等目标。泰勒、福特、松下幸之助。测量、控制、监督 松下和福特之间的关键区别，在于看出了商业中道德伦理元素的重要性——公司不是单纯的生产工具，还是社会和个人福祉的载体。 第三个10年关于”组织“的思考，善用群体智慧的现代管理者 CEO并非只是着眼于简单短期成功的独裁式人物。相反，塑造组织文化、定义组织的目标，也是其职责的一部分。 倘若每一个问题，独裁者都知道完整的答案，那么独裁的确是最有效的管理方式。但他做不到，而且永远不可能做到。这就是为什么独裁最终会走向失败。 决策时管理的核心 斯隆对组织的研究成果，在于确立了分权经营和集中政策控制相结合的组织模式。他认为企业最高层的管理者对事业部的经营细节有太多的了解，这既不适宜，也无必要。多事业部形式造就了大型企业组织分权化的趋势。 第四个10年开始关注”人“的问题 只要企业管理方法还不曾考虑到人类本性和社会动机，工业发展就摆脱不了罢工和怠工行为。 人是所有商业活动的中心，也是所有其他活动的中心。处理人与人冲突的三种方式：压制、妥协、整合 没有参与就没有责任。 第五个10年战争总是能以奇妙的方式把精明的管理人才汇聚到一起。 二战标志着大规模营销的诞生，它以一种极不寻常的方式登场。 可口可乐、箭牌口香糖、雀巢咖啡等公司都通过战争中的营销大获成功 生产的变数要最小化，人际间的合作要最大化，这才是向前发展的最有效途径 日本的战败与商业崛起，坚定的实用主义在日本大行其道，雅马哈，索尼。 盛和昭夫认为，管理是责任的终点也是起点。他说”即便公司面临衰退，我们也不应该裁员。公司应该牺牲利润，因为这是管理者应该承担的风险和责任。员工是无辜的，为什么反倒要让他们受罪？“ 早在西方还没有任何人想到”顾客服务“这一概念时，松下幸之助就对它有了自己的理解。他说，”售后服务比售前协助更重要，只有通过收服务，企业才能得到终身客户“ 松下幸之助在公司成立之初碰上经济衰退，没有解雇任何一名工人。他说，”制造商的使命，应该是客服贫困，把整个社会从贫困中拯救出来，并为它带去财富“ 第六个10年消费主导的时代，探索工作的动机。人本主义兴起 人际关系学派三驾马车。其中，马斯洛提出需求层次理论，赫茨伯格提出保健因素与激励因素的双因素理论，麦格雷戈则提出X理论、Y理论以及Z理论。接下来，彼得·德鲁克横空出世，开创了战略管理的全盛时期。 管理培训和洗脑的联系，暗示心理契约远远不止一桩公平的互惠交易。 德鲁克写出了《管理的实践》：企业存在的目的，只有一个有效定义——创造客户。市场不是上帝、大自然或者经济力量创造的，而是商人创造的。也许在他们创造出可以满足客户特定需求的产品之前，这种需求已经被客户察觉。也许就像饥荒时人们对粮食的渴望一样，客户在清醒着的每一刻都盼望着自己的需求能得到满足。但这只是理论上的渴望；只有当商人采取行动、创造出能满足这种需求的产品之后，客户和市场才真正出现。 ”营销组合“的四大关键要素是：产品、价格、地点、推广。这就是后来著名的4P营销理论。强调的是销售方的营销组合，而非购买方的营销组合。 管理层必须把自己视为满足消费者价值需求的人，而不是生产产品的人。以生产为导向的思维必然会导致视角变得狭隘。 成长不是要跻身于某一个行业，而是要有足够的洞察力，找到未来成长的方向。 销售关心的是吸引人用现金交换你的产品时所使用的花招和技巧，它不在乎交换双方获得的价值。营销则不然，它始终把整个业务流程视为一种紧密结合的努力，旨在发现、创造、调动和满足客户需求。 马斯洛在《动机与人格》一书中否定了弗洛伊德学派。马斯洛认为普遍需求，也即匮乏性需求——生理需求、安全需求、社交需求和尊重需求，必须先得到满足，人才能产生无私的行为。人们努力满足普遍需求是正常而健康的。 赫茨伯的双因素理论：一类满足人的本能需求——保健因素，一类满足人类的独有需求——激励因素。他认为人们真正的工作动力来自成就感、个人成长、工作满意度和获得认可。保健因素是造成工作不快的主要原因，激励因素则是通往高工作满意度的康庄大道。 麦格雷戈提出的X理论——假设员工天生懒惰，需要监督和激励，把工作看作为了挣钱而不得不做的事。Y理论——人渴望并需要工作。Z理论——把组织和个人义务融合到一起。 第七个10年战略管理时代，彼得·德鲁克，父亲是奥地利政府的首席经济学家，母亲跟随佛洛依德学习过精神病学。 赋予他人愿景和执行能力，是独一无二、唯能寄望于管理者的任务。归根到底，管理者的定义就在于愿景和道义责任。 管理者的五项管理职责： 必须有高标准的绩效要求；不可放任平庸或糟糕的业绩表现；奖励必须以绩效为基础。 每一个管理岗位本身必须具备意义，而不仅仅只是晋升阶梯上的一块垫脚石。 必须有合理而公正的晋升制度。 管理需要有一套“章程”，明确地制定出影响管理者“生死”的决策，同时管理者应有向高层申诉的途径。 在职务任命时，管理层必须认识到，正直是管理者必须具备的素质，管理者天生就应该有这样的品质，不能指望他上任之后再培养出来。 管理者的7项新任务： 目标管理。 承担更多风险，目光更为长远。 制定战略决策。 构建完整的团队，团队中的每个成员都能根据共同目标进行自我管理，评估个人业绩和结果。 快速和清晰地沟通信息。 把企业视为一个整体，将管理者自身的职能整合其中。只掌握一两种职能相关知识的传统做法无法再满足当下管理的要求。 以联系的眼光看待企业。只专注于一个行业里少量产品的传统做法无法再满足当下管理的要求。 军事战略与企业思想及实践之间，一直存在着极为相似之处。最古老的起点大概可以追溯到成书于2500多年前的《孙子兵法》 主不可以怒而兴师，将不可以愠而致战。合于利而动，不合于利而止。怒可以复喜，愠可以复悦，亡国不可以复存，死者不可以复生。 夫兵形象水，水之形，避高而趋下；兵之形，避实而击虚。水因地而制流，兵因敌而制胜。 克劳塞维茨：战争不过是以其他手段来延续政治，而政治可以视为一种规模更大的商业活动。 19世纪末，商业实践和商业哲学首次获得了与其他学术理论科目同等高度的地位。MBA 管理者可以是专业人士，但不能把自己看作永远正确的超级英雄。 第八个10年反思企业管理的臃肿和弊端 贝尔宾问卷，团队成员的9种职能（网易对管理者有做这个问卷） 特别工作小组模式 第九个10年西方企业在二战后美梦一般的发展即将停滞，接下来该怎么办？ 学习日本，日本企业管理的关键要素之一是愿景，他们认为这是西方最为缺乏的东西。 大前研一的战略三角——构思任何企业战略时，都必须考虑的三个主要因素：公司本身、客户和竞争对手 戴明提出的质量管理14条原则： 持之以恒地改进产品和服务。 采用新的观念。 停止依靠大规模检查去获得质量。 结束只以价格为基础的采购习惯。 持之以恒地改进生产和服务系统。 实行岗位职能培训。 建立领导力企业管理。 排除恐惧，使每一个员工都可以为公司有效地工作。 打破部门之间的障碍。 取消对员工的标语、训词和告诫。 取消定额管理和目标管理。 消除影响员工工作情感的考评。 鼓励学习和自我提高。 采取行动实现转变。 波特的五力模型： 新竞争者的进入 替代品的威胁 客户的议价能力 供应商的议价能力 现有竞争者之间的竞争 彼得斯和沃特曼的《追求卓越》中写道：美国的问题在于，我们一味沉迷于管理工具，却忽视了管理的艺术。我们的工具侧重于衡量和分析。我们可以衡量成本。但光靠这些工具，我们并不能准确的阐明员工的价值所在。并提出8个关键特征： 贵在行动 贴近客户 自主和创业精神 依靠员工促进生产 以深入基层的价值观为动力 坚持团结 精兵简政 松紧结合 管理者比比皆是，领导者却凤毛麟角。领导者4种常见的能力：引导他人注意力的能力、把握做事意义的能力、赢得信任的能力和自我管理的能力。 第十个10年麻省理工研究发现，管理领域流行理论总是有着固定的生命周期。 企业再造理论的流行和消失 出现各种新的组织模式，如矩阵模式 韦尔奇提出的六西格玛质量标准 新的管理模式，如精益模式，丰田的精益生产理念 智力资本的概念 德鲁克在1992年指出，从现在起，知识是关键。世界不再朝着劳动密集、物质资料密集、能源密集的方向前进，而是越发朝向知识密集前进。 新世纪观念的重要性。圣吉提出的“学习型组织”，有5个组成部分： 建立愿景 团队学习 改变心智 自我超越 系统思考 价值观的重要性。价值观有两项关键作用——公司清晰阐明自己的价值观，能让潜在的应聘人员进行一定程度的自我选择；价值观还为个人事业目标和组织目标匹配提供了一套框架。 组织面临的挑战在于，价值观比金钱复杂的多。 今天的员工不忠于任何人，只忠于自我。 如今的招聘是要找出具备正确态度的人，再训练他们掌握适当、有用的技能——而不是反过来。 价值观是培养员工忠诚度的新途径。忠诚度并没有消失，只不过企业必须考争取才能获得，而且争取的方式与以往的区别越来越大了。 企业是繁荣昌盛的社会的重要组成部分。可惜，企业终究难免一死。 企业的死亡率这么高，是因为管理者只关心利润和成本，而不关心构成组织的人类群体。 企业长寿的最大奥妙就在于尽量少尝试新鲜事物。长寿老人一般都奉行洁身自好、谨慎克制的生活，公司也一样。长寿企业的4个主要特点：对自身所处的环境敏感，有凝聚力和强烈认同感，宽容，在财务上保守。 秩序和混沌只在一线之间","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"},{"name":"领导力","slug":"领导力","permalink":"https://lchml.com/tags/%E9%A2%86%E5%AF%BC%E5%8A%9B/"}]},{"title":"从0到1构建SaaS系统","slug":"build-saas","date":"2022-08-24T16:00:00.000Z","updated":"2022-08-25T04:06:36.455Z","comments":true,"path":"technology/build-saas/","link":"","permalink":"https://lchml.com/technology/build-saas/","excerpt":"SaaS系统的构建是基于互联网提供软件服务的应用模式。 在21世纪开始兴起的SaaS概念打破传统软件概念，SaaS模式随着互联网技术的发展和应用软件的成熟不断完善，是软件科技发展的最新趋势。","text":"SaaS系统的构建是基于互联网提供软件服务的应用模式。 在21世纪开始兴起的SaaS概念打破传统软件概念，SaaS模式随着互联网技术的发展和应用软件的成熟不断完善，是软件科技发展的最新趋势。 SaaS是什么定义相信大家都对云服务中的IaaS、PaaS、SaaS早就有所耳闻，现在更是衍生出了aPaaS、iPaaS、DaaS等等的类似概念。对于SaaS也有各种各样的定义，这里我们给出的定义是：SaaS是一种基于互联网提供服务和软件的交付模型，所有网络基础设施及软件、硬件运作平台的所有前期实施、后期维护都由SaaS平台完成，用户只需要租赁软件服务并通过互联网接入使用。SaaS模型依赖敏捷性和运营效率，作为推动增长、覆盖和创新的业务战略的支柱。 业内大家通常会以Salesforce作为SaaS的标杆。 价值目前市场上越来越多的企业和组织采用SaaS服务来替代原来传统的软件采购部署方式，其原因可以主要总结为以下几个方面。另外，相比于传统软件，SaaS的盈利模式也决定了客户的成功对于SaaS产商来说极其重要，只有客户成功了，才会有续费， SaaS项目才有办法继续下去。当然SaaS相比传统软件也会有一些缺点，如独立性、可控性、个性化等。 基础架构SaaS系统通常首先是一个普通的分布式系统，因此它一定具有分布式系统的所有组成要素，如服务发现、负载均衡、序列化协议、传输协议、授权认证、网络安全等等。 入口客户最直接接触的通常是SaaS系统的客户端，客户端的形式可以根据业务的需求决定，常见的有浏览器网页、移动端APP、小程序、智能设备等等。 客户端到服务器的入口通常是一个通用域名或者是每个租户的独立子域名。如网易互客的入口是huke.163.com，网易七鱼的入口是xxx.qiyukf.com。域名的背后就一定需要DNS的存在，需要配置出合理的DNS解析，通常传统的基于UDP的DNS服务容易受到中间人攻击，存在被劫持的风险，另外也存在被运营商封禁等情况，因此SaaS系统通常搭建自己的HTTPDNS来规避风险。 有了域名作为入口之后，下一步就是客户端和服务器之间的通信协议，对于少数简单的SaaS系统来说只要通过域名和HTTP协议就可以完成所有服务，但大部分SaaS系统都会存在双向通信的需求，因此还需要维护长连接通道，常用的如原生TCP协议，或websocket协议。另外如果业务中有媒体流传输的需求，还会用到UDP，RTP协议等等。当然，目前市场上对于各种场景和需求都有对应的成熟解决方案，因此SaaS系统通常不会去从0开始解决所有问题，如长链接和媒体流我们可以集成网易云信的服务来解决。 接入层接入层通常是各种路由协议以及多层代理组成，如运营商和AS之间通常用BGP协议或者三线，机房内部通常会有接入的三层交换机，四层代理等等。网易七鱼目前的接入方案如下图所示，而对于规模较小的业务，为了灵活性和性价比，通常会在交换机和Nginx之间加入四层代理nlb。这一层基本都是由集团的SA同学负责搭建和运维。 业务层这里我们不去讨论业务上的各种设计模式和分层，因此把接入层之后数据层之前的所有服务和设施统称为业务层。通常业务层是一个SaaS系统研发中投入资源最大的，线上问题如性能瓶颈、稳定性、安全漏洞等大部分都来自于业务层，因此该层也是开发和线上运维的重点。 在业务层目前SaaS系统最常用的还是微服务的架构，不同于IaaS或PaaS，SaaS业务的一个重要特征是其业务复杂度很高、业务链路很长，而微服务的架构刚好可以很好的应对这种情况。当然在业务刚开始的时候，我们可以用简单的单体应用来快速实现原型验证，等业务发展起来后再开始逐步微服务拆分。 流量通过接入层后，一般为了系统的灵活性，会通过Nginx的upstream来转发请求到网关，由网关统一分发到对应的业务服务，而业务服务又可以拆分为许多独立的微服务相互调用。这也就带来了SaaS系统中的大部分常见问题，如： 谁可以使用什么服务？（租户管理） 服务在哪里？（服务发现） 请求应该由哪个服务节点处理？（负载均衡） 信息怎么传输？（传输协议） 如何避免一个租户影响另一个租户？（资源隔离） 输入和输出如何表示？（序列化协议） 网络出现分区、超时或者服务出错了怎么办？（熔断、降级、服务治理） 服务权限如何管理？（认证授权） 如何保证通信安全？（网络安全） 重要程度和依赖关系怎么样？（服务分级） 如何保证不同机器的服务状态一致？（分布式数据一致性） 等等，这些全都需要研发人员投入大量的精力，每个点展开细说都是一个很大的话题。基于业务和技术的考虑，通常还需要引入消息队列、缓存、配置中心、定时任务等组件。 数据层所有业务逻辑，最后一定都会在数据存储上得到体现。在一个SaaS系统中，最常用的存储依然是关系型数据库，如我们的DDB、另外常用HBase、TiDB等作为冷数据存储，ES、MongoDB等作为对应功能的数据存储。因此SaaS系统中多个数据存储之间的一致性是一个需要重视的地方。 对象存储方面，我们集团内有Nos，市面上的云厂商也都有相应的服务，不需要自己构建。不论客户存储的对象还是系统中的某些资源，为了提高客户的访问速度，我们都需要有CDN的存在。 SaaS业务中还有一个常见的需求就是BI，这要求系统具有数据分析能力，OLAP数据库也是必不可少的，网易云商采用的是ClickHouse。 在某些特定的业务场景，也许还需要用到TSDB，录入智能设备的传感器读数，用户的活动轨迹，系统的状态变化等等。 数据层还有一个非常重要，但经常被忽视的话题就是数据合规。特别是对于SaaS业务，因为面向的客户都是企业和组织，因此数据的安全合规是非常重要的。例如网易云商有专门的中间件用于数据库的敏感数据加密。 运维能力到目前为止，一个SaaS系统基本已经搭建成型可以提供服务了。但是我们对系统的状态还一无所知，因此还要构建足够强大的运维能力。其中包括了可观测性、计量计费、快速恢复、故障演练、系统治理各个方面。以可观测性为例，我们需要采集系统中的各种数据并通过大量技术手段来观测系统的状态，如系统资源、业务指标、健康状态、链路追踪、业务埋点、报警管理、错误统计、流量水位、趋势分析、变更管理等。针对SaaS业务的特点，还需要特别对系统进行租户维度的监控和管理。 部署模式SaaS系统根据隔离程度的不一样可以分为三种部署模式，每种部署模式都会涉及到架构的调整适配，都有各自的优缺点。 共享模式指SaaS系统中的所有资源，如业务服务、数据存储等全部是共享的，这要是绝大分部SaaS系统一开始采用的模式，这种模式系统的优势是灵活性高，资源利用率高，采用集中化管理，开发运维更简单。缺点是租户间容易相互影响，合规性也容易被一些特定行业客户挑战，还有很难为不同租户提供差异化服务。 专属模式指SaaS系统中几乎所有资源都是租户独占的，这种部署模式的优势是每个租户有完全隔离的环境，租户之间不会有影响，可以针对不同租户提供个性化的服务。但是缺点也很明显，这种部署模式的资源利用率低，成本高，运维难度高，管理复杂。通常会被用于一些特定行业或者特殊需求的客户场景。 混合模式指SaaS系统中有部分资源是所有租户共享的，还有部分资源是租户独占的，这种模式是现在大型SaaS系统常见的部署模式，可以兼顾上面种模式的优缺点，针对不同的客户提供不同的解决方案。 未来发展上面简要介绍了搭建一个SaaS系统的主要过程，尽管SaaS的设计初衷是快速为特定业务场景提供垂直解决方案，但企业对跨业务跨部门的需求也越来越强烈，例如营销服务一体化、私域运营等场景。因此，业界无论在业务还是技术方面都还在不断的探索之中，例如对于SaaS的成本控制，合规性，可扩展性，针对不同租户的差异化服务等等，都是SaaS产商经常面临的难题。有人在探索部署方式的优化，有人在探索产品的设计方案，有人在探索低代码的模式，还有人在探索生态合作的方案。无论如何，大家的的努力都是在为了客户的成功，回到我们的起点，只有客户成功了，SaaS才有存在下去的价值。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"架构","slug":"架构","permalink":"https://lchml.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"SaaS","slug":"SaaS","permalink":"https://lchml.com/tags/SaaS/"},{"name":"分布式","slug":"分布式","permalink":"https://lchml.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"服务器","slug":"服务器","permalink":"https://lchml.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"《也许你该找个人聊聊》","slug":"yxngzgrll","date":"2022-08-10T16:00:00.000Z","updated":"2022-08-11T07:25:50.282Z","comments":true,"path":"book/yxngzgrll/","link":"","permalink":"https://lchml.com/book/yxngzgrll/","excerpt":"作者自己的人生经历就够传奇的，当过电视剧制作人，当过作家，并在30岁的时候决定转行去当医生，还顺利的考入了名牌大学医学院，开始和比自己年轻的多的同学们一起学解剖学理论，最后因为想要和患者有更长期的接触而选择了心理治疗师作为自己的职业。","text":"作者自己的人生经历就够传奇的，当过电视剧制作人，当过作家，并在30岁的时候决定转行去当医生，还顺利的考入了名牌大学医学院，开始和比自己年轻的多的同学们一起学解剖学理论，最后因为想要和患者有更长期的接触而选择了心理治疗师作为自己的职业。 书中讲述了作者作为心理治疗师帮助几位面对不同问题的患者，同时作者自己也作为患者在寻求另一位心理治疗师的帮助。看完后对其中的朱莉和约翰是印象最深的。特别是朱莉，无法想象看着自己生命的快速消逝却无能为力的那种无力和绝望，到后面身上的器官和组织一个个被摘除，对她来说一切都奢求，然后她却勇敢和乐观的面对了这样的人生。 全书陆陆续续看了有将近2个月，一是本身内容比较多，二是全书的节奏相对来说有点冗长。整体可以打85分吧，微信读书上的92分个人感觉偏高了。 以下是书中的一些摘除： 变化常常伴随着失去，无所失则不得变，正因如此，人们常说要去改变，却依然驻足原地。 如果你不能意识到“完美是幸福的敌人”，那你就剥夺了让自己快乐的权利。 他们或许无法想象抑郁症状能在短期内缓解，但其实他们根本不需要去想。去做一件事，再让这件事驱使你去做另一件事，用一个良性循环来替代一个恶性循环。大多数巨大的转变都是靠我们用数百个微不足道、甚至难以察觉的一小步积累而来的。 作者为了不结婚自己生孩子这一段经历，大受震撼。但作为接受中华文明的我来说，还是不太能接受 常人对新咨询师几乎都有一个相同的疑惑：假如不痛苦，你就不曾体味真实的人生；假如你也深陷痛苦，你凭什么帮助别人？ 你没法逃避痛苦，只能承认 瑞士著名心理学家卡尔·荣格说过：“人们会想尽办法，各种荒谬的办法，来避免面对自己的灵活。”，但他还说过：“只有直面灵活的人，才会觉醒。” 变化常常伴随着失去。无所失则不得变，正因如此，人们常常说着要去改变，却依然驻足原地。 四分之三从事临床心理治理的心理医生都是女性。 人格障碍分为三大类群： A群（具有古怪、奇异、反常的人格特质）：偏执型人格障碍，分裂样型人格障碍，分裂型人格障碍。 B群（具有戏剧化、不稳定的人格障碍）：反社会型人格障碍，边缘型人格障碍，表演型人格障碍，自恋性人格障碍。 C群（具有焦虑、恐惧的人格特质）：回避型人格障碍，依赖型人格障碍，强迫型人格障碍。 大多数值得做的事都不简单 男性在这个问题上通常处于劣势，因为对内心世界的探索不是他们成长历程中的主要课题——世俗也很少接受男性和别人分享自己的情绪和感受。就像女性常迫于文化压力不得不时刻注意自己的外表，社会给男性的压力则要求他们维持良好的情绪表象。 愤怒是大多数人最容易进入的情绪，因为它是指向外在的，愤怒的责怪别人能让你感到痛快又义正严词。但宣泄出来的情绪往往只是冰山一角，如果你透过表层去看，就能瞥见表象下积聚着更多的情绪，那些你没有意识到的或是不想表达出来的情绪：恐惧、无助、嫉妒、孤独、不安。如果你能包容这些更深层次的情绪，在足够长的时间里去理解它们，倾听它们的诉求，你将能更有效的管理你的愤怒，那你也就不会总是那么怒气冲冲的了。 安宁，不是要身处一个没有嘈杂、烦恼和辛劳的地方，而是即使身处繁杂之中依然保持内心的平静。 即使你拥有世上所有的真知灼见，但如果你在治疗之外的现实生活中不去作出改变，那再多的洞察，甚至治疗本身，都将毫无价值。 弗洛伊德称之为“强迫性重复”——人的潜意识会幻想：或许这一次我可以通过和一个新出现的但感觉熟悉的人接触，从而回到过去，抚平很久以前的创伤。但唯一的问题是，通过选择感觉熟悉的对象，人们百分之百会得到事与愿违的结果：旧伤口会被重新打开，人们只会变得更缺乏信心，感觉自己不值得被爱。 我们会将自己原生家庭内化，成为我们人际关系中不断重复的主旋律。 人们常常期望由别人来告诉自己该干什么，就好像别人手里有标准答案似的，又好像我们每天日常生活中做的那么多选择真的有对错之分。但其实人们又讨厌被告知应该要做什么。虽然人们会重复地、不厌其烦地要你告诉他们该做什么，但一旦你给出了建议，他们却不会释怀，而是感到怨恨。而且即使后续发展一切顺利，也无法避免人们心中的怨恨，因为人们最终还是希望在自己的生活中掌控话语权。 行动的越快，看到的就越少，因为在飞速移动中，一切都变得模糊了。 耐心的定义是“可以承受刺激、烦恼、不幸或痛苦，而不表现出抱怨、愤怒、急躁或诸如此类的反应”。很明显，生活的大部分就是由刺激、烦恼、不幸和痛苦组成的。在心理学上，耐心可以被认为是能够长期承受这些困境直到克服困难的能力。感受到悲伤或焦虑，也可以让你对自己和所处的世界有本质上的了解。 我发现只要人们一感受到孤单就会拿起一个设备来逃避这种感受。这通常发生在两件事中间的空档里。人们长期处于受干扰的状态下，似乎丧失了和别人相处的能力，也丧失了和自己相处的能力。 痛苦并没有高低等级之分——这也是我在心理治理师的专业培训中学到的最重要的道理之一。人们所受的折磨不应该拿来被比较。 我们是在人与人的关系中成长的。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"心理学","slug":"心理学","permalink":"https://lchml.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"《领导力的5个层次》","slug":"ldld5gcc","date":"2022-06-06T16:00:00.000Z","updated":"2022-06-07T06:25:18.735Z","comments":true,"path":"book/ldld5gcc/","link":"","permalink":"https://lchml.com/book/ldld5gcc/","excerpt":"网易集团领导力培训课前读物。全书总体来说鸡汤味有点浓，其中有大量的正确废话，写作风格有点像读书时写作文，为了论证观点引用大量的小故事或者名人名言。当然也有一定的收获，有一些之前没想到的或者认识的盲区。属于可以一读，但并不值得强烈推荐。","text":"网易集团领导力培训课前读物。全书总体来说鸡汤味有点浓，其中有大量的正确废话，写作风格有点像读书时写作文，为了论证观点引用大量的小故事或者名人名言。当然也有一定的收获，有一些之前没想到的或者认识的盲区。属于可以一读，但并不值得强烈推荐。 书中把领导力分为以下5个层次： 职位：权力，人们追随你是因为他们非听不可 认同：关系，人们追随你是因为他们愿意听你的。爱人者方能御人 生产：成果，人们追随你是因为你对组织所做的贡献。当你赢得胜利的时候，任何困难都能迎刃而解 个人发展：复制，人们追随你是因为你对他们所付出的。不在于拥有的巨大权力，而在于善于授权的能力 领袖特质：尊敬，人们追随你是因为你的领袖特质以及你所代表的东西 以下是一些原文摘抄： 对于不同人的而言，你并不是总在同一领导力层次上。人们会根据你对他们所处的领导力层次来决定自身行为 不论对于处在哪个层次的领导者，他们并不是自然而然就能保持在那个层次上。你要竭尽全力去赢得自己的领导力层次，并且你的层次随时会上升或下降。 你的领导力层次越高，领导力的实现就越容易，就越需要花费更多的时间与精力去再上新台阶。 领导力征程上每提升一个层次都是需要日积月累的，而后退确实瞬间可以完成的。 想要攀登新的领导力高峰，你要做对很多事情，但有时只要一件事情做错，就足以导致功败垂成。 你迈出的步伐越远，你的回报越大 一名领导者的成长是主动学习与经验积累的结合体。 在某一领导力层次上的固步自封会限制你和你的团队，领导能力决定一个人办事的成效水平。换言之，你完成任务的有效性和团队协作的能力受限于你的领导能力。 当你变换职位或者组织时，你基本上要从新的领导力层次开始 领导力就是接手追随者的现状，并将他们带向新的征程 你的价值观是你领导力的灵魂，它指导着你的行为 道德价值观——究竟什么是以“对”的理由做“对”的事？ 关系价值观——你该如何营造与他人相互信任、尊重的环境？ 成功价值观——什么样的目标值的你去终生追求？ 员工不会为他们不喜欢的领导者付出最大的努力。 成功需要绝大多数人的甘于付出，但也不会超出他们能力所及的范围。使事情变得与众不同就是优秀的领导力。 职位并不是值得所有人去追求的人生目标，所谓的安全感不能成为最终的目的。 人脉，而非职位，是一个领导者最宝贵的财富 领导者并不一定需要知道所有的答案，我们中每一个人的聪明才智都不及团队的智慧。 我是谁？ 我的价值观是什么？ 我想要将怎样的领导力付诸实践？ 学会说“我不知道”，当别人询问你不清楚的问题时，大胆承认，再向你的团队成员征求意见。 不领导别人你照旧可以关心他们，但是假如不去真心关心他们，你将不可能成为超越第一层次的高效领导者。 当危险嘎吱作响地来临时，人们会自觉的依附到那些他们知道可以信赖的人——那些没有离开而与他们同舟共济的人身边。 如果你踩着别人的肩膀爬上去，当你在往下走的时候他们会绊倒你 领导一个组织不仅仅要依靠机制，也与组织的灵魂休戚相关。高效的领导力从理解中获得源泉。 领导者必须从最大多数人的利益做出最好的决策。因此，领导者应放弃迎合某个个人的权力，如果这会伤害整个团队或组织。 要人们认同你的想法，必须先让他们接受你这个人 团队成员列在表中，并回答一下问题： 你知道这个人工作之外的哪三件事情？ 这个人认为什么最有价值？ 这个人前三大关注点是什么？ 这个人对于人生有怎么样的希望或期许？ 能否化梦想为现实是区别真正领导者与自封的领导者的试金石。 一个组织中的员工如果都不清楚自己的目标是什么那有何谈成功？ 人们会自然而然地追随比自己强的领导者 你是什么样的人就吸引什么样的人追随你 人的发展与培养是领导者最大的成就 生命的目的不只是成功。生命的目的是成长和分享。当你回首往事时，你会发现你给别人带去的快乐比战胜他们更能让自己得到满足。 领导者就像仆从一样，为员工们的工作清扫障碍。 这个人很有可能在哪里跌倒？ 这个人的盲点在哪里？ 我的直觉告诉我这个人的思维里缺了什么？ 为什么这个人没有释放出他的潜力？ 这个人在追随谁，谁又有可能将他引入歧途？ 这个人什么时候能够做好？ 这个人什么时候会失足犯错？ 对于一位领导者的检验是他留给其他人坚持下去的信念与力量。 写下一条学习格言，每天严格遵守；它应该描述出你保持可教状态的态度与行动。 找到一个或多个在领导力方面走在你前面的人，定期与他们见面从中学习。 专心于一种爱好、一项任务或者体育活动，它不仅让你觉得值得去付出时间与努力，而且也会极大的挑战你，是你保持谦逊的姿态。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"},{"name":"职场","slug":"职场","permalink":"https://lchml.com/tags/%E8%81%8C%E5%9C%BA/"}]},{"title":"《百年孤独》","slug":"bngd","date":"2022-06-04T16:00:00.000Z","updated":"2022-06-07T06:14:38.461Z","comments":true,"path":"book/bngd/","link":"","permalink":"https://lchml.com/book/bngd/","excerpt":"“马孔多在下雨。”","text":"“马孔多在下雨。” “多年以后，面对行刑队，奥里雷亚诺· 布恩迪亚上校将会回想起父亲带他去见识冰块的那个遥远的下午。”在惊艳的开头之后，出现的是各种冗长的重复的人名。大约六七年前，第一次翻开书，读了20多后页放弃了，第二次翻开书读了100多页后又放弃了。没想到在2022年端午节的连续三天大雨中，再次翻开书后就一发不可收拾，直到读完还意犹未尽。也不知道这六七年间是什么变了。 也许阅读《百年孤独》本身就需要孤独，布恩迪亚家族的宿命式的重复命名，其实也正是全书的重要线索。就像乌尔苏拉所说：“她从家族漫长的历史上重复命名的传统中得出了在她看来无可争辩的结论：所有 叫奥雷里亚诺的都性格孤僻，但头脑敏锐，富于洞察力；所有叫何塞·阿尔卡蒂奥的都性格冲动，富裕事业心，但命中注定带有悲剧色彩。” 随着何塞·阿尔卡蒂奥·布恩迪亚创建马孔多， 到最后一个奥雷里亚诺被蚂蚁吃掉的同时马孔多消失。一百年的时间，伴随着家族兴衰的同时，无数人的命运在历史潮流中沉浮。似乎谁都掌握不了自己的命运，唯有梅尔基亚德斯似乎从一开始就跳出了时间的桎梏，也只有他的房间似乎一直脱离时间而存在。又或者时间根本就不存在，因为羊皮卷中描述的家族宿命本就是全部一起发生的。 书中的马孔多就是南美洲的缩影，原生态的乡村，被带着强迫式的进入现代化，经历了保守派和自由派的战争，反抗殖民者的战争。上校为了自由派发起了无数次战争，最终却自己亲手结束了自己的战争，乃至最后所有的17个儿子都被全部暗杀。何塞·阿尔卡蒂奥第二的罢工行动遭到政府的残酷镇压，他成了车站大屠杀中唯一的幸存者。当他醒来时，看到了一生中最恐怖的场景：近两百多列车厢全部塞满了尸体，“像变质的香蕉一样被丢入大海”。然而更恐怖的是，在仅仅几年之后，在政府的宣传和教育下，根本没有人相信曾经发生过大屠杀。只有何塞·阿尔卡蒂奥第二至死都牢记着有三千四百零八人在车站被屠杀。并且教给奥雷里亚诺·巴比伦不要忘记。 书中有各种截然不同的女性角色，并且实际上是她们在努力维持着这个家族，有善良坚强的乌尔苏拉，有乐观天真的蕾梅黛丝，有偏执阴郁的阿玛兰旦，有任劳任怨的桑塔索菲亚，有勇敢热情的佩特拉，还有固执迂腐虚荣的费尔南达。 “过去都是假的，回忆是一条没有归途的路，以往的一切春天都无法复原，即使最狂热最坚贞的爱情，归根结底也不过是一种瞬息即逝的现实，唯有孤独永恒。” 以下是看完书后的主要人物关系梳理：","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"政治","slug":"政治","permalink":"https://lchml.com/tags/%E6%94%BF%E6%B2%BB/"},{"name":"文学","slug":"文学","permalink":"https://lchml.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"《建筑也可以很好玩：欧洲篇——从古希腊到文艺复兴》","slug":"jzykyhhw-eu","date":"2022-05-23T16:00:00.000Z","updated":"2022-06-07T06:26:13.255Z","comments":true,"path":"book/jzykyhhw-eu/","link":"","permalink":"https://lchml.com/book/jzykyhhw-eu/","excerpt":"看完《地下室手记》以后需要看点轻松的书来调节一下，刚好微信读书推荐了这个，确实还挺有意思的，不仅科普了建筑知识，还简单科普了古希腊到文艺复兴的欧洲历史。","text":"看完《地下室手记》以后需要看点轻松的书来调节一下，刚好微信读书推荐了这个，确实还挺有意思的，不仅科普了建筑知识，还简单科普了古希腊到文艺复兴的欧洲历史。书中涉及到历史，宗教，科学各方面，其中关于宗教大家有兴趣可以看我之前总结的《三教起源与关系》。了解了基督教、犹太教、伊斯兰教之间的关系后看本书会更顺畅。 看书时想到，如今地球上的主要文明，其实就是发源于地中海沿岸的欧洲文明，发源于两河的中东伊斯兰文明，以及发源于的中国的东亚文明三大文明。 看书的过程中建议大家对照地中海地图会有更直观的体会 古希腊建筑古希腊，爱琴海周围一圈的城邦，雅典和斯巴达，波希战争 雅典卫城集大成，多立克柱式，爱奥尼柱式，西方建筑的源头 古罗马建筑古罗马继承了古希腊的文化并发扬光大，科林斯柱式，科林斯实墙，拱券技术 维特鲁威的《建筑十书》奠定了欧洲古代建筑的基本体系 建筑三大终极定律：坚固、美观、实用 万神殿，角斗场 中世纪建筑罗马分裂东西以后，基督教发展，这段历史和前面的三大宗教渊源关系刚好对应，不熟悉的可以往前翻翻。 西罗马就是现在的西欧，8世纪末查理大帝统一西欧进入由教会统治的中世纪，后来分裂为法兰西、意大利、德意志（神圣罗马帝国） 西欧天主教主要以发源于巴西利卡的哥特式教堂为主，拉丁十字。双圆心尖券+飞扶壁 法国巴黎圣母院、意大利米兰大教堂、德国科隆大教堂 东欧东正教以发源于穹顶形式的集中式穹顶大空间为主的东正教教堂，希腊十字。帆拱 圣索菲亚大教堂，柏林大教堂，威尼斯圣马可教堂 独特的意大利罗曼式风格，比萨大教堂建筑群，券柱式。 文艺复兴时期建筑14世纪，佛罗伦萨开启文艺复兴 米开朗基罗的地表最牛教堂（没有之一）的圣彼得大教堂 文艺复兴三杰：达芬奇、米开朗基罗、拉斐尔（都是由美第奇家族资助），美第奇家族是佛罗伦萨城市的实际控制者。家族靠经商起家，但是成员有的做到佛罗伦萨统治者、有的做到教皇，政商教通吃。一个有钱又有品味的家族，如果没有他们的保护，很多文艺复兴的杰出大师可能早就被教会送上火刑架。 中世纪1000多年，基督教教权几乎完全控制了人们的精神生活。直到但丁的《神曲》标志着中世纪末期人主义开始觉醒。 中世纪末期两件事：拜占庭灭亡，黑死病。所以被视为黑暗时期 拜占庭苦苦支撑了1000年后终于被土耳其灭了，西欧就需要直面土耳其的蹂躏 黑死病直接带走了当时欧洲人口的三分之二（也有说二分之一） 文艺复兴的主要任务就是扫除中世纪的黑暗，建立新世界。各个领域的大师们都试图去恢复古希腊和古罗马的文明，核心是恢复以古希腊和古罗马为代表的人文主义和理性精神。重新肯定人的地位，人的伟大。 《神曲》标志着文学的开端 《蒙娜丽莎》标志着绘画的开端，中世纪的绘画中，人在神面前必须像蝼蚁一样卑微。而当你仔细看《蒙娜丽莎》，你会发现画中的那个女人自信、端庄，仿佛就是仙女一般，达芬奇故意将”神性“赋予给人。 佛罗伦萨主教堂（又称为圣母百花大教堂，伯鲁乃列斯基），穹顶内部壁画：《最后的审判》。标志着文艺复兴建筑的开端。 坦比哀多，作为一个天主教建筑，却拥有古典建筑的一切特点。整个建筑各部分比例和谐，体现着古希腊文化中的几何之美。几乎重新定义了后来欧洲宗教建筑的形式标准。梵蒂冈圣彼得大教堂，英国的圣保罗大教堂，美国的国会大厦。 教堂一帮都是为了献给基督教的大人物而建造的：上帝的儿子——耶稣，耶稣的老妈——圣母玛利亚，耶稣的十二门徒——如圣彼得、圣安德烈，耶稣的迷弟——圣保罗。 米开朗基罗用四年时间完成了西斯廷礼拜堂的天顶组画（600平方米） 米开朗基罗的《圣母怜子》雕塑，存于梵蒂冈圣彼得大教堂 梵蒂冈圣彼得大教堂是全世界最大最奢华最有故事的教堂，没有之一。教会和人文主义两派的拉锯，都想按照自己的世界观和统治需要来修建教堂。所以可以在圣彼得大教堂中看到不同时期，不同势力，不同建筑师留下的痕迹。 巴洛克风格巴洛克风格设计大神贝尼尼对教堂内部装饰以及教堂外面的大广场进行了设计。一种极度奢华和形式主义的风格。 有趣知识红桃K：查理曼帝国查里大帝 黑桃K：以色列国王大卫 方块K：古罗马凯撒大帝 梅花K：马其顿国王亚历山大","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"建筑","slug":"建筑","permalink":"https://lchml.com/tags/%E5%BB%BA%E7%AD%91/"}]},{"title":"《地下室手记》","slug":"dxssj","date":"2022-05-10T16:00:00.000Z","updated":"2022-05-12T06:01:14.672Z","comments":true,"path":"book/dxssj/","link":"","permalink":"https://lchml.com/book/dxssj/","excerpt":"读陀思妥耶夫斯基要谨慎，因为太痛苦。","text":"读陀思妥耶夫斯基要谨慎，因为太痛苦。 读后感一切贬义的负面的词语都能用来形容主人公：懦弱、自卑、敏感、卑劣。下流、猥琐、纠结、怪异、阴暗、虚荣、窝囊、无耻、季度成性、反复无常、自欺自人等等，然而最无奈的是什么？是我们总能从他身上发现自己的影子，也许这是因为所有这些原本就是人性中与生俱来的。 第一次读陀思妥耶夫斯基的作品，地下室人，也就是主人公永远都在矛盾和不断的臆想以及自我否定中试图寻找自己的自尊和虚荣。几乎每句话都是对前句话的反驳与嘲笑。越往后读，越感觉到作者真的是在对读者实施精神上的酷刑和拷问。原以为短短几万字的内容会很快就读完，万万没想到会读的如此艰难，甚至有些痛苦。第一次意识到理性的局限性，意识到理性在人性面前的矛盾和脆弱。理性是好东西，这是毋庸争议的，然后理性却终究只是理性，只能满足人的理性能力，而意愿确是整个生命的表现，也就是人的整个生命，既包括理性，也包括一切内心的骚动。地下室人对丽莎的指责和被丽莎撞见窘态后的崩溃的歇斯底里，看似极端却又合理。人可以在痛苦和被折磨之中发现可耻的快感并享受它。所有的矛盾和问题最终都指向“人是什么？” 摘抄我回到自己的小角落里，马上强烈地意识到，就在今天又干了一件卑鄙的事情，而已经做过的事情无论如何也无法挽回，因此就在内心深处暗自咬牙切齿地不断责备自己，翻来覆去的指摘自己，慢慢腾腾的折磨自己，以致那痛苦终于变成某种可耻的、令人诅咒的快感，而且——最终变成一种千真万确、货真价实的享受！ 你已经无路可走，你已经永远无法变成另一种人了。而且，即使还有时间和信心能够变成另一种什么人，那你自己大约也不想变了。而且，即便想变，大概也会一事无成了，因为实际上也许已经没有什么可变的了。 然而，人是如此热衷于构建体系，热衷于抽象结论，因此会随时准备存心歪曲真理，随时准备视而不见、听而不闻，而一个劲地维护自己的逻辑。 文明究竟使我们的什么东西变的温文尔雅了？文明只是在人身上培养除了丰富复杂度的发展，人甚至会进化到从鲜血中寻找享受。由于文明，人如果不是变的嗜血成性的话，那么至少变得比以往的嗜血成性更卑鄙、更丑恶。以往，他把血腥屠杀看作正义行为，因此心安理得地去消灭那些必须消灭的人；可如今，我们尽管认为血腥屠杀是丑恶勾当，可我们仍旧在干着这丑恶的勾当，甚至比以往干得更多。哪种更坏？——你们自己去评判吧。 人，无论何时何地，也不论他是什么样的人，都喜欢随心所欲的采取行动，而根本不希望按照理性和利益指明的那样去行动；他想要做的事也可能违反自身的利益，而有时完全应该违反。自己本人的、随心所欲的、自由自在的意愿，自己本人的、即便是最为野蛮的人性，自己本人的、有时被刺激到疯狂程度的幻想——这一切便是那被忽略掉的、最为有利的利益，正是它无法纳入任何一种分类，且总是使所有的体系和理论土崩瓦解。 理性是好东西，这是毋庸争议的，然后理性却终究只是理性，只能满足人的理性能力，而意愿确是整个生命的表现，也就是人的整个生命，既包括理性，也包括一切内心的骚动。 人却是一种思想轻浮、恬不知耻的生物，喜爱的只是达到目的的过程，而非目的本身。而且谁知道呢，也许人类在大地上追求的全部目的，仅仅就在于达到目的这一连续不断的过程，换句话说——就是生活本身，而非目的本身。 每个人的回忆里都有这样一些东西，它们不能公之于众，而只能向朋友们公开。还有一些东西，即使对朋友也不能公开，而只能对自己公开，而且还得在隐秘的情况下。然而，最后还有这样一些东西，甚至都害怕对自己公开，并且这样的东西，在每一个正派人那里都有相当多的积累。甚至可以这样说：一个人越是正派，这样的东西就越多。 人只喜欢计算自己经受了多少痛苦，而不喜欢计算自己得到了多少幸福。可如果公平合理地衡量衡量，那他就会发现，他是痛苦和幸福两者兼而有之。 人与世界关系的陌生化、人与他者关系的损毁，最终带来的是人与自我之间的危机。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"文学","slug":"文学","permalink":"https://lchml.com/tags/%E6%96%87%E5%AD%A6/"},{"name":"心理","slug":"心理","permalink":"https://lchml.com/tags/%E5%BF%83%E7%90%86/"}]},{"title":"《城乡中国》","slug":"cxzg","date":"2022-04-27T16:00:00.000Z","updated":"2022-05-12T06:03:47.726Z","comments":true,"path":"book/cxzg/","link":"","permalink":"https://lchml.com/book/cxzg/","excerpt":"作者这样的学者在中国是非常稀缺和重要的，直言直谏的价值有时候远远超过观点本身。邓公说过，我们要警惕右，但主要防止左，左带来的危害要远远大于右。","text":"作者这样的学者在中国是非常稀缺和重要的，直言直谏的价值有时候远远超过观点本身。邓公说过，我们要警惕右，但主要防止左，左带来的危害要远远大于右。 读后感此书带着大量经济学知识，加上大量作者的调研数据和观察总结，信息量很高，所以读起来会稍微有点慢。全书的核心思想就在于论证赋予农地转让权，让农地入市的合理性，正当性和必要性。作者作为国内著名经济学教授、北大院长，经济学方面的实力无需质疑。从书中学习到了很多经济学理论，还特地了解了书中经常提到的经济学家科斯。全书前半部分，有过于理想主义的经济学学者思维的感觉，信仰完全的自由市场经济模式，后半部分深入关于农地入市的主题后，不得不说非常有古代谏臣的感觉。虽然书中有很多观点我认为过于理想，并不赞同。但更重要的是，我认为作者这样的学者在中国是非常稀缺和重要的，直言直谏的价值有时候远远超过观点本身。邓公说过，我们要警惕右，但主要防止左，左带来的危害要远远大于右。 阅读中的思考政治权力和资本权力是当今世界的两大核心或者说方向，东西方的冲突本质上也是如此，各自都打着为人民为社会的旗号，其实唯独没有人民权力。 所谓的市场化，完全的自由市场必然会导致资本的集中和垄断。而所谓的国有化，完全的计划市场或者政府主导必然会导致权力的集中和垄断。 作者赶上了上山下乡的年代，可能是感受过当年的动荡和混乱，所以天然的会导致立场更偏右吧。 最后重点是虽然书中的部分观点我不认可，但我认为这样的学者在中国是非常稀缺和重要的，为何？因为我们要警惕右，但主要是防止“左”，左带来的危害远远大于右，可以把一切破坏的精光。而且可以看出来作者的出发点通常都是通过经济学给人民特别是农民带来更好的生活。 兰田村确权的例子，想到了显微镜下的大明中，开国之初为了造黄册确定版籍的事，几乎都是一模一样的问题，事情一旦落地最基层到具体的人身上，总会有意想不到的问题，于是就一定会产生上有政策下有对策的现象，执政的水平可能就是在这个矛盾和问题中如果寻找到一个合适的中间点。 看此书的过程中突然有点理解了父母一辈对土地的执着，在没有土地依然能过的不错，对生活也毫无影响的情况下，还是会见缝插针的想要利用每块可以耕种的土地。 我国在政府不仅在土地市场上具有垄断的卖方的地位，同时在土地政策上有太多的自由量裁权。权力的寻租现象古今中外都是社会的巨大危害，只有靠良好的制度才可能尽量杜绝。 完全自由的市场真的能自我调节吗？最后不会形成大资本垄断的局面吗？参考相对最接近自由市场的互联网行业的赢者通吃，最后土地还是会被大资本垄断，和现在的政治垄断又有什么区别，依旧是半斤八两吧。我认为目前人类社会在这方面还远远没有达到理想水平，所以不应该用现有的自由市场也好计划经济也好试图解决，期待有识之士能创造出更先进的理论体系。 邓公时代就提出的实践是检验真理的唯一标准，到现在也没有能很好的落实到行政管理上，更不要说某些领域甚至还倒退了。 中国的统治者甚至包括被统治者都太习惯于家长式的政府管理模式了，“给农民权利会损害农民利益”就是典型的家长式思维。好处是做对了决定行动极快效率极高，坏处是做错了决定也没有人能纠偏纠错，非要破坏个精光才能停下来。 一些摘抄中国目前是工业化超前，城市化落后的现状。 伦敦在早期是乡村生存不下去，继承不到财产的人才去村里，和中国古代是反过来的。 自由迁徙权，在新中国成立时写在宪法里，后来在1975被拿掉之后，没能再加回来。 在我们的上层建筑里，一直到今天也还值得注意的现象：讲归讲，做归做，谁也不难受。 一旦面对实际问题，压缩个人权利很容易就被选为实现整体目标的手段。 一直到2011年，我国城镇人口越过了总人口的51%。 ”城市土地国有化“以及”国有土地使用权的市场转让“共同铺就了我国城市化道路的制度基石。 ”行政垄断的土地市场化“：其一，土地使用权可以合法地在市场里流转；其二，土地的市场化流转，被行政权高度垄断。 增长常常成为膨胀的行政权力中的”人质“，由于行政主导构成中国高速经济增长的组成部分，因此当改革触及权力时，也可能连带影响增长速度。投鼠忌器，膨胀的权力为鼠，高速经济增长为器。 以强制力为后盾的工作作风一般缺乏耐心，这套工作机制，在某些场合很受用。比如对付”非典“，太婆婆妈妈就不成。救灾也不成，打仗就更讲军令如山了。这些场合需要快刀斩乱麻，令行禁止是上选。但是，遇到千家万户细细碎碎的实际利益，遇到人们的认知很发散、难有一致共识的情况，非要指哪打哪，偏好整齐划一、剑及屡及，后果一般好不了。 罗纳德·哈利·科斯，法律经济学创始人之一，诺贝尔经济学奖得主，芝加哥经济学派代表人物。提出”清楚的产权界定是市场交易的前提“。 自上而下推行的事，立意再正确，意义再重大，倘若没有底层响应，还是免不了成为落不得地的空头文章。 一个有意思的历史：1983年丽水缙云县养鸭业兴旺，这里养鸭的方式很特别，是大群”游牧“——小鸭孵出来个把月后，就一群一群地”离乡背井“，利用沿途水塘、小河、收禾后的稻田为天然饲料库，也补以人工饲料，边走边养。更离奇的是牧鸭范围，居然可以北达上海江苏，南抵福建广东，西至武汉。反正哪里市场需求大、出价高，哪里就是鸭子的最后归宿。鸭子游牧当然需要人看护，通常一群鸭子配两个全劳力、两个辅助劳力。”出游“时间，少则几个月一年，多则两三年在外。牧鸭人收益不错（平均每只鸭子得利5月，1983年），但是很辛苦，风餐露宿以外，还要与三教九流打交道。 受“大国末梢定理”支配，绝大多数村庄根本不可能专设多套管理机构，所以到处都是“三个牌牌一个门，说了算的还是那个人”。这也是日后“村官巨贪”现象的制度起源。 这是废除市场的代价。本来市价是个最简明的办法~有限的资源大家都想要，报个价，出价高者先得就摆平了。可非要说土地特殊，特殊到“市场失灵”，价格机制治好靠边站。 这是搞文件，不是写文章。这么大个国家，中央文件写的太细、太板，底下没法办。后来懂了，中国文件不能不给底下留下选择余地。文件层层下达后，读还是不读，可选；读哪句，不读哪句，也可选；读了怎么解，重点放到哪里，更可选。上面都写明白了，底下怎么办？ 脱离实际的目标，就是前面我讲过的用大词包装起来的那些个“伟大目标”，好听是好听——但凡选大词的时候，古今中外没有不好听的——但与现实脱节，根本无从下手，也无望实现，弄来弄去下不了台，只好滥用权力胡来。结果“词”很大，做出来的事却不堪回首，连那些大词也一并被糟蹋到无人再信才算拉到。 经验和逻辑都证明，分权分责又分利的分权体制，比较的优点就是一不出大错，二用利害相逼的学习机制及时纠错。 《人权宣言》说：自由即有权做一切无害于他人的任何事情。 社会治理的实践与法治，其实是不断在寻找群体生活中人们互相损害的最小可能性。 在目前情况下，同地不同权，国有土地可转让，集体土地不可转让，本身就是违宪的非法现象。 ”政府“无非就是最后的、唯一可以合法使用暴力的权威第三方。 论改革，如果只进行经济体制改革而回避政治体制改革，那经改就改不深，改出来的成果也可能得而复失。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"政治","slug":"政治","permalink":"https://lchml.com/tags/%E6%94%BF%E6%B2%BB/"},{"name":"经济","slug":"经济","permalink":"https://lchml.com/tags/%E7%BB%8F%E6%B5%8E/"}]},{"title":"《蛤蟆先生去看心理医生》","slug":"hmxsqkxlys","date":"2022-04-15T16:00:00.000Z","updated":"2022-05-12T06:00:47.751Z","comments":true,"path":"book/hmxsqkxlys/","link":"","permalink":"https://lchml.com/book/hmxsqkxlys/","excerpt":"跟着蛤蟆先生一起经历了心理上的自我剖析，阅读过程中常会有”原来如此“的感觉。每个人都有儿童状态、父母状态、成人状态。但实际上人总是会本能的逃避成人状态，因为这需要刻意的思考和学习。在儿童状态下的人容易抑郁，在父母状态下的人容易愤怒。学习这些之后可以让我们更了解自己了解别人，会去思考每个人包括自己情绪行为背后的心理状态。","text":"跟着蛤蟆先生一起经历了心理上的自我剖析，阅读过程中常会有”原来如此“的感觉。每个人都有儿童状态、父母状态、成人状态。但实际上人总是会本能的逃避成人状态，因为这需要刻意的思考和学习。在儿童状态下的人容易抑郁，在父母状态下的人容易愤怒。学习这些之后可以让我们更了解自己了解别人，会去思考每个人包括自己情绪行为背后的心理状态。 每个人都会有儿童自我状态，又可以分为自然型儿童，适应型儿童两种状态。 所以父母若是严厉挑剔，这个孩子就必须学习如何应对他们，他会将自然行为调整为最能适应现状的行为。 一个正在发展情感和情绪的孩子与他父母之间的纠葛，父母是那么固执地认定是非对错，又远比孩子强大的多，孩子们是怎么在这场战斗中存活下来的？ 真正让人惊讶的是我们成年后有多少行为是从童年学来的。你只要想一想，就会发现这其实非常明显。童年体验到最强烈的情绪，不可避免的变成我们成年后经常有的感受。 蛤蟆意识到那时在獾面前的忏悔只是表象，其实他是在防御獾对他的攻击。不是发自内心的东西，就不能带来真正的改变。 自我剖析很难，会让人想要逃避，因为它会带来痛苦感，但是在剖析之后我们会更了解自己。 父母就是仁慈的独裁者。 当你的愤怒遇到了父母的绝对权力，会发生什么？你得学习如何不带攻击性的发火。 你偷偷的或无意识的配合对方，来给自己制造不快，这就是在玩心理游戏，而且只有在游戏里输的人才算赢家。 我们看到的自己，并不一定总是我们喜欢的样子。从当下的你，变成你想成为的自己，必定要经历行为和态度的转变，需要付出艰辛的努力，需要勇气和决心。 每个人都会有父母自我状态，挑剔型父母会容易愤怒。 我们绝不是父母的翻版，虽然父母对我们的影响极大，但每个人自身的独特性确保了我们不是父亲或母亲的复制品，而是独立的个体。 没有一种批判比自我批判更强烈，也没有一个法官比我们自己更严苛。 “他更会倾听了，”鼹鼠回答，“这是关键。他开始懂得倾听，而且看上去是真的能听进我们的话。以前，你连一句话都说不完，他就来插嘴。说心里话，他看上去更友善、更平和，没以前那么烦人了。 我们称它为‘成人状态’。加上它，就形成了自我状态的三位一体，分别是父母、成人、儿童状态。这个三位一体也代表了人格的结构。 “‘成人自我状态￼’指我们用理性而不是情绪化的方式来行事。它让我们能应对此时此地正在发生的现实状况。” 单靠争论不能改变一个人的想法，只会让人更固执己见。 为什么进入成人状态很难？是因为这个过程需要艰辛的努力和刻意的思考。我们在另外两个状态时，像父母或儿童一样行事，几乎不需要去思考，因为我们知道要做什么，说什么，就好像在演习一样。 如果你为自己负责，就会认识到你对自己是有自主权的。因此你就知道自己有力量来改变处境，更重要的是，有力量改变你自己。 如果你想造一艘船，不要抓一批人来搜集材料，不要指挥他们做这个做那个，你只要叫他们如何渴望大海就够了——《小王子》 将自己的经历告诉别人，而不会因此被嘲笑或排斥，是多么大的慰藉。 所谓活的真实，就是真诚的回应当下的需求。真能打破从童年延续而来的因果循环，让真实的自我摆脱过去经历的束缚，在自由中成为真正的自己。 我不好，你好。受害者心理的游戏：我真不幸、可怜弱小的我、无论我做什么都要爱我。极端情况是自杀。儿童状态。 我好，你不好。占据权力和权威的制高点，总是会愤怒。抓到了你了你这个坏小孩，你为什么总让我失望，你怎么敢。总是需要攻击谴责被人。极端情况是谋杀。挑剔型父母状态。从来不会抑郁。 因为愤怒能够非常有效的抵抗抑郁。愤怒的人从不觉得内疚，因为他们总是在怪罪别人。他们自卫的方式，是把自己内在的恐惧对外投射到别人身上，这样就能把自己的怒火转向别人。 虽然你开始在理智上理解自己的行为，但要充分理解自我，唯有通过和自己的情绪做联结。当你对情绪的感受越来越清晰时，就能明白他们并非可有可无，也不会对它们不闻不问，因为情绪正是自我的核心。（直面自己的情绪，正确的表达情绪） 高情商的人：他们都有强大的自我意识，了解自己的情感。他们能管理情绪，能从悲伤和不幸中重新振作。但也许最重要的是，他们能控制冲动，也懂得延迟满足，从而避免轻率的决定和不妥的行为。 一个高情商的人能辨识他人的感受，这种技能称为”共情“。情感智力中最大的技能是通过理解和回应对方的情感，与他们建立良好的关系。 独立性隐含了做自己的自豪感，还包括独特的才能、与众不同的部分。独立的人时刻守护新发现的自主权，如同一个曾被殖民的国家重获自由一样。这当然没错，但共生性则体现出成熟和自我接纳，还包括求同存异的接纳他人。共生性可以让你在社交和工作上与别人有效联结，协同合作。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"心理学","slug":"心理学","permalink":"https://lchml.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"三教起源和关系","slug":"sjqygx","date":"2022-03-27T16:00:00.000Z","updated":"2022-12-06T08:59:39.245Z","comments":true,"path":"book/sjqygx/","link":"","permalink":"https://lchml.com/book/sjqygx/","excerpt":"我们都知道耶路撒冷被称为圣城，并且同时是三大教的圣城，但是为什么会这样呢？好奇之下翻了很多资料以及视频，在youtube上的一个视频对此做了比较系统又足够简洁的梳理，下面就总结一下内容。","text":"我们都知道耶路撒冷被称为圣城，并且同时是三大教的圣城，但是为什么会这样呢？好奇之下翻了很多资料以及视频，在youtube上的一个视频对此做了比较系统又足够简洁的梳理，下面就总结一下内容。 犹太教亚当和夏娃的后代中有一个叫诺亚，也就是造船的那个。 诺亚的后代中有一个叫亚伯拉罕，他从乌尔出发，在哈兰，上帝对他说，离开此地，远方有一片我应允你的土地 - 迦南，亚伯拉罕和上帝定下契约，上帝说我会给你一个伟大的国度。 雅各&#x2F;以色列，亚伯拉罕的孙子。上帝（或天使）对他说，你不要再叫雅各，要叫以色列。有4个妻子，12个孩子，这个群体叫做以色列人。 约瑟，以色列其中一个儿子，因为得宠，被兄弟当做努力卖到了埃及，帮助埃及法老解梦，成为了宰相。后来迦南发生大饥荒，以色列带着族人到埃及避难，约瑟不计前仇，法老把Goshen分给以色列人，以色列人越来越多，法老担心反客为主，下令奴役以色列人，持续400多年。 摩西，公元前1250年，出埃及记。因为杀了一个埃及人，开始逃亡，逃亡过程中遇到上帝，上帝让摩西回到埃及解救以色列人。过程中劈开红海，达到西奈山，和上帝谈话，上帝颁布了“十诫和律法”，摩西刻在石板上，这个就是犹太教信仰体系的根基。和神有过约定的民族，是被上帝选中的子民。最后回到迦南。 公元前1000年，当初12个儿子发展成12个部落，第11子的后代扫罗统一以色列王国，第二代国王扫罗儿子。第三代国王大卫，第四子犹大的后代，扫罗的女婿。第四代国王，所罗门。第五代分裂以色列王国和犹大王国。 公元前722年，亚述帝国扩张，以色列王国被灭，犹大帝国存活成为亚述帝国的附庸。现在的犹太Jew就是来源于犹大。（第一次放逐） 公元前597年，巴比伦王国打败亚述，把犹太人迁移到自己的土地当做奴隶。一直到公元前538年，巴比伦被波斯帝国打败，犹太人被释放，回到迦南地区。（第二次放逐） 公元70年，犹太人被罗马人打败，耶路撒冷被洗劫，神殿被毁坏，开始了2000多年世界各地的流亡，一直到第二次世界大战屠杀犹太人（第三次放逐） 1948年回到迦南地区，在上帝曾应许的领土上犹太人复国，取名为以色列。国旗的六芒星象征大卫王。 基督教耶稣的故事：塔纳赫语言在大卫的后代中将出现一位弥赛亚（救世主），统治犹太人，带领大家生活在理想国度。 公元0年，耶稣诞生，犹太人王，在加利利和犹大省布道。收了12个门徒，前往耶路撒冷。指责教会长老，犹大（和前面的犹大没有关系）为了30银币背叛耶稣。耶稣已经预言到自己会死，但是也会复活。犹太长老把耶稣交给罗马人。耶稣被罗马人拷打，自己背着十字架在耶路撒冷走，最后被钉死在十字架上。死后的第三天，一个叫抹大拉的玛利的女人，发现棺材里的尸体不见了。想去通知其他人，碰到了复活的耶稣。耶稣通知门徒到加利利的一座山上再会，40天后在加利利的山上，耶稣颁布了重要使命：让门徒们把他教导的传给世界，凡我所吩咐你们的，都教训他们遵守。之后耶稣就升天了。这时大约在公元30年之后左右。 耶稣说自己是预言中犹太人的救世主弥赛亚。不信的人： 还在等待弥赛亚的出现，也就是现在的犹太教。信的人：早期犹太基督徒，马太，马克，路加，约翰四个人写的书和后面的历史其他书整合起来。认为塔纳赫是上帝和子民旧的约定，所以是旧约。门徒所记载的耶稣也就是上帝和子民新的约定，所以是新约。基督教 基督徒主要看新约。耶稣替人类受难赎罪。信他才能上天堂。门徒在安条克开始向非犹太人传教，成为基督徒，普世教会。由于在罗马的地盘传教，所以一直被打压。直到君士坦丁最终皈依基督教，正式确认基督教合法。 公元325年，第一届大公会，讨论对经文的理解分析，教会的组织框架，仪式，耶稣的身份，第四届大公会才决定耶稣的二元论，既是人也是神。 公元331年，正宗版《圣经》定稿 公元380年，正式确立基督教为罗马国教。 东边是君士坦丁堡教会，希腊语为主（新约是用希腊语写的），西边是罗马教会，拉丁语为主。西边自称罗马教皇。 公元1054年，东西大分裂，西边自称罗马普世（Catholic）教会，传入中国翻译为天主教。 东边自称正宗（Orthodox）普世教会。 东边又称为东边的正统教会，简称东正教。主要在东欧和俄罗斯。 期间普世天主教腐败，公元1517年，马丁路德，宗教改革。重新解释，原本天主教认为生而有罪，行得救赎。马丁路德认为生而有罪，信得救赎。抗议教，翻译为新教。胸口笔画十字的是天主教，教皇也是天主教的。新教没有教皇。 基督教分为：天主教，东正教，新教（中国说的基督教） 基督就是希伯来语的弥赛亚，救世主的音译。 伊斯兰教认为耶稣是和摩西一样的地位，不是神，认为塔纳赫和新约都是被篡改过的。是最后一个先知穆罕默德把大家拉回了正轨。 公元610年，在迦南地区以南的阿拉伯半岛，穆罕默德居于麦加，在山洞里遇到了加百列天使，开始传播上帝的教诲，追随者越来越多。穆罕默德上上帝启示的记录写成了《古兰经》，伊斯兰教迅速发展。 公元1095年，西欧罗马天主教发动第一次十字军东征。拿下耶路撒冷，圣殿骑士团保护前往朝圣的人。然后被伊斯兰人夺回。然后以色列在美国支持下复国，拿走耶路撒冷。 原视频：https://www.youtube.com/watch?v=ncXCHdTFBEs","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"宗教","slug":"宗教","permalink":"https://lchml.com/tags/%E5%AE%97%E6%95%99/"}]},{"title":"《PPT演讲力》","slug":"pptyjl","date":"2022-03-24T16:00:00.000Z","updated":"2022-05-12T05:58:39.993Z","comments":true,"path":"book/pptyjl/","link":"","permalink":"https://lchml.com/book/pptyjl/","excerpt":"演讲本身就是你过往所有的人生阅历和智慧沉淀","text":"演讲本身就是你过往所有的人生阅历和智慧沉淀 演讲的大树模型 干——主题，让观众愿意听 带着观众去准备，带着目标去准备 满足三个要求：观众想听、你想说、场合需要 观众画像：讲给谁听？他们想听什么？演讲的目标是什么（越具体越好）？ 选定主题的三个标准：利他、要有结论、引人瞩目 枝——逻辑，让观众听得懂 开场30秒：承诺式、想象式、震惊式 三点式逻辑：一二三 三种结尾方式：金句结尾、号召结尾、点题结尾 关键时刻——年会演讲 问候和感谢，喜悦开场 成绩和不足，报喜也报忧 前景和目标，干成什么样 价值观和使命，霸气结尾 关键时刻——面试应聘 自我介绍（MTV）：Me我是谁？Task我为什么胜任这个职位？Value为什么录用我？ 最大的优点是什么（STAR）：Situation、Task、Action、Result 最大的缺点是什么：缺点、表现、反思、改进 职业规划是什么：和目标岗位契合、不会轻易离职、上进（技术或管理） 为什么离开上一家公司：围绕成长展开 关键时刻——竞聘演讲（4P） 自我介绍（Position） 胜任证据（Proof） 工作计划（Plan） 承诺拉票（Promise） 关键时刻——授课教学（4E） 吸睛导入（Eye） 激活讲解（Explain） 示范举例（Example） 练习反馈（Exam） 脑洞大开（Extrapolation） 回顾总结（Echo） 关键时刻——拿单谈判（关门逻辑） 痛点门（我为什么要买？） 方案门（我买的是什么？批评行业、以退为进） 案例门（我为什么要跟你买？） 优惠门（我为什么要现在买？三限促单法，限时、限量、现优惠） 关键时刻——融资演讲 项目概要：最好用一句话介绍项目在哪些领域能解决哪些问题 产品服务 商业模式 市场规模 竞争优势 团队介绍 融资策略 关键时刻——年终总结 标题要亮：问题型、数字型、金句型 逻辑要清 引言要精：用最亮眼。最数字化、最提纲挈领的方式，集中展现工作成果，起到摘要的作用 重点业绩——里程碑、对核心业务的贡献 重点工作——抓住工作重点和几个突出的成绩、亮点来阐述 常规工作——在于体现自己既关注重点工作，也不落下日常工作 业绩要显：有数字（数字化可视化）、有故事 不足要有：情景、冲突、疑问、回答 计划要细：时间点清晰、计划有主次、实施方案详尽、每个环节有责任人 感谢要高：功劳越让越多，越抢越少 关键时刻——上台主持 搞气氛 推嘉宾：主题，重要性，主讲人 顺流程 叶——故事，让观众记得住 HIT：幽默感（Humor）、画面感（Image）、转折（Turn） 幽默感 自黑，找无关痛痒的“缺点”，如外形、性格、犯过的错、悲惨经历 用好黑点：自黑关联演讲、用自黑反击他黑、用自黑表达实力 把PPT变成捧哏，可以用图片 谜面留给演讲者，谜底留给PPT 情理之中留给演讲者，意料之外留给PPT 注意事项：及时隐藏、留足时间 段子公式： 埋包袱A+停顿1+重读词&#x2F;句+抖包袱B+停顿2 改编俗语——AB&#x3D;AC A+屎尿屁或猪狗驴 画面感 用类比：就像、相当于 数字化+可视化 用道具 身体：着装、身体语言、脸到（微笑）眼到（眼神交流）手到（肢体语言，不要夹紧两肋）身到（横向走位和纵向走位）声到（声音大、有节奏、有变化、有停顿） 转折 对观众提问 果——影响，让观众有行动 围绕一个可以传播的观点，重复重复再重复： 观点只要一个 观点要重复 观点要新颖 观点要小角度切入：小角度-大挖掘-大思考-大激动的演讲-最后输出大道理 打造个人IP 第一步，IP定位，自我介绍，让别人一下子记住你 第二步，围绕个人IP长期优质输出，输出的过程就是传播营销 根——能量，让观众有启发演讲本身是一种能量的传递，演讲的根就是做自己，不要为演讲而去表演一个陌生人。顶级演讲者是有感情和能调动观众感情的人 如何做到有感情？ 场景化：真实且具体的时间、地点、人物 素材华：建立共鸣故事素材库 找敌人：敢爱真善美，敢恨假丑恶 五个现场互动技巧 要掌声 要举手 要奖励 要回声 要托儿 平时要有积累素材的习惯： 金句子、金段子、金排版 好的故事 演讲细节和意外应对技巧所有演讲者在台上大放光彩，都是在台下勤学苦练的结果 六步准备 1、写逐字稿 2、对着PPT念两遍逐字稿（三改：书面语改为口语、长句改为短句、单音词改为双音词） 3、脱稿讲三遍（不要背稿，按逻辑走，重点：开场白、金句子、金段子、结尾） 4、手机录音讲一遍（复盘问题，卡壳，节奏，感情） 5、对着别人讲一遍（身体语言） 6、提前到现场再过一遍逐字稿","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"演讲","slug":"演讲","permalink":"https://lchml.com/tags/%E6%BC%94%E8%AE%B2/"},{"name":"PPT","slug":"PPT","permalink":"https://lchml.com/tags/PPT/"}]},{"title":"《圆圈正义》","slug":"yqzy","date":"2022-03-22T16:00:00.000Z","updated":"2022-05-12T06:12:23.935Z","comments":true,"path":"book/yqzy/","link":"","permalink":"https://lchml.com/book/yqzy/","excerpt":"罗翔老师的杂文集，书中通常会从司法的角度分析问题，但更多的是从哲学和道德的层面在讲述。阅读过程中能感受到作者带有理想主义，悲观而又温暖的思考。让我知道了法治和法家的区别，知道了法律的尽头是道德，是一般民众朴素的期待。","text":"罗翔老师的杂文集，书中通常会从司法的角度分析问题，但更多的是从哲学和道德的层面在讲述。阅读过程中能感受到作者带有理想主义，悲观而又温暖的思考。让我知道了法治和法家的区别，知道了法律的尽头是道德，是一般民众朴素的期待。 读后感作者提到很多问题，比如功利主义，虚无主义，极端自由主义等等，都能很好的帮我们理解社会理解自己，时刻警惕自己人性的幽暗面，自己的虚荣心。时刻谨记真实的生活意味着承认自己的有限、浅薄和虚荣。要记得爱人如己，要记得谨慎、节制、公正、坚毅的品质。 巧合的是，由于之前一段时间阅读了不少中华文明，中国历史相关的书籍，再加上近来西方国家的表现和国内媒体的报道，让自己一度陷入中华文明最伟大，西方文明不过如此的迷恋之中。幸好，在这本书中罗老师借用了许多西方文明的伟大先驱和哲学思想，提醒了我各大文明一直都是各有长处，也同样各有缺点。我们要做的不是去迷恋一个或鄙视一个，而应该集各家之所长来不断提高自己。 另外也多了一些关于民主的思考，民主中有一个重要的悖论——多数人的暴政。而民主，本身就是可以操控的，因为不可能每个人都足够理性，都能独立思考，更多的是被引导被思考，再加上现代社会中，发达的媒体加上互联网的辅助，可以非常容易的给每个人编织信息茧房，同时还让每个人都觉得自己是在独立思考。这些都让暴政更容易成为现实。 当然对于当下互联网一代的人来说，可能很多人会觉得鸡汤味略浓。但我们别忘了，鸡汤从来不是贬义的，只有毒鸡汤才是。 此书让我想起了当老师的梦想，可惜的是处于经济的困难和学历的限制等因素，依然还是梦想。 摘录 以下摘录了一些书中个人觉得有价值的文字 绝对的权力导致绝对的腐败，同时也绝对导致自恋。 法治和法家的重要区别，在于一个是对权力的约束，一个是权力的工具. 往往是那些善良的愿望，把人类带入了人间地狱. 法治的基本要义在于用公开的规则去约束权力，让民众能够有合理的预期，免于惶惶未知的恐惧。合理的预期是包括人类在内的所有生物的基本天性。 让幸福感持续的唯一方法就是以感恩的心、谦卑的心接受一切成功与失败。 如果你认为是自己的才干、智慧让你获得了成功，那你注定不会幸福。因为这样的你在成功时，你会目空一切、狂妄自大，在得意中自我毁灭；在失败时，你会自怨自艾、愤怒嫉妒。甚至自寻短见。 我们常说天道酬勤，但事实上，人生的许多成就，个人的努力虽然重要，但自己能决定的其实很少。有许多重要的关头，许多贵人相助其实是可遇不可求的。 个人的努力在于机会来临时能抓住，而机会是否来临合适来临不是自己能决定的。 我很想做一个勇敢的人，但我并不知道当真正的挑战来临的时候，我会不会像自己想象的甚至所宣称的那般勇敢。 人类的本性就是喜欢拉帮结派. 司法真正忌惮的从来不是舆论，而是舆论背后那种捉摸不定的权力意志。 加缪告诉我们，任何事情都无任何意义，如果我们不能肯定任何价值观念，那么任何事情都可能发生——既无对也无错。(个人感想：随着年纪阅历的增长，确实越来越多的会陷入虚无主义的困境) 对抽象的人类的爱是无须付出代价的，但对具体的人的爱则总是要投入大量的时间和精力。 我们越想按照既定的计划来规划时间，我们就越会对突如起来的事件心生怨恨。如果对未知之事保持一种开放之心，受到一种生活在愉悦的漠然之中的召唤，人生也许会无比幸福。 极端自由主义，穆勒看来，只要行为不妨害他人，法律就不得干涉。 知识经常会让人骄傲，给人带来智力上的优越感，让你瞧不起人，无法与人建立正常的人际关系。 伪善的人最喜欢空谈崇高的话题。他们活在崇高的理念之下，用这种理念逃避对具体个体的责任，为自己的虚伪批上神圣的外袍。 功利主义：是否行为取决于行为结果对自己的影响 希腊文化是人本主义，自由得不到很好的约束。中华文化是民本主义，权力得不到很好的约束。 我们每天都在原谅一个不那么可爱的自己，那么当别人做错事的时候，当别人冒犯你的时候，你是不是也能够爱人如己，推己及人呢。 鲁迅说：勇者愤怒，抽刃向更强者，怯者愤怒，却抽刃向更弱者。 已有的事，后必再有；已行的事，后必再行。日光之下，并无新事。历史似乎给我们的唯一教训就是人类从来不接受教训。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"哲学","slug":"哲学","permalink":"https://lchml.com/tags/%E5%93%B2%E5%AD%A6/"},{"name":"法律","slug":"法律","permalink":"https://lchml.com/tags/%E6%B3%95%E5%BE%8B/"}]},{"title":"《无规则游戏：阿富汗屡被中断的历史》","slug":"wgzyx","date":"2022-03-17T16:00:00.000Z","updated":"2023-04-27T03:09:41.091Z","comments":true,"path":"book/wgzyx/","link":"","permalink":"https://lchml.com/book/wgzyx/","excerpt":"“院子里的一条好狗，比首都的好国王更有用。” —— 阿富汗民谚","text":"“院子里的一条好狗，比首都的好国王更有用。” —— 阿富汗民谚 在18世纪才刚刚从原始社会变成一个民族国家的阿富汗，欧亚大陆各大文明的交汇之地，各大帝国的利益所在，地理和历史就决定了这是一个不会太平的地方。对比中华文明，相当于阿富汗需要在短短两百多年时间，完成中华文明几千年的发展，这几乎是不可能的事情。所以他们在两百年前还在上演着中国两千多年前的士族门阀制度，人民的思想和“王侯将相宁有种乎的”还有太远的距离。一百多年前的国王还在试图进行像商鞅那样的消除门阀加强中央集权的改革。然而给阿富汗的时间太短了，期间更有英国、苏联、美国各种帝国势力的入侵或干涉，所有的这些就汇集成了一个混乱误解的阿富汗。 同时纵观世界历史，也再次印证了，在国际关系上利益才是不变的底层逻辑，美国为了利益通过巴基斯坦三军请报局扶持了塔利班，之后同样为了利益赶走了塔利班，如今依旧是为了利益逃离了阿富汗，从政治的角度，没有人在意阿富汗是什么样子，只在意阿富汗的样子是不是符合自己的利益。 介于最近的俄乌战争，在阅读过程中有一个很深的感触，就好像同时存在两个世界。一个是阅读的世界，这里基本上没有人讨论民主自由或是独裁专制，这并不是两个相互对立的极端，都只是实现目标的手端或方式，大家更关注的是社会运行的规则，是否能符合当下的实现，是否能带来效果，是否能实现社会的目标。还有一个是互联网社交媒体的世界里，没有人关心实际的社会和具体的人，每个人只关注口号，关注站队，关注意识形态，似乎意识形态就能解决所有问题。然而实际上意识形态并不能带来发展和进步，不能解决实际的社会问题。 其实文明本身就是建立在暴力的基础上的，就好像再发达再文明的社会都需要有暴力机构来维护一样，只有在暴力的基础上才可能有有限的文明。阿富汗动乱的根源洽洽不在于暴力，而是其历史和地理让它没有能发展出足够强大的暴力，所以这片土地上总是在循环往复的重复暴力，重复无规则的游戏。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"政治","slug":"政治","permalink":"https://lchml.com/tags/%E6%94%BF%E6%B2%BB/"},{"name":"经济","slug":"经济","permalink":"https://lchml.com/tags/%E7%BB%8F%E6%B5%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"}]},{"title":"《置身事内》——中国政府与经济发展","slug":"zssn","date":"2021-12-31T16:00:00.000Z","updated":"2022-05-12T05:56:08.621Z","comments":true,"path":"book/zssn/","link":"","permalink":"https://lchml.com/book/zssn/","excerpt":"看完此书，最大的感受就是，经济规律和金融制度才是当今世界的底层逻辑。作者用非常通俗易懂的语言很好的讲解了中国政府和中国经济的发展，理解了这个发展逻辑，我们就能更好的理解身边的一些事情。比如政府为什么不想让房价涨，但是为什么房价又不得不涨的原因。比如为什么中美贸易战其实是一个必然的结果。比如所谓权力，实质就是在说不清楚的情况下由谁来拍板决策的问题。比如政府为什么都需要有各种城投公司。对当下政治和经济有兴趣的人，此书都值得一读。","text":"看完此书，最大的感受就是，经济规律和金融制度才是当今世界的底层逻辑。作者用非常通俗易懂的语言很好的讲解了中国政府和中国经济的发展，理解了这个发展逻辑，我们就能更好的理解身边的一些事情。比如政府为什么不想让房价涨，但是为什么房价又不得不涨的原因。比如为什么中美贸易战其实是一个必然的结果。比如所谓权力，实质就是在说不清楚的情况下由谁来拍板决策的问题。比如政府为什么都需要有各种城投公司。对当下政治和经济有兴趣的人，此书都值得一读。 中国五级政府管理体系：中央-省-市-县区-乡镇 中国政府管理制度：条块分割，多重领导。 我国政治体制的一个鲜明特征是“层层复制”：中央的主要正职架构，即党委、政府、人大、政协等。省市县三级都完全复制，即所谓“四套班子”。 浙江以吴语方言复杂多变闻名，而吴语方言的分布与省内地市的划分高度重合：台州属于吴语台州片，温州属于瓯江片，金华则属于婺州片。同一市内，语言文化分布也会影响到区县划分。杭州下辖的淳安和建德两县，属于皖南的徽文化和徽语区，而其他县及杭州市区，则属于吴语区的太湖片。 因为信息复杂，不可信的信息比比皆是，而权力和责任又高度个人化，所以体制内的规章制度无法完全取代个人信任。上级在提拔下级时，除考虑工作能力外，关键岗位上都要尽量安排信得过的人。 事权划分的三大原则：公共服务的规模经济、信息复杂性、激励相容。 1994年分税制改革是很多重大经济现象的分水岭，也是城市化模式的分水岭。 财税与政府行为的关系，中间多次财税改革，加强中央财政，开始搞土地财政，再引申出政府投融资，政府不可以直接向银行借贷，所以需要设立城投公司。各种xx城投公司。招商引资，地方债务。 光伏产业，地方政府的投资反过来也可能引起产能过剩 私募基金，有限合伙模式GP、LP，政府产业引导基金。绝大多数政府引导基金最终都投向了战略性新兴产业（以下简称“战新产业”） 经济发展是企业、政府、社会合力的结果，具体合作方式取决于各自占有的资源，而这些资源禀赋的分布格局由历史决定。我国的经济改革脱胎于计划经济，政府手中掌握大量对产业发展至关重要的资源，如土地、银行、大学和科研机构等，所以必然会以各种方式深度参与工业化进程。政府和市场间没有黑白分明的界限，几乎所有的重要现象，都是这两种组织和资源互动的结果。 20世纪90年代中期至21世纪初期，基础设施不完善、法制环境不理想、资本市场和社会信用机制不健全，因此以信用级别高的地方政府和国企为主体、以土地为杠杆，可以撬动大量资源，加速投资进程，推动快速城市化和工业化。这种模式的成就有目共睹，但也会带来如下后果：与土地相关的腐败猖獗；城市化以“地”为本，忽略了“人”，民生支出不足，教育、医疗等公共服务供给滞后；房价飞涨，债务急升；经济过度依赖投资，既表现在民众收入不高所以消费不足，也表现在过剩产能无法被国内消化、向国际输出时又引起贸易失衡和冲突。 地方政府推动经济发展的模式： 第一个特点是城市化过程中“重土地、轻人”，优点是可以快速推进城市化和基础设施建设，缺点是公共服务供给不足，推高了房价和居民债务负担，拉大了地区差距和贫富差距。 第二个特点是招商引资竞争中“重规模、重扩张”，优点是推动了企业成长和快速工业化，缺点是加重了债务负担。企业、地方政府、居民三部门债务互相作用，加大了经济整体的债务和金融风险。 第三个特点是发展战略“重投资、重生产、轻消费”，优点是拉动了经济快速增长，扩大了对外贸易，使我国迅速成为制造业强国，缺点是经济结构不平衡。 1980年，我国城镇常住人口占总人口比重不足两成，2019年超过了六成 按照国家统计局的数据，自1998年住房商品化改革以来，全国商品房均价在20年间涨了4.2倍。 2015年之前的十年间，北、上、广、深房价翻了两番，年均增速13%。 2002年至2007年，美国房价平均涨了将近60%。危机之后，房价从2007年的最高点一直下跌到2012年，累积跌幅27%，之后逐步回升，2016年才又回到十年前的高点。 2008年之后的10年，我国房价急速上涨，按揭总量越来越大，居民债务负担上涨了3倍多。2018年末，居民债务占GDP的比重约为54%，虽仍低于美国的76%，但已接近德国和日本。根据中国人民银行的信贷总量数据，居民债务中有53%是住房贷款，24%是各类消费贷（如车贷）。 2019年末，中国人民银行调查统计司调查了全国3万余户城镇居民（农民负债率一般较低，大多没有房贷）的收入和债务情况。接近六成家庭有负债，平均债务收入比为1.6，也就是说债务相当于1.6倍的家庭年收入。这个负担不低，接近美国。2000年，美国家庭负债收入比约为1.5，2008全球金融危机前飙升至2.1，之后回落到1.7左右。 根据中国人民银行的调查，城镇居民2019年的负债中有76%是房贷。而从资产端看，城镇居民的主要财产也就是房子。房产占了家庭资产的近七成，其中六成是住房，一成是商铺。而在美国居民的财富中，72%是金融资产，房产占比不到28%。(15)中国人财富的压舱石是房子，美国人财富的压舱石是金融资产。这个重大差别可以帮助理解两国的一些基本政策，比如中国对房市的重视以及美国对股市的重视。 以买车为例，这是房子之外最贵的消费品类，对宏观经济非常重要，约占我国社会商品零售总额的10%。车是典型的奢侈品，需求收入弹性很大，收入增加时需求大增，收入减少时需求大减。2018年的私家车数量是2005年的14倍。但是从2018年下半年开始，“贸易战”升级，未来经济形势不确定性增大，轿车销量开始下降，一直到2019年底，几乎每个月同比都在下降。在新冠肺炎疫情影响之下，2020年2月份的销量同比下跌八成，3月份同比下跌四成，各地于是纷纷出台刺激汽车消费的政策。 美国州与州之间虽然规模差别很大，但人均GDP差别很小，无论生活在哪个州，平均生活水平都差不太多。 要想平衡地区间的发展差距，关键是要平衡人均差距而不是规模差距。想达到地区间规模的平均是不可能的。 正是这些看上去低技能的服务业工作，支撑着大城市的繁华，也支撑着所谓“高端人才”的生活质量。若没有物美价廉的服务，生活成本会急升。如果一个城市只想要高技能人才，结果多半会事与愿违：服务业价格会越来越高，收入会被生活成本侵蚀，各种不便利也会让生活质量下降，“高端人才”最终可能也不得不离开。 重庆的地票制度相当于土地供给翻了一番，所以房价一直比较稳定。 2008年的全球金融危机让穷人财富大幅缩水，贫富差距进一步扩大，引发了“占领华尔街运动”，之后特朗普当选，美国政治和社会的分裂越来越严重。 人们在乐观时往往会低估负债的风险，过多借债。当风险出现时，又会因为债务负担沉重而缺乏腾挪空间，没办法应对。 银行可以卖给老百姓一个理财产品，利息5%，再把筹来的钱委托给信托公司，让信托公司把钱借给房企。在这笔“银信合作”业务中，发行的理财产品不算银行储蓄，委托给信托公司的投资不算银行贷款，所以这笔“表外业务”就绕开了对银行的监管，是一种“影子银行”业务。 过去40年，我国的名义GDP增长了242倍，大家从每个月挣二三十元变成了挣四五千元，动作稍微慢一点，就被时代甩在了后面。身在其中的风风火火、慌慌张张、大起大落、大喜大悲，其他国家的人无论有多少知识和理论，都没有切身感受。 如果能帮助读者理解身边的一些事情，从热闹的政经新闻中看出些门道，从严肃的政府文件中觉察出些机会，争取改善一下生活，哪怕只是增加些谈资，也足够了。我是个经济学家，基于专业训练的朴素信念也有一个：生活过得好一点，比大多数宏伟更宏伟。 （相对于金融机制来说，上班拿固定工资这种赚钱的方式简直相当于原始社会。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"政治","slug":"政治","permalink":"https://lchml.com/tags/%E6%94%BF%E6%B2%BB/"},{"name":"经济","slug":"经济","permalink":"https://lchml.com/tags/%E7%BB%8F%E6%B5%8E/"}]},{"title":"《中国哲学简史》摘抄","slug":"zgzxjs","date":"2021-12-11T16:00:00.000Z","updated":"2022-05-12T05:56:18.163Z","comments":true,"path":"book/zgzxjs/","link":"","permalink":"https://lchml.com/book/zgzxjs/","excerpt":"本来想称为摘要，但是由于此书本身就是作者在自己的《中国哲学史》著作的基础上精简而成，已经是摘要中的摘要，当得起字字珠玑四字，很难再从其中做出摘要，任何的摘要都不足以展示此书的精髓。因此本文只能说是对书中的一些感兴趣的知识点所做摘抄。在看书的过程中突然觉得似乎当今社会大部分人的哲学思维依旧停留在先秦诸子百家时期。","text":"本来想称为摘要，但是由于此书本身就是作者在自己的《中国哲学史》著作的基础上精简而成，已经是摘要中的摘要，当得起字字珠玑四字，很难再从其中做出摘要，任何的摘要都不足以展示此书的精髓。因此本文只能说是对书中的一些感兴趣的知识点所做摘抄。在看书的过程中突然觉得似乎当今社会大部分人的哲学思维依旧停留在先秦诸子百家时期。 深以为此书和《中国通史》两本书应该作为中国人必读之书。能把晦涩艰深的中国几千年的哲学及其发展史写的如此浅显易懂，足见作者的哲学功底之强，称得上学贯中西，博古通今。全书通过梳理诸子百家中主要的儒家、墨家、道家、名家、阴阳家、法家，以及之后的佛学、新道家、禅宗、新儒家，到最后西方哲学的传入。系统的解释了中国几千年来的哲学变化，也就间接的讲述了中国人几千年来思维方式的变化。 关于哲学对哲学的定义：就是对于人生的有系统的反思的思想。 作者认为中国历来以文化区分彼此，而非种族。并深刻论述了当时世界环境与战国时的相似之处。 按照中国哲学的传统，哲学的任务不是为了人对客观实际增加正面的知识，而是为了提高人的心智 哲学在中国文化中所占的地位，历来可以与宗教在其他文化中的地位相比。宗教也和人生有关系。每种大宗教的核心都有一种哲学。事实上，每种大宗教就是一种哲学加上一定的上层建筑，包括迷信、教条、仪式和组织。这就是我所说的宗教。 人们习惯于说中国有三教：儒教、道教、佛教。我们已经看出，儒家不是宗教。至于道家，它是一个哲学的学派；而道教才是宗教，二者有其区别。道家与道教的教义不仅不同，甚至相反。道家教人顺乎自然，而道教教人反乎自然。举例来说，照老子、庄子讲，生而有死是自然过程，人应当平静地顺着这个自然过程。但是道教的主要教义则是如何避免死亡的原理和方术，显然是反乎自然而行的。 作为哲学的佛学与作为宗教的佛教，也有区别。受过教育的中国人，对佛学比对佛教感兴趣得多。中国的丧祭，和尚和道士一起参加，这是很常见的。中国人即使信奉宗教，也是有哲学意味的。 从入世的哲学观点看，出世的哲学是太理想主义的、无实用的、消极的。从出世的哲学观点看，入世的哲学太现实主义了、太肤浅了。它也许是积极的，但是就像走错了路的人的快跑：越跑得快，越错得很。 古代中国和希腊的哲学家不仅生活于不同的地理条件，也生活于不同的经济条件。因此也就产生了完全不同的哲学观点。 《论语》说：“子曰：知者乐水，仁者乐山；知者动，仁者静；知者乐，仁者寿。” 哲学，特别是形上学，它的用处不是增加实际的知识，而是提高精神的境界。 人与其他动物的不同，在于人做某事时，他了解他在做什么，并且自觉他在做。正是这种觉解，使他正在做的对于他有了意义。 不同的人可能做相同的事，但是各人的觉解程度不同，所做的事对于他们也就各有不同的意义。每个人各有自己的人生境界，与其他任何个人的都不完全相同。它们是：自然境界、功利境界、道德境界、天地境界。 禅宗有个故事说：“俱胝和尚，凡有诘问，唯举一指。后有童子，因外人问：‘和尚说何法要？’童子亦竖起一指。胝闻，遂以刃断其指，童子号哭而去。胝复召子，童子回首，胝却竖其指，童子忽然领悟。” 在使用负的方法之前，哲学家或学哲学的学生必须通过正的方法；在达到哲学的单纯性之前，他必须通过哲学的复杂性。人必须先说很多话，然后保持静默。 诸子百家刘歆将“百家”分为十个主要的派别，即“十家”。其中有六家与司马谈列举的相同，其余四家是纵横家、杂家、农家、小说家。刘歆在结论中说：“诸子十家，其可观者，九家而已。” 司马谈（司马迁他爹）论六家要旨： 第一是阴阳家。他们讲的是一种宇宙生成论。它由“阴”、“阳”得名。在中国思想里，阴、阳是宇宙形成论的两个主要原则。 第二是儒家。这一家在西方文献中称为“孔子学派”。但是“儒”字的字义是“文士”或学者，所以西方称为“孔子学派”就不大确切，因为这没有表明这一家的人都是学者以及思想家。他们与别家的人不同，都是传授古代典籍的教师，因而是古代文化遗产的保存者。 第三是墨家。这一家在墨子领导下，有严密的组织、严格的纪律。它的门徒实际上已经自称“墨者”。 第四是名家。这一家的人，兴趣在于他们所谓的“名”、“实”之辨。如公孙龙的白马非马。 第五是法家。汉字“法”的意义是法式、法律。这一家源于一群政治家，他们主张好的政府必须建立在成文法典的基础上，而不是建立在儒者强调的道德惯例上。 第六是道德家。这一家的人把它的形上学和社会哲学围绕着一个概念集中起来，那就是“无”，也就是“道”。简称道家 中国哲学家的社会、经济思想中，有他们所谓的“本”“末”之别。“本”指农业，“末”指商业。 士、农、工、商，“商”是其中最后最下的一个。“士”通常就是地主，“农”就是实际耕种土地的农民。在中国，这是两种光荣的职业。一个家庭若能“耕读传家”，那是值得自豪的。 我们看出中国思想的两个主要趋势道家和儒家的根源。它们是彼此不同的两极，但又是同一轴杆的两极。两者都表达了农的渴望和灵感，在方式上各有不同而已。 在自然界和人类社会的任何事物，发展到了一个极端，就反向另一个极端；这就是说，借用黑格尔的说法，一切事物都包含着它自己的否定。这是老子哲学的主要论点之一，也是儒家所解释的《易经》的主要论点之一。 儒家出于私人教师 孔子是中国历史上第一个以私人身份教了大量学生的人，他周游列国时有大批学生跟随着。 刘歆说儒家“游文于《六经》之中，留意于仁义之际”。《六经》就是《易》、《诗》、《书》、《礼》、《乐》（今佚）、《春秋》 关于人的德性，孔子强调仁和义，特点是仁。 在儒家思想中，义与利是直接对立的。孔子本人就说过：“君子喻于义，小人喻于利。”（《论语·里仁》） 我们能够做的，莫过于一心一意地尽力去做我们知道是我们应该做的事，而不计成败。这样做，就是“知命”。要做儒家所说的君子，知命是一个重要的必要条件。所以孔子说：“不知命，无以为君子也。”（《论语·尧曰》） 这样做的结果，我们将永不患得患失，因而永远快乐。所以孔子说：“知者不惑，仁者不忧，勇者不惧。”（《论语·子罕》）又说：“君子坦荡荡，小人长戚戚。”（《论语·述而》） 他说：“吾十有五，而志于学。三十而立。四十而不惑。五十而知天命。六十而耳顺。七十而从心所欲，不逾矩。”（《论语·为政》） “朝闻道，夕死可矣。”（《里仁》）孔子的志于学，就是志于这个“道”。我们现在所说的“学”，是指增加知识；但是“道”却是我们用来提高精神境界的真理。 先秦儒家三个最大的人物是孔子、孟子、荀子。孟子代表儒家的理想主义的一翼，稍晚的荀子代表儒家的现实主义的一翼。荀子名况，又号荀卿。 荀子最著名的是他的性恶学说。这与孟子的性善学说直接相反。表面上看，似乎荀子低估了人，可是实际上恰好相反。荀子的哲学可以说是教养的哲学。他的总论点是，凡是善的、有价值的东西都是人努力的产物。价值来自文化，文化是人的创造。正是在这一点上，人在宇宙中与天、地有同等的重要性。正如荀子所说：“天有其时，地有其财，人有其治，夫是谓之能参。”（《荀子·天论》） 照孟子所说，仁、义、礼、智的“四端”是天生的，只要充分发展这“四端”，人就成为圣人。但是照荀子所说，人不仅生来毫无善端，相反的倒是具有实际的恶端。在《性恶》篇中，荀子企图证明，人生来就有求利求乐的欲望。但是他也肯定，除了恶端，人同时还有智能，可以使人向善。 荀子的学生，有两个最著名：李斯、韩非。这二人都在中国历史上有重大影响。李斯后来做了秦始皇帝的丞相，始皇最后于公元前221 年以武力统一了中国。这两位君臣一起致力于统一，不仅是政治的统一，也是思想的统一，这个运动的顶点就是公元前213 年的“焚书坑儒”。另一位学生韩非，成为法家的领袖人物，为这次政治的、思想的统一提供了理论的辩护。法家思想将在下一章论述。 董仲舒，罢黜百家，独尊儒术。为儒家的正统而创建基本制度，主张以儒家经典作为考试基础。他把主要来源于阴阳家的形上学的根据，与主要是儒家的政治、社会哲学结合起来。 董仲舒认为宇宙由十种成分组成。天、地、阴、阳，五行的木、火、土、金、水，最后是人（见《春秋繁露·天地阴阳》。同时提出了新的五行相生相克的理论，并认为“天、地、人，万物之本也。天生之，地养之，人成之。” 他从传统的儒家五伦即君臣、父子、夫妇、兄弟、朋友。中选出三伦是为三纲即君为臣纲，就是说，君为臣之主。夫为妻纲，父为子纲。另加儒家坚持的五种德性是为五常，即仁、义、礼、智、信。五常是个人的德性，三纲是社会的伦理。 《礼记》的《礼运》篇所说，社会的进化分为三个阶段，第一阶段是乱世，第二阶段是“小康”之世，第三阶段是“大同”之世。 武帝采纳了这个建议，正式宣布儒学为国家官方学说，《六经》在其中占统治地位，当然，儒家要巩固这个新获得的地位，需要用相当时间从其他对立的各家中择取许多思想，从而使儒学变得与先秦儒学很不相同。 墨家出于游侠 孔子之后，下一个主要的哲学家是墨子。他姓墨名翟。在古代，墨子与孔子享有同等的盛名，墨学的影响也不亚于孔学。 孔子是古代文化的辩护者，辩护它是合理的、正当的；墨子则是它的批判者。孔子是文雅的君子，墨子是战斗的传教士。他传教的目的在于，把传统的制度和常规，把孔子以及儒家的学说，一起反对掉。 兼爱非攻，天志明鬼。 中西方古代哲学中有大量的异曲同工的思想。 后期墨家在批评道家的时候，揭示出了一些也在西方哲学中出现过的逻辑悖论，只有在现代建立了新的逻辑学，这些悖论才得到解决。因此在当代逻辑学中，后期墨家所做的批评不再有效了。可是，我们看到后期墨家如此富于逻辑头脑，实在令人赞叹。他们试图创造一个认识论和逻辑学的纯系统，这是中国古代其他各家所不及的。 道家出于隐者 先秦道家哲学的发展，一共有三个主要阶段。属于杨朱的那些观念，代表第一阶段。《老子》的大部分思想代表第二阶段，《庄子》的大部分思想代表第三阶段即最后阶段。 善于全生的人，一定不能多为恶，但是也一定不能多为善。他一定要生活在善恶之间。他力求无用，但是到头来，无用对于他有大用。 《老子》第一章说：“道可道，非常道；名可名，非常名。无名天地之始，有名万物之母。” 《庄子》的《天下》篇说，老子的主要观念是“太一”、“有”、“无”、“常”。 庄子和老子都主张不治之治，但是所持的理由不同。老子强调他的总原理“反者道之动”。他的论证是，越是统治，越是得不到想得到的结果。庄子强调天与人的区别。他的论证是，越是以人灭天，越是痛苦和不幸。 道家认为，圣人对万物的自然本性有完全的理解，所以无情。可是这并不是说他没有情感。这宁可说是，他不为情所忧乱，而享有所谓“灵魂的和平”。 无用之用，无为之为，无知之知 《天下》篇的含意似乎是说，儒家知道具体的“数度”，而不知所含的原理；道家知道原理，而不知数度。换句话说，儒家知道“道”之末，而不知其本；道家知其本，而不知其末。只有两家的结合才是全部真理。 一定程度上是作为取代佛教的本地宗教而发展起来的。道教虽然一贯反对佛教，但是道家却以佛学为盟友。 禅宗是中国佛教的一支，它真正是佛学和道家哲学最精妙之处的结合。它对后来中国的哲学、诗词、绘画都有巨大的影响。 “新道家”是一个新名词，指的是公元 3 世纪、4 世纪（魏晋南北朝时期）的“玄学”。“玄”是黑色，又有微妙、神秘等意思。《老子》第一章说：“玄之又玄，众妙之门。”所以“玄学”这个名称表明它是道家的继续。代表作有《世说新语》 名家出于讼者（辩者） 真正创建名家的人是惠施、公孙龙。惠施相对论，公孙龙共相论。公孙龙不像惠施那样强调“实”是相对的、变化的，而强调“名”是绝对的、不变的。他由此得到与柏拉图的理念或共相相同的概念，柏拉图的理念或共相在西方哲学是极著名的。他的著作《公孙龙子》，有一篇《白马论》。其主要命题是“白马非马”。 韩非本人是法家，竟然反对源出讼师的名家的“词”，以为它破坏法律，这也许令人奇怪。但是在第十四章中我们就会明白，韩非及其他法家其实都是政治家，并不是法学家。 阴阳家出于方士，方士的术数分为六种：天文、历谱、五行、蓍龟、杂占、形法。 五行通常译为Five Elements（五种元素）。我们切不可将它们看做静态的，而应当看做五种动态的互相作用的力。 以土德王的黄帝，为以木德王的夏朝所克。以木德王的夏朝，为以金德王的商朝所克。以金德王的商朝，为以火德王的周朝所克。以火德王的周朝，将为以水德王的秦朝代所克。汉朝以后，人们不大注意这个问题了。但是一直到辛亥革命取消帝制为止，皇帝的正式头衔仍然是“奉天承运皇帝”。所谓“承运”，就是承五德转移之运。 五行学说解释了宇宙的结构，但是没有解释宇宙的起源。阴阳学说解释了宇宙起源。 《易经》的原文只包括六十四卦的卦辞和爻辞。阳爻，连线，表示奇数；阴爻，断线，表示偶数。 乾111、坤000、震100、巽011、坎010、离101、艮001、兑110 法家西周封建社会根据两条原则办事：一条是“礼”；一条是“刑”。礼是不成文法典，以褒贬来控制“君子”即贵族的行为。刑则不然，它只适用于“庶人”；或“小人”，即平民。这就是《礼记》中说的：“礼不下庶人，刑不上大夫。”（《曲礼上》） 他们之所以称为法术之士，是因为他们提出了治理大国的法术。这些法术把权力高度集中于国君一人之手。他们鼓吹的这些法术就是愚人也能懂会用。照他们所说，国君根本不需要是圣人或超人。只要忠实地执行他们的法术，哪怕是仅有中人之资也能治国，并且治理得很好。还有些“法术之士”更进一步，将他们的法术理论化，做出理论的表述，于是构成了法家的思想。 把法家思想与法律和审判联系起来，是错误的。用现代的术语说，法家所讲的是组织和领导的理论和方法。谁若想组织人民，充当领袖，谁就会发现法家的理论与实践仍然很有教益，很有用处，但是有一条，就是他一定要愿意走极权主义的路线。 韩非是法家最后的也是最大的理论家，在他以前，法家已经有三派，各有自己的思想路线。一派以慎到为首，他以“势”为政治和治术的最重要的因素。另一派以申不害为首，申不害强调“术”是最重要的因素。再一派以商鞅为首商鞅又称商君，最重视“法”。“势”，指权力，权威；“法”，指法律，法制；“术”，指办事、用人的方法和艺术，也就是政治手腕。韩非认为，这三者都是不可缺少的。 除了法家，其他各家都认同人类黄金时代在过去，不在将来。自从黄金时代过去后，历史的运动一直是逐步退化的运动。因此，拯救人类，不在于创新，而在于复古。法家认识到时代变化的要求，又极其现实地看待这些要求。由于这些全新的情况，出现了全新的问题，韩非认为，只有用全新的方案才能解决。 这种把历史看做变化过程的观点，在我们现代人看来，不过老生常谈。但是从它在当时反对了古代中国其他各家流行的学说看来，实在是一种革命的观点。 韩非像他的老师荀子一样相信人性是恶的。但是他又与荀子不同，荀子强调人为，以之为变恶为善的手段，韩非则对此不感兴趣。在韩非和其他法家人物看来，正因为人性是人性的原样，法家的治道才有效。法家提出的治国之道，是建立在假设人性是人性的原样，即天然的恶这个前提上；而不是建立在假设人会变成人应该成为的样子，即人为的善这个前提上。 道家与法家代表中国思想的两个极端。道家认为，人本来完全是天真的；法家认为，人本来完全是邪恶的。道家主张绝对的个人自由；法家主张绝对的社会控制。可是在无为的观念上，两个极端却遇合了。这就是说，它们在这里有某些共同之处。 法家的治道，需要君主公正无私。他一定惩罚应当受惩罚的人，即使这些人是他的亲友；他一定奖赏应当受奖赏的人，即使这些人是他的仇敌。只要他有一些时候不能这样做，他的整个统治机器就垮了。这样的要求是一个仅有中等智力的人远远不能胜任的，真正能实现这种要求的还只有圣人。 在早期的中国封建社会中，以礼治贵族，以刑治平民。所以，儒家要求不仅治贵族以礼，而且治平民也应当以礼而不以刑，这实际上是要求以更高的行为标准用之于平民。在这个意义上，儒家是革命的。在法家思想里，也没有阶级的区别。在法律和君主面前人人平等。可是，法家不是把平民的行为标准提高到用礼的水平，而是把贵族的行为标准降低到用刑的水平，以至于将礼抛弃，只靠赏罚，一视同仁。儒家的观念是理想主义的，法家的观念是现实主义的。正由于这个缘故，所以在中国历史上，儒家总是指责法家卑鄙、粗野，法家总是指责儒家迂腐、空谈。 佛学佛教传入中国，是中国历史中最重大的事件之一。从它传入以后，它就是中国文化的重要因素，在宗教、哲学、文学、艺术方面有其特殊影响。小乘、大乘的经文都翻译过来了，但是只有大乘在中国的佛学中获得永久的地位。 “中国的佛学”与“在中国的佛学”，二者所指的不一定是一回事。因为佛教中有些宗派，规定自己只遵守印度的宗教和哲学传统，而与中国的不发生接触。相宗，又称唯识宗，就是一个例子。相宗是著名的到印度取经的玄奘（596—664）引进中国的。像相宗这样的宗派，都只能叫做“在中国的佛学”。它们的影响，只限于少数人和短暂的时期。它们并没有进入广大知识界的思想中，所以在中国的精神的发展中，简直没有起作用。“中国的佛学”则不然，它是另一种形式的佛学，它已经与中国的思想结合，它是联系着中国的哲学传统发展起来的。往后我们将会看到，佛教的中道宗与道家哲学有某些相似之处。中道宗与道家哲学相互作用，产生了禅宗。禅宗虽是佛教，同时又是中国的。禅宗虽是佛教的一个宗派，可是它对于中国哲学、文学、艺术的影响，却是深远的。 虽说佛教有许多宗派，每个宗派都提出了某些不同的东西，可是所有的宗派一致同意，他们都相信“业”的学说。照佛学的说法，宇宙的一切现象，或者更确切地说，一个有情物的宇宙的一切现象，都是他的心的表现。不论何时，他动，他说，以至于他想，这都是他的心做了点什么，这点什么一定产生它的结果，无论在多么遥远的将来。这个结果就是业的报应。业是因，报是果。一个人的存在，就是一连串的因果造成的。一个有情物的今生，仅只是这个全过程的一个方面。死不是他的存在的终结，而只是这个过程的另一个方面。今生是什么，来自前生的业；今生的业，决定来生是什么。如此，今生的业，报在来生；来生的业，报在来生的来生；以至无穷。这一连串的因果报应，就是“生死轮回”。它是一切有情物的痛苦的主要来源。照佛学的说法，这一切痛苦，都起于个人对事物本性的根本无知。宇宙的一切事物都是心的表现，所以是虚幻的，暂时的，可是无知的个人还是渴求它们，迷恋它们。这种根本无知，就是“无明”。无明生贪嗔痴恋；由于对于生的贪恋，个人就陷入永恒的生死轮回，万劫不复。要逃脱生死轮回，唯一的希望在于将“无明”换成觉悟，觉悟就是梵语的“菩提”。佛教一切不同的宗派的教义和修行，都是试图对菩提有所贡献。从这些对菩提的贡献中，个人可以在多次再生的过程中，积累不再贪恋什么而能避开贪恋的业。个人有了这样的业，其结果就是从生死轮回中解脱出来，这种解脱叫做“涅槃”。 佛教此宗（中道宗）与道家所用的方法，以及用这种方法所得的结果，都是相似的。这种方法是，利用不同的层次，进行讨论。一个层次上的说法，马上被高一层次上的说法否定了。我们在第十章已经看到，《庄子·齐物论》所用的也是这种方法，它就是以上刚才讨论的方法。一切都否定了，包括否定这个“否定一切”，就可以达到庄子哲学中相同的境界，就是忘了一切，连这个“忘了一切”也忘了。这种状态，庄子称之为“坐忘”，佛家称之为“涅槃”。我们不可以问佛教此宗，涅槃状态确切的是什么，因为，照它说的，达到第三层次的真谛，就什么也不能说了。 万物每刻都在变化。在任何特定的时刻存在的任何事物，实际上是这个时刻的新事物，与过去存在的这个事物，不是同一个事物。（想到了量子力学） 禅宗“禅”或“禅那”是梵文Dhyana的音译，原意是沉思、静虑。佛教禅宗的起源，按传统说法，谓佛法有“教外别传”，除佛教经典的教义外，还有“以心传心，不立文字”的教义，从释迦牟尼佛直接传下来，传到菩提达摩，据说已经是第二十八代。达摩于梁武帝时，约 520 年至 526年，到中国，为中国禅宗的初祖。达摩将心传传给慧可（486—593），为中国禅宗二祖。如此传到五祖弘忍（605—675），他有两个大弟子，分裂为南北二宗。神秀（706 年卒）创北宗，慧能（638—713）创南宗。南宗不久超过了北宗，慧能被认为六祖。禅宗后来一切有影响的派别，都说它们是慧能的弟子们传下来的（参见道原《传灯录》卷一）。 有一天弘忍自知快要死了，把弟子们召集在一起，说现在要指定一个继承人，其条件是写出一首最好的“偈”，把禅宗的教义概括起来。当下神秀作偈云：身如菩提树，心如明镜台。时时勤拂拭，莫使染尘埃。针对此偈，慧能作偈云：菩提本无树，明镜亦非台。本来无一物，何处染尘埃。 第一义不可说，因为对于“无”什么也不能说。 新道家新道家，尽管是道家，却认为孔子甚至比老子、庄子更伟大。他们认为，孔子没有说忘，因为他已经忘了忘；孔子也没有说无欲，因为他已经无欲于无欲。 老庄否认有人格的造物主存在，代之以无人格的道，而道生万物。向郭则更进一步，认为道是真正的无。照向郭（向秀和郭象）的说法，先秦道家所说的道生万物，不过是说万物自生。 为了理解“风流”，我们就要转回到《世说新语》（简称《世说》）上。这部书是刘义庆（403—444）撰，刘峻（463—521）作注。魏晋的新道家和他们的佛教朋友，以“清谈”出名。清谈的艺术在于，将最精粹的思想，通常就是道家思想，用最精粹的语言，最简洁的语句，表达出来，所以它是很有讲究的，只能在智力水平相当高的朋友之间进行，被人认为是一种最精妙的智力活动。 中国历史上儒家与道家的传统，在某种程度上，相当于西方的古典主义与浪漫主义的传统，这也是原因之一。 汉（公元前206—公元220）、晋（265—420），不仅是中国历史上两个不同朝代的名称，而且由于它们的社会、政治、文化特征很不相同，它们还指文学艺术的两种不同风格，以及两种不同的生活态度。汉人风度是庄严、雄伟，晋人风度是放达、文雅。文雅也是“风流”的特征之一。 新道家可以分为主理派（代表是向郭）和主情派（竹林七贤） 新儒家到唐朝时，儒家又被重新确立为国家的官方教义。这时候，儒家表现在孟子、荀子、董仲舒等人著作中的活力早已丧失。经典原文具在，注疏甚至更多，可是都不能满足时代的精神兴趣和需要。道家复兴和佛教传入之后，人们变得对于形上学问题，以及我所说的超道德价值，或当时称为性命之学的问题，比较有兴趣。 新儒家的主要来源可以追溯到三条思想路线。第一，当然是儒家本身。第二是佛家，包括以禅宗为中介的道家，因为在佛家各宗之中，禅宗在新儒家形成时期是最有影响的。在新儒家看来，禅与佛是同义语；前一章已经讲过，在某种意义上，可以说新儒家是禅宗的合乎逻辑的发展。第三是道教，道教有一个重要成分是阴阳家的宇宙发生论。新儒家的宇宙发生论主要是与这条思想路线联系着。 周敦颐、邵雍、张载提出了新儒家的宇宙发生论。 新儒家接着分成两个主要的学派，真是喜人的巧合，这两个学派竟是兄弟二人开创的。他们号称“二程”。弟弟程颐（1033—1108）开创的学派，由朱熹（1130—1200）完成，称为“程朱学派”，或“理学”。哥哥程颢（1032—1085）开创的另一个学派，由陆九渊（1139—1193）继续，王守仁（1473—1529）完成，称为“陆王学派”，或“心学”。在“二程”的时代，还没有充分认识这两个学派不同的意义，但是到了朱熹和陆九渊，就开始了一场大论战，一直继续到今天。 两个学派争论的主题，确实是一个带有根本性的重要哲学问题。用西方哲学的术语来说，这个问题是，自然界的规律是不是人心（或宇宙的心）创制的。这历来是柏拉图式的实在论与康德式的观念论争论的主题，简直可以说，形上学中争论的就是这个主题。 朱熹，或称朱子，是一位精思、明辨、博学、多产的哲学家。光是他的语录就有一百四十卷。到了朱熹，程朱学派或理学的哲学系统才达到顶峰。元仁宗于 1313 年发布命令，以《四书》为国家考试的主课，以朱注为官方解释。朱熹对其他经典的解释，也受到政府同样的认可，凡是希望博得一第的人，都必须遵照朱注来解释这些经典。明、清两朝继续采取这种做法，直到1905 年废科举、兴学校为止。 朱熹说：“天地之间，有理有气。理也者，形而上之道也，生物之本也；气也者，形而下之器也，生物之具也。是以人、物之生，必禀此理，然后有性；必禀此气，然后有形。” 王阳明强调致良知。《传习录》其中有一段说：“先生游南镇，一友指岩中花树问曰：‘天下无心外之物，如此花树，在深山中，自开自落，于我心亦何相关？’先生云：‘尔未看此花时，此花与尔心同归于寂。尔来看此花时，则此花颜色，一时明白起来。便知此花，不在尔的心外。’” 到了清代，官方方面，程朱学派的地位甚至比前朝更为巩固。非官方方面，对程朱学派和陆王学派在清朝都发生了重大的反动。反对程朱陆王的领袖人物，都谴责他们在禅宗和道家影响下，错误地解释了孔子的思想，因而已经丧失了儒家固有的实践方面。清代的学者们发动了“回到汉代”的运动，意思就是回到汉代学者为先秦经典所作的注释。他们相信，汉代学者生活的时代距孔子不远，又在佛教传入中国之前，因此汉儒对经典的解释一定比较纯粹，比较接近孔子的原意。于是，他们研究了浩繁的汉儒注释，都是新儒家所摒弃的，他们将这种研究称为“汉学”。这个名称是与新儒家对立的，他们称新儒家为“宋学”，因为新儒家的主要学派兴于宋代。清儒中的汉学与宋学之争，是中国思想史上最大的论争之一。 西方哲学传入1919 年邀请约翰·杜威和柏特兰·罗素来北京大学和其他地方讲学。他们是到中国来的第一批西方哲学家，中国人从他们的讲演中第一次听到西方哲学的可靠说明。 西方哲学对中国哲学的永久性贡献，是逻辑分析方法。佛家和道家都用负的方法。逻辑分析方法正和这种负的方法相反，所以可以叫做正的方法。负的方法，试图消除区别，告诉我们它的对象不是什么；正的方法，则试图做出区别，告诉我们它的对象是什么。对于中国人来说，传入佛家的负的方法，并无关紧要，因为道家早已有负的方法，当然佛家的负的方法确实加强了它。可是，正的方法的传入，就真正是极其重要的大事了。它给予中国人一个新的思想方法，使其整个思想为之一变。 西方哲学传入后最丰富的成果，是复兴了对中国哲学包括佛学的研究。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"哲学","slug":"哲学","permalink":"https://lchml.com/tags/%E5%93%B2%E5%AD%A6/"},{"name":"中国哲学","slug":"中国哲学","permalink":"https://lchml.com/tags/%E4%B8%AD%E5%9B%BD%E5%93%B2%E5%AD%A6/"},{"name":"哲学史","slug":"哲学史","permalink":"https://lchml.com/tags/%E5%93%B2%E5%AD%A6%E5%8F%B2/"}]},{"title":"《格鲁夫给经理人的第一课》","slug":"manager","date":"2021-10-12T16:00:00.000Z","updated":"2022-05-12T05:59:38.459Z","comments":true,"path":"technology/manager/","link":"","permalink":"https://lchml.com/technology/manager/","excerpt":"花了几天断断续续读完，书很薄，但是干货很多。作者作为国际著名科技企业英特尔的CEO，手把手教你怎么做管理，大到战略思想，指导方针，小到言行举止，操作步骤。每个章节都有高度总结提炼的宝贵经验。读完书很快，但是消化它，把它变成自己的东西需要很久。","text":"花了几天断断续续读完，书很薄，但是干货很多。作者作为国际著名科技企业英特尔的CEO，手把手教你怎么做管理，大到战略思想，指导方针，小到言行举止，操作步骤。每个章节都有高度总结提炼的宝贵经验。读完书很快，但是消化它，把它变成自己的东西需要很久。 经理人的产出＝他直接管辖部门的产出＋他间接影响所及部门的产出 让混沌丛生，然后掌控混沌。 产出导向管理 团队意识 “管理杠杆率”（managerialleverage）这个概念，它是用来衡量各种管理活动对提高团队产能的作用的指标。高杠杆率的管理活动才能带来高产能。 团队中的每一个体都各尽所能，这个团队才会有最高的产能。 早餐店的生产线，煮鸡蛋的限制步骤，PM中的关键链路 所有的生产流程都有一个共同的特性，就是原料在流程中会变得越来越有价值。我们应该谨守“及早发现、及早解决”的准则，如此我们便能在生产流程中价值最低的阶段修正问题。 要管好你的产出，你得先设定一些指标；要做到高效高产，你需要更多的指标。指标能将你的注意力引导到需要监督的事情上。 指标运用的第一个原则是，“有总比没有好”。任何管理都需要评估，但我们也发现，一个有效的指标应是评估产出，而不是产出之前的生产活动。 指标运用的第二个原则是，一个好的指标应该是用来衡量具体且可计算的事情的。 黑箱理论 先行指标，先行指标通过让你了解未来的概况来引导你注意黑箱中该注意的事情。因为你事先有所反应，所以能杜绝后患。当然，先行指标的功效唯有在你确信其有效的前提下才会成立。 线性指标，线性指标同样具有“早期发现、早期解决”的功效。 趋势指标，这个重要的指标能以时间（这个月的业绩和过去数月的相比）或其他设定的标准为基础。 重复印证表， 提高产能的两个方法： 加速生产，我们可通过组织重整或只是让员工工作更勤奋来达成目的。没有改变工作的本质，只是想办法让事情做得更快——让每一个员工在每一工时内做更多的事。 改变工作的本质，这里要谈的是“我们该做什么”，而不是“怎样才能更快”。我们要提高产出对工时的比例，即使工时维持不变，我们仍可设法提高产出。就像大家常说的：“我们不仅要辛勤工作，还得懂得如何工作。” 但不管在生产还是管理活动上，都还有办法提高杠杆率，那便是将工作简单化。 要将工作简单化，你得先质疑每一个步骤存在的理由。你会发现很多步骤其实并不需要，它们的存在可能是因为传统或只是为了让工作显得正式，而实际上对生产活动完全没有帮助。 经理人的每一项管理活动对整个组织都有或多或少的影响。至于对整体产出的影响有多大，则在于这些活动的杠杆率大小。 “活动”是我们日常真正在做的事，看起来有些烦琐；而“产出”则是我们的成就，与活动相比，当然就显得重要得多。 经理人必须有同时处理数件事情的能力，此外，还得知道何时该转移注意力，把精力放在当时最能促进整个组织产出的活动上。换句话说，他必须了解哪些活动有最高的杠杆率。 对大多数的经理人而言，最重要的信息往往来自简短而非正式的谈话。这种信息的传递速度往往也比任何一种书面报告或是小纸条快。而信息的价值，通常也和其时效有绝对的关联。 报告的价值在于提案人必须对自己的问题或方案进行更严格的审视。报告用来表示一个人的自律，远胜于它在传递信息上的作用。 收集信息非常重要 理论上，我们永远可以设法得到更多的人力、金钱或者资本，但一个人每天只有24小时，不多也不少。因此，该如何运用时间便成为极重要的课题。以我的观点，如何运用时间甚至是一个人能否成为领导者或模范的最重要的一点。 管理活动：收集信息、传递信息、制定决策、给予提示、为人表率 会议本身并非“活动”，它只是个“媒介”。 经理人的生产力即其每个单位时间的产出，可通过以下三种方法来增加：1. 加快每一项活动进行的速度。2. 提高每一项活动的杠杆率。3. 调整管理活动的组合，摒除低杠杆率的活动，代之以高杠杆率的活动。 管理的艺术在于如何在那么多看似都很重要的活动中，挑出一两项甚至三项最重要的，然后全心全意地去做。对我而言，留心顾客的抱怨具有极高的杠杆率。 没有监督的授权等于渎职 活用日程表。在排定了“一定要在某个时间做”的事情后，再将“重要但不太紧急”的事项插进空隙。 一个经理人必须要有一些“项目”的存货。是那些你并不急着完成的项目，比如一些用来提高部门长期生产力的项目。 定期一对一会议 同级群体综合征，当一群职位相当的人要开会时，总需要有一个职位较高的人与会——他不见得最能干或最具有专业知识，但他能够控制会议的进行。 我们都具备聪明才智以及意志力，应该能克服“怕人觉得自己很傻”以及意见不被采纳的恐惧，从而能够参与讨论并有自己的主张。 我们希望决策是由离问题最近，而且最了解问题的人来制定的。 在制定决策之前，经理人应对以下6个问题的答案了然于胸：（1）决策的内容。（2）决策的时限。（3）决策人。（4）在制定决策前应先向谁咨询。（5）谁对此决策一言九鼎，或是能全盘否定。（6）谁应该在决策制定后被告知。 在你规划行动方案之前，一定记得先问自己：有什么事情如果我“今天”做了，可以让“明天”更好，或者至少让“明天”不会更糟。 将你的部门当成一个独立公司 在你规划行动方案之前，一定记得问自己：有什么事情如果我“今天”做了，可以让“明天”更好，或者至少不会更糟。 蕴藏在目标管理背后的道理其实非常简单：如果你不知道何去何从，你将永远到到不了目的地。 将办公室变为竞技场能培养下属的运动家精神：求胜但不怕输，并随时向自己的极限挑战——这是一个团队能不断前进的主要动力。 激励是用来提高绩效的，而不是改变一个人的情绪或者态度。 马斯洛的需求层次理论 在基本生理需求和安全感需求这两个层次，金钱的效力在需求被满足时就会停止；但如果金钱成为衡量成就的标准，它的效力将无边无界。 主管应该事先搞清楚他对下属的期望，然后再以此来判断下属的绩效是否合乎期望。评估最大的问题在于经理人并没有列明对下属的期望，就像我们早先提过的：“如果我们不知道到底要什么，最可能的结果是什么也得不到。”你还必须避免落入潜力陷阱。你必须不断提醒自己，要评估的是绩效而非下属的潜力。 “做绩效评估并将结果告诉下属”是经理人最艰难的工作之一。最好的学习方法是参考你过去曾收到过的评估报告。如果你够幸运，你可以从上司给你的评估中找到好的绩效评估传统，借此维护公司评估系统的完整性。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"《凤凰架构》","slug":"phoenix","date":"2021-08-25T16:00:00.000Z","updated":"2022-05-12T06:08:48.099Z","comments":true,"path":"technology/phoenix/","link":"","permalink":"https://lchml.com/technology/phoenix/","excerpt":"构建可靠的大型分布式系统","text":"构建可靠的大型分布式系统 远程服务远程的服务在哪里（服务发现），有多少个（负载均衡），网络出现分区、超时或者服务出错了怎么办（熔断、隔离、降级），方法的参数与返回结果如何表示（序列化协议），信息如何传输（传输协议），服务权限如何管理（认证、授权），如何保证通信安全（网络安全层），如何令调用不同机器的服务返回相同的结果（分布式数据一致性）等一系列问题，全都需要设计者耗费大量精力。 进程间通信：管道&#x2F;具名管道、信号、信号量、消息队列、共享内存、本地套接字 RPC面向过程编程 REST只是一种风格，不是协议，REST的基本思想是面向资源来抽象问题 六大原则：客户端与服务端分离、无状态、可缓存、分层系统、统一接口、按需代码。 程度分级：完全不REST、开始引入资源概念、引入统一接口映射到HTTP协议的方法上、超媒体控制 解决REST问题的理论方案：GraphQL（更彻底的面向资源） 事务处理事务问题A（原子性Atomic）C（一致性Consistency）I（隔离性Isolation）D（持久性Durability） 通过Commit Logging实现事务的原子性和持久性是当今的主流方案，还有另外一种称为“Shadow Paging”（有中文资料翻译为“影子分页”）的事务实现机制。阿里的OceanBase就是直接采用CommitLogging机制来实现事务的。Redo日志和Undo日志 解决隔离性：写锁、读锁、范围锁，不同的隔离级别对应三种锁的不同组合应用。 可串行化：对事务所有读、写的数据全都加上读锁、写锁和范围锁即可做到可串行化 可重复读（幻读问题）：可重复读对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，但不再加范围锁。但InnoDB在只读事务中可以完全避免幻读问题。 读已提交（不可重复读问题）：读已提交对事务涉及的数据加的写锁会一直持续到事务结束，但加的读锁在查询操作完成后会马上释放。 读未提交（脏读问题）：它只会对事务涉及的数据加写锁，且一直持续到事务结束，但完全不加读锁。 近年来有一种名为“多版本并发控制”（Multi-Version Concurrency Control，MVCC）的无锁优化方案被主流的商业数据库广泛采用。MVCC是一种读取优化策略，它的“无锁”特指读取时不需要加锁。 XA规范，早于java出现，对应JTA标准。XA将事务提交拆分成两阶段： 准备阶段：它与本地事务中真正提交的区别只是暂不写入最后一条Commit Record而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。 提交阶段：对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条Commit Record而已，通常能够快速完成，只有收到Abort指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载操作。 “两段式提交”（2 Phase Commit，2PC）协议，而它能够成功保证一致性还需要一些其他前提条件。1、必须假设网络在提交阶段的短时间内是可靠的，即提交阶段不会丢失消息。2、必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态。 衍生出的”三阶段提交“：在事务需要回滚的场景中，三段式提交的性能通常要比两段式提交好很多，但在事务能够正常提交的场景中，两者的性能都很差，甚至三段式因为多了一次询问，还要稍微更差一些。 “FLP不可能原理”，证明了如果宕机最后不能恢复，那就不存在任何一种分布式协议可以正确地达成一致性结果。该原理在分布式中是与CAP不可兼得原理齐名的理论。 麻省理工学院的Seth Gilbert和Nancy Lynch以严谨的数学推理证明了CAP猜想。Consistency、Availability、Partition Tolerance HBase属于CP系统 选择放弃一致性的AP系统是目前设计分布式系统的主流选择 通过最终一致性来解决实际问题。BASE分别是基本可用性（Basically Available）、柔性事务（Soft State）和最终一致性（EventuallyConsistent）的缩写。 可靠事件队列（消息队列事务）：最容易出错的动作应该最先进行，消息都必须具备幂等性。只要第一步业务完成了，后续就没有失败回滚的概念，只许成功，不许失败。问题是没有隔离性，会产生超售的问题。 “最大努力交付”（Best-Effort Delivery），譬如TCP协议中未收到ACK应答自动重新发包的可靠性保障就属于最大努力交付。 TCC（Try-Confirm-Cancel）事务，·Try：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需要用到的业务资源（保障隔离性）。·Confirm：确认执行阶段，不进行任何业务检查，直接使用Try阶段准备的资源来完成业务处理。Confirm阶段可能会重复执行，因此本阶段执行的操作需要具备幂等性。·Cancel：取消执行阶段，释放Try阶段预留的业务资源。Cancel阶段可能会重复执行，因此本阶段执行的操作也需要具备幂等性。 TCC具有很高的性能潜力，也带来了更高的开发成本和业务侵入性，即更高的开发成本和更换事务实现方案的替换成本。阿里开源的Seata。 SAGA事务。SAGA在英文中是“长篇故事、长篇记叙、一长串事件”的意思。将大事务拆分成若干个小事务，将整个分布式事务T分解为n个子事务，命名为T1，T2，…，Ti，…，Tn。与TCC相比，SAGA不需要为资源设计冻结状态和撤销冻结的操作，补偿操作往往要比冻结操作容易实现得多。SAGA必须保证所有子事务都得以提交或者补偿，但SAGA系统本身也有可能会崩溃，所以它必须设计成与数据库类似的日志机制（被称为SAGA Log）以保证系统恢复后可以追踪到子事务的执行情况。Seata同样支持SAGA事务模式。 阿里的GTS（GlobalTransaction Service，Seata由GTS开源而来）所提出的“AT事务模式”，参照了XA两段提交协议实现的，但对于XA 2PC的缺陷设计了针对性的解决方案。 多级分流系统作为系统的设计者，我们应该意识到不同的设施、部件在系统中有各自不同的价值。 有一些部件位于客户端或网络的边缘，能够迅速响应用户的请求，避免给后方的I&#x2F;O与CPU带来压力，典型如本地缓存、内容分发网络、反向代理等。 有一些部件的处理能力能够线性拓展，易于伸缩，可以使用较小的代价堆叠机器来获得与用户数量相匹配的并发性能，应尽量作为业务逻辑的主要载体，典型如集群中能够自动扩缩的服务节点。 有一些部件稳定服务对系统运行有全局性的影响，要时刻保持容错备份，维护高可用性，典型如服务注册中心、配置中心。 有一些设施是天生的单点部件，只能依靠升级机器本身的网络、存储和运算性能来提升处理能力，如位于系统入口的路由、网关或者负载均衡器。 对系统进行流量规划时，我们应该充分理解这些部件的价值差异，有两条简单、普适的原则能指导我们进行设计。 第一条原则是尽可能减少单点部件。另一条更关键的原则是奥卡姆剃刀原则。在能满足需求的前提下，最简单的系统就是最好的系统。 客户端缓存 强制缓存：基于时效性，HTTP1.0的Expires、HTTP1.1的Cache-Control 协商缓存：基于变化检测，Last-Modified，304&#x2F;Not Modified 世界根域名服务器的ZONE文件只有2MB大小，甚至可以打印出来物理备份。 首先DNS会将域名还原为“www.icyfenix.cn.”，注意最后多了一个点“.”，它是“.root”的含义。 1、客户端先检查本地的DNS缓存（TTL存活时间） 2、客户端将地址发送给本机操作系统中配置的本地DNS（Local DNS），这个本地DNS服务器可以由用户手工设置，也可以在DHCP分配或者拨号时从PPP服务器中自动获取到。 3、本地DNS收到查询请求后，会按照“是否有www.icyfenix.com.cn的权威服务器”→“是否有icyfenix.com.cn的权威服务器”→“是否有com.cn的权威服务器”→“是否有cn的权威服务器”的顺序，依次查询自己的地址记录，如果都没有查询到，就会一直找到最后点号代表的根域名服务器为止。这个步骤里涉及两个重要名词。 4、现在假设本地DNS是全新的，上面不存在任何域名的权威服务器记录，所以当DNS查询请求按步骤3的顺序一直查到根域名服务器之后，它将会得到“cn的权威服务器”的地址记录，然后通过“cn的权威服务器”，得到“com.cn的权威服务器”的地址记录，以此类推，最后找到能够解释“www.icyfenix.com.cn”的权威服务器地址。 5、通过“www.icyfenix.com.cn的权威服务器”，查询www.icyfenix.com.cn的地址记录。地址记录并不一定就是指IP地址，在RFC规范中有定义的地址记录类型已经多达数十种，譬如IPv4下的IP地址为A记录，IPv6下的AAAA记录、主机别名CNAME记录，等等。 权威域名服务器（Authoritative DNS）：负责翻译特定域名的DNS服务器，“权威”意味着域名应该翻译出怎样的结果是由这个服务器决定的。DNS翻译域名时无须像查电话本一样刻板地一对一翻译，根据来访机器、网络链路、服务内容等各种信息，可以玩出很多花样。权威DNS的灵活应用，在后面的内容分发网络、服务发现等章节还会有所涉及。 根域名服务器（Root DNS）：固定的、无须查询的顶级域名（Top-LevelDomain）服务器，可以默认它们已内置在操作系统代码之中。全世界一共有13组根域名服务器（注意并不是13台），每一组根域名都通过任播（Anycast）的方式建立了一大群镜像，根据维基百科的数据，迄今已经超过1000台根域名服务器的镜像了。选择13是由于DNS主要采用UDP传输协议（在需要稳定性保证的时候也可以采用TCP）来进行数据交换，未分片的UDP数据包在IPv4下的最大有效值为512字节，最多可以存放13组地址记录。 DNS的设计可能受到中间人攻击的威胁，产生被劫持的风险。HTTPDNS可以防止 传输链路的三个问题：缓存、连接、压缩 TCP还有慢启动的特性，使得刚刚建立连接时的传输速度是最低的，后面再逐步加速直至稳定。由于TCP协议本身是面向长时间、大数据传输来设计的，在长时间尺度下，它建立连接的高昂成本才不至于成为瓶颈，它的稳定性和可靠性的优势才能展现出来。 Keep-Alive机制的副作用是“队首阻塞”（Head-of-Line Blocking）问题。HTTP&#x2F;2多路复用（HTTP&#x2F;2 Multiplexing）技术解决了该问题。在HTTP&#x2F;1.x中，HTTP请求就是传输过程中最小粒度的信息单位了。而在HTTP&#x2F;2中，帧（Frame）才是最小粒度的信息单位。不需要突破浏览器对每个域名最多6个的连接数限制。 与HTTP&#x2F;1.x相比，HTTP&#x2F;2本身变得更适合传输小资源，譬如传输1000张10KB的小图，HTTP&#x2F;2肯定要比HTTP&#x2F;1.x快，但传输10张1000KB的大图，则大概率HTTP&#x2F;1.x会更快些。这是TCP连接数量（相当于多点下载）的影响，但更多是由TCP协议可靠传输机制导致的，一个错误的TCP包会导致所有的流都必须等待这个包重传成功，这是HTTP&#x2F;3要解决的问题。因此，把小文件合并成大文件，在HTTP&#x2F;2下是毫无益处的。 HTTP&#x2F;1.1版本中增加了另一种“分块传输编码”（ChunkedTransfer Encoding）的资源结束判断机制，彻底解决了Content-Length与持久连接时资源即时压缩的冲突问题。 HTTP3（基于Quick UDP Internet Connection，QUIC）设计重点是替换TCP传输协议。针对移动场景，QUIC提出了连接标识符的概念，该标识符可以唯一地标识客户端与服务器之间的连接，而无须依靠IP地址。这样，切换网络后，只需向服务端发送一个包含此标识符的数据包即可重用既有的连接，因为即使用户的IP地址发生变化，原始连接的连接标识符依然是有效的。 内容分发网络（CDN）的工作过程，主要涉及路由解析、内容分发、负载均衡和CDN应用四个方面。CDN获取源站资源的过程被称为“内容分发”，目前主要有以下两种主流的内容分发方式。主动分发（Push）、被动回源（Pull）。 CDN作用：加速静态资源分发、安全防御、协议升级、状态缓存、修改资源、访问控制、注入功能。 负载均衡，四层负载均衡的优势是性能高，七层负载均衡的优势是功能强。做多级混合负载均衡，通常应是低层负载均衡在前，高层负载均衡在后。三角传输模式、代理模式 第二层数据链路层传输的内容是数据帧（Frame），如1500字节MTU的以太网帧，其中包含了源和目标MAC地址，数据链路层负载均衡所做的工作，是修改请求的数据帧中的MAC目标地址，让用户原本发送给负载均衡器的请求的数据帧，被二层交换机根据新的MAC目标地址转发到服务器集群中对应的真实服务器的网卡上，这样真实服务器就获得了一个原本目标并不是发送给它的数据帧。必须保证所有的真实服务器与负载均衡器有相同的虚拟IP地址 第三层网络层传输的单位是分组数据包（Packet），这是一种在分组交换网络（Packet Switching Network，PSN）中传输的结构化数据单位。IP分组数据包的Header中带有源和目标的IP地址。IP隧道模式，新创建一个数据包，把原数据包的Header和Payload整体作为新数据包的Payload，并在这个新数据包的Header中写入真实服务器的IP作为目标地址。同样必须保证所有的真实服务器与负载均衡器有相同的虚拟IP地址。另一种NAT模式会带来带宽资源竞争问题（也就是我们常见的路由器）。 工作在四层之后的负载均衡模式就无法再转发了，只能代理，此时真实服务器、负载均衡器、客户端三者之间由两条独立的TCP通道来维持通信。根据“哪一方能感知到”的原则，可以分为“正向代理”“反向代理”和“透明代理”三类。 均衡策略：轮询、权重轮询、随机、权重随机、一致性哈希、响应速度、最少连接数。 软件负载均衡：系统内核如LVS，应用程序如Nginx，HAProxy，KeepAlived 硬件负载均衡：F5，A10 引入缓存带来的问题：开发角度，提高系统复杂度、运维角度，缓存会掩盖一些缺陷、安全角度，缓存可能会泄漏某些保密数据，也是容易受到攻击的薄弱点。 缓存的目的：为缓解CPU压力而引入缓存、为缓解I&#x2F;O压力而引入缓存。缓存虽然是典型以空间换时间来提升性能的手段，但它的出发点是缓解CPU和I&#x2F;O资源在峰值流量下的压力，“顺带”而非“专门”地提升响应性能。 设计缓存考虑维度：吞吐量、命中率、扩展功能、分布式缓存 进程缓存：Caffeine、ConcurrentLinkedHashMap、LinkedHashMap、Guava Cache、Ehcache和Infinispan Embedde（性能由高到低） GuavaCache为代表的同步处理机制，即在访问数据时一并完成缓存淘汰、统计、失效等状态变更操作，通过分段加锁等优化手段来尽量减少竞争。 以Caffeine为代表的异步日志提交机制，这种机制参考了经典的数据库设计理论，将数据的读、写过程看作日志（即对数据的操作指令）的提交过程。在Caffeine的实现中，每个线程都设有专门的环形缓存区（Ring Buffer，也常称作CircularBuffer）来记录由于数据读取而产生的状态变动日志。从Caffeine读取数据时，数据本身会在其内部的ConcurrentHashMap中直接返回，而数据的状态信息变更就存入环形缓冲中，由后台线程异步处理。向Caffeine写入数据时，将使用传统的有界队列（ArrayQueue）来存放状态变更信息，写入带来的状态变更是无损的，不允许丢失任何状态。 缓存淘汰策略：FIFO、LRU、LFU、TinyLFU、W-TinyLFU 分布式缓存：大对象中修改一个值问题的性能问题，一致性问题（通常使用AP模式） 缓存穿透，有可能是业务逻辑本身就存在的固有问题，也有可能是恶意攻击所导致。为了解决缓存穿透问题，通常会采取下面两种办法。缓存空值，布隆过滤器判断key是否存在。 缓存击穿，热点数据失效导致，加锁或手动管理缓存 缓存雪崩，随机失效时间，多级缓存 缓存污染，Cache Aside模式 架构安全LDAP、OAuth2、JWT、摘要、加密、签名 Hash代替明文 密码加盐防止彩虹表攻击 动态盐值防止冒认 动态令牌可以防止重放攻击 HTTPS可以防止链路上的恶意嗅探 独立物理设备、独立信息通道、专用网络 中间人攻击 加密基础是大素数的乘机做质因数分解，然而如何对大数进行质因数分解，迄今还没有找到多项式时间的算法，甚至无法确切地知道这个问题属于哪个复杂度类（ComplexityClass）。所以尽管这个过程在理论上一定是可逆的，但实际上算力差异决定了逆过程无法实现。 对称加密算法，密钥数量问题、密钥分发问题 非对称加密算法，解决密钥分发问题，但由于计算复杂度高，性能要差好几个数量级。不支持分组，所以主流算法都只能加密不超过秘钥长度的数据，不能用于大量数据的加密。 公钥加密+私钥解密，内容不会被读取也不能被篡改 私钥加密+公钥解密，用于签名，可以防止篡改，但不能保证不被获取 保证公钥可信分发的标准，即公开密钥基础设施（Public Key Infrastructure，PKI）。在密码学中，公开密钥基础建设借着数字证书认证中心（Certificate Authority，CA）将用户的个人身份跟公开密钥链接在一起，且每个证书中心用户的身份必须是唯一的。PKI的确定链接关系的这一角色称为注册管理中心（Registration Authority，RA）。RA确保公开密钥和个人身份链接，可以防抵赖。证书（Certificate）是权威CA中心对特定公钥信息的一种公证载体。 传输安全层（Transport Layer Security）当前主流版本TLS1.2，两轮四次握手：client hello - server hello - client handshake finished - server handshake finished 分布式理论“分布式一致性算法”这个翻译不准确，其指的其实是“Distributed Consensus Algorithm”，应该翻译为“分布式共识算法”。其基础是计算机科学中的状态机。 世界上只有一种共识协议，就是Paxos，其他所有共识算法都是Paxos的退化版本。Paxos是一种基于消息传递的协商共识算法，是当今分布式系统最重要的理论基础，几乎就是“共识”二字的代名词。Paxos算法并不考虑拜占庭将军问题，即假设信息可能丢失也可能延迟，但不会被错误传递。 Paxos算法将分布式系统中的节点分为三类。 提案节点：称为Proposer，提出对某个值进行设置操作的节点，设置值这个行为就被称为提案（Proposal），值一旦设置成功，就是不会丢失也不可变的。后面介绍的Raft算法中就直接把“提案”叫作“日志”了。 决策节点：称为Acceptor，是应答提案的节点，决定该提案是否可被投票、是否可被接受。提案一旦得到过半数决策节点的接受，即称该提案被批准（Accept）。提案被批准即意味着该值不能被更改，也不会丢失，且最终所有节点都会接受它。 记录节点：称为Learner，不参与提案，也不参与决策，只是单纯地从提案、决策节点中学习已经达成共识的提案，譬如少数派节点从网络分区中恢复时，将会进入这种状态。 在使用Paxos算法的分布式系统里，所有的节点都是平等的，它们都可以承担以上某一种或者多种的角色，不过为了便于确保有明确的多数派，决策节点的数量应该被设定为奇数个，且在系统初始化时，网络中每个节点都应该知道整个网络所有决策节点的数量、地址等信息。 决策节点： 承诺不会再接受提案ID小于或等于n的Prepare请求； 承诺不会再接受提案ID小于n的Accept请求。 在不违背以前的承诺的前提下，回复已经批准过的提案中ID最大的那个提案所设定的值和提案ID，如果该值从来没有被任何提案设定过，则返回空值。如果违反此前做出的承诺，即收到的提案ID并不是决策节点收到的最大的ID，那允许直接对此Prepare请求不予理会。 prepare-promise-accept-accepted Basic Paxos、Multi Paxos、Fast Paxos、Raft、ZAB。 Multi Paxos对Basic Paxos的核心改进是增加了“选主”的过程。把共识问题分解为“选主”、“复制”和“安全”三个问题来思考、解决的思路，即“Raft算法”（在Raft的《一种可以让人理解的共识算法》中提出），并获得了USENIX ATC 2014大会的Best Paper，后来更是成为etcd、LogCabin、Consul等重要分布式程序的实现基础，ZooKeeper的ZAB算法与Raft的思路也非常类似，这些算法都被认为是Multi Paxos的等价派生实现。 “最终一致性”的分布式共识协议：Gossip协议。相比Paxos、Raft等算法，Gossip的过程十分简单，它可以看作以下两个步骤的简单循环。相比Paxos、Raft等算法，Gossip的过程十分简单，它可以看作以下两个步骤的简单循环。1、如果有某一项信息需要在整个网络的所有节点中传播，那从信息源开始，选择一个固定的传播周期（譬如1秒），随机选择它相连接的k个节点（称为Fan-Out）来传播消息。2、每一个节点收到消息后，如果这个消息是它之前没有收到过的，则在下一个周期内，该节点将向除了发送消息给它的那个节点外的其他相邻的k个节点发送相同的消息，直到最终网络中所有节点都收到了消息。尽管这个过程需要一定时间，但是理论上最终网络的所有节点都会拥有相同的消息。 微服务服务发现，Eureka是AP，Consul是CP基于Raft算法，ZK基于ZAP算法，etcd基于Raft算法，同时支持CP和AP的Nacos，k8s使用CoreDNS 网关路由，网关&#x3D;路由器（基础职能）+过滤器（可选职能）。基于Nginx、HAProxy开发的Ingress Controller（k8s组件），基于Netty开发的Zuul 2.0等 客户端负载均衡，Ribbon，LoadBalancer。代理客户端负载均衡，网格服务的Pod sidecar内 网络I&#x2F;O模型，Socket在操作系统接口中被抽象为数据流，而网络I&#x2F;O可以理解为对流的操作。一次网络访问：远程主机返回的数据→存放到操作系统内核缓冲区→复制到应用程序的地址空。 两类、五种模型：两类是指同步I&#x2F;O与异步I&#x2F;O，五种是指在同步I&#x2F;O中又划分出阻塞I&#x2F;O、非阻塞I&#x2F;O、多路复用I&#x2F;O、信号驱动I&#x2F;O四种细分模型以及异步I&#x2F;O模型。在Linux系统下实现高并发网络编程时仍以多路复用I&#x2F;O模型模式为主。 Region是地域的意思，面向全球或全国的大型系统的服务集群往往会部署在多个不同地域，大型系统就是通过不同地域的机房来缩短用户与服务器之间的物理距离，以提升响应速度，对于小型系统，地域一般就只在异地容灾时才会涉及。需要注意，不同地域之间是没有内网连接的。所以集群内部流量是不会跨地域的，服务发现、负载均衡器默认也是不会支持跨地域的服务发现和负载均衡的。 Zone是区域的意思，它是可用区域（Availability Zone）的简称。区域指在地理上位于同一地域内，但电力和网络是互相独立的物理区域，譬如在华东的上海、杭州、苏州的不同机房就是同一个地域的几个可用区域。同一个地域的可用区域之间具有内网连接，流量不占用公网带宽，因此区域是微服务集群内流量能够触及的最大范围。 异地容灾和异地双活的差别：容灾是非实时的同步，而双活是实时或者准实时的，跨地域或者跨区域做容灾都可以，但一般只能跨区域做双活，当然，也可以将它们结合起来使用，即“两地三中心”模式。 流量治理问题：一个服务崩溃引发雪崩效应，突发流量导致服务阻塞 信息系统设计成分布式架构的主要动力之一就是为了提升系统的可用性，最低限度也必须保证将原有系统重构为分布式架构之后，可用性不下降才行。 容错策略：故障转移（Failover）、快速失败（Failfast）、安全失败（Failsafe）、沉默失败（Failsilent）、故障恢复（Failback） 容错设计模式：断路器模式（服务熔断和服务降级）、舱壁隔离模式（服务隔离，如线程池隔离和信号量机制）、重试模式（仅对主路中的关键服务做同步重试，要求幂等性） 流量控制（限流），依据什么限流，具体如何限流，超额流量如何处理。 流量指标，TPS（每秒事务数）、HPS（每秒请求数）、QPS（每秒查询数） 限流设计模式：流量计数器模式、滑动时间窗模式、漏桶模式、令牌桶模式 分布式限流，令牌桶优化为额度。限流与容错不一样，做分布式限流从不追求“越彻底越好”，往往需要权衡方案付出的代价与得到的收益。 可靠通信边界安全模型，着重对经过网络区域边界的流量进行检查，对可信任区域（内网）内部机器之间的流量则给予直接信任或者较为宽松的处理策略，减小了安全设施对整个应用系统复杂度的影响以及网络传输性能的额外损耗。 零信任安全模型，中心思想是不应当以某种固有特征来自动信任任何流量，除非明确得到了能代表请求来源（不一定是人，更可能是另一台服务器）的身份凭证，否则一律不会有默认的信任关系。 可观测性事件日志、链路追踪和聚合度量三个方向。 日志，elk，logstash，Filebeat 追踪，zipkin，pinpoint，skywalking，鹰眼 度量，Prometheus，zabbix，时序数据库influxdb 监控预警 从这一章的内容来看，互客的可观测性做的不错。 虚拟化容器ISA（Instruction Set Architecture，指令集架构）是计算机体系结构中与程序设计相关的部分，包含基本数据类型、指令集、寄存器、寻址模式、存储体系、中断、异常处理以及外部I&#x2F;O。 ABI（Application Binary Interface，应用二进制接口）是应用程序与操作系统之间或其他依赖库之间的低级接口。 根据抽象目标与兼容性高低的不同，虚拟化技术又分为下列五类。 指令集虚拟化（ISA Level Virtualization），就是仿真，性能损失最大。 硬件抽象层虚拟化（Hardware Abstraction Level Virtualization），如VMware、Hyper-V，一般说的虚拟机就是指这一类。 操作系统层虚拟化（OS Level Virtualization），不会提供真实的操作系统，而是采用隔离手段，使得不同进程拥有独立的系统资源和资源配额，看起来仿佛是独享了整个操作系统，但其实系统的内核仍然是被不同进程所共享的。也就是“容器化” 容器化牺牲了一定的隔离性与兼容性，换来的是比前两种虚拟化更高的启动速度、运行性能和更低的执行负担。 隔离文件：chroot、隔离访问：Namespace、隔离资源：cgroups、封装系统：LXC、封装应用：Docker、封装集群：kubernetes 2014年，Docker开源了自己用Go语言开发的libcontainer。这是一个越过LXC直接操作namespaces和cgroups的核心模块，它使得Docker能直接与系统内核打交道，而不必依赖LXC来提供容器化隔离能力。2015年，在Docker的主导和倡议下，多家公司联合制定了“开放容器交互标准”（Open Container Initiative，OCI），将libcontainer独立出来，封装重构成runC项目，并捐献给Linux基金会管理。重构了Docker Daemon子系统，将其中与运行时交互的部分抽象为containerd项目。 Kubernetes Master→kubelet→DockerManager→DockerEngine→containerd→runC KubernetesMaster→kubelet→KubeGenericRuntimeManager→DockerShim→DockerEngine→containerd→runC KubernetesMaster→kubelet→KubeGenericRuntimeManager→containerd→runC 容器的本质是对cgroups和namespaces所提供的隔离能力的一种封装，在Docker提倡的单进程封装的理念影响下，容器蕴含的隔离性多了仅针对单个进程的额外限制，而Linux的cgroups和namespaces原本都是针对进程组而非单个进程来设计的，同一个进程组中的多个进程天然就可以共享相同的访问权限与资源配额。如果现在我们把容器与进程在概念上对应起来，那容器编排的第一个扩展点，就是要找到容器领域中与“进程组”相对应的概念，这是实现容器从隔离到协作的第一步，在Kubernetes的设计里，这个对应物叫作Pod。扮演容器组的角色，满足容器共享名称空间的需求，是Pod的两大最基本职责之一，同处于一个Pod内的多个容器，相互之间以超亲密的方式协作。它们将默认共享如下内容： UTS名称空间：所有容器都有相同的主机名和域名。 网络名称空间：所有容器都共享一样的网卡、网络栈、IP地址等。因此，同一个Pod中不同容器占用的端口不能冲突。 IPC名称空间：所有容器都可以通过信号量或者POSIX共享内存等方式通信。 时间名称空间：所有容器都共享相同的系统时间。 同一个Pod的容器，只有PID名称空间和文件名称空间默认是隔离的。可以通过Pod元数据定义中的spec.shareProcessNamespace来改变。容器间可以共享存储卷，这是通过Kubernetes的Volume来实现的。 Pod的另外一个基本职责是实现原子性调度。Pod是隔离与调度的基本单位，也是我们接触的第一种Kubernetes资源。Kubernetes将一切皆视为资源，不同资源之间依靠层级关系相互组合、协作的这个思想是贯穿Kubernetes整个系统的两大核心设计理念之一，不仅在容器、Pod、主机、集群等计算资源上是这样，在工作负载、持久存储、网络策略、身份权限等其他领域中也都有一致的体现。 k8s的两大核心设计理念：资源模型和控制器模式。工业领域的”控制回路“。 通过描述清楚这些资源的期望状态，由Kubernetes中对应监视这些资源的控制器来驱动资源的实际状态逐渐向期望状态靠拢。这种交互风格被称为Kubernetes的声明式API，日常在元数据文件中定义的spec字段所描述的便是资源的期望状态。 ReplicaSet也是一种资源，属于工作负荷类，代表一个或多个Pod副本的集合。可以保证Pod出现故障时自动恢复。由Deployment来创建ReplicaSet，再由ReplicaSet来创建Pod，当你更新Deployment中的信息（譬如更新了镜像的版本）后，部署控制器就会跟踪到新的期望状态，自动创建新的ReplicaSet，并逐渐缩减旧的ReplicaSet的数量，直至升级完成后彻底删除掉旧的ReplicaSet。Kubernetes又提供了Autoscaling资源和自动扩缩控制器，从而自动根据度量指标，如处理器、内存占用率、用户自定义的度量值等，来设置Deployment（或者ReplicaSet）的期望状态，实现当度量指标出现变化时，系统自动按照“Autoscaling→Deployment→ReplicaSet→Pod”这样的顺序层层变更，最终实现根据度量指标自动扩容&#x2F;缩容。 Helm一开始的目标就很明确：如果说Kubernetes是云原生操作系统，那Helm就要成为这个操作系统上的应用商店与包管理工具。 Operator是使用自定义资源（CR，Custom Resource，是CRD的实例），管理应用及其组件的自定义Kubernetes控制器。将简洁的高级指令转化为Kubernetes中具体操作的方法，与前面Helm或者Kustomize的方法并不相同。Helm和Kustomize最终仍然是依靠Kubernetes的内置资源来跟Kubernetes打交道的，Operator则要求开发者自己实现一个专门针对该自定义资源的控制器，在控制器中维护自定义资源的期望状态。 最后一种应用封装的方案，是阿里云和微软公司在2019年10月上海QCon大会上联合发布的开放应用模型（Open Application Model，OAM），它不仅是中国云计算企业参与制定乃至主导发起的国际技术规范，也是业界首个云原生应用标准定义与架构模型。 容器间网络在Linux目前提供的八种名称空间里，网络名称空间无疑是隔离内容最多的一种，它为名称空间内的所有进程提供了全套的网络设施，包括独立的设备界面、路由表、ARP表，IP地址表、iptables&#x2F;ebtables规则、协议栈，等等。 网络栈中的数据流动的路径： 目前主流的虚拟网卡方案有tun&#x2F;tap和veth两种。 tun和tap是两个相对独立的虚拟网络设备，其中tap模拟了以太网设备，操作二层数据包（以太帧），tun则模拟了网络层设备，操作三层数据包（IP报文）。使用tun&#x2F;tap设备的目的是实现把来自协议栈的数据包先交由某个打开了&#x2F;dev&#x2F;net&#x2F;tun字符设备的用户进程处理后，再把数据包重新发回到链路中。 veth（虚拟以太网，Virtual Ethernet）实际上不是一个设备，而是一对设备，因而也常被称作veth pair。要使用veth，必须在两个独立的网络名称空间中进行才有意义，因为veth pair是一端连着协议栈，另一端彼此相连的。 虚拟交换机Linux Bridge。 Docker三种网络方案：桥接模式（默认，veth，docker0网桥，通过二层网络通信）、主机模式（直接使用宿主机）、空置模式。 可以用户自行创建的网络：容器模式、MACVLAN模式、Overlay模式。 kubenet是kubelet内置的一个非常简单的网络，它采用网桥来实现Pod间通信。 容器的持久化存储Docker内置了三种挂载类型，分别是Bind（–mount type&#x3D;bind）、Volume（–mount type&#x3D;volume）和tmpfs（–mount type&#x3D;tmpfs）。Kubernetes同样将操作系统和Docker的Volume概念延续了下来，并对其进行了细化。Kubernetes将Volume分为持久化的PersistentVolume和非持久化的普通Volume两类。 PersistentVolume是由管理员负责提供的集群存储。 PersistentVolumeClaim是由用户负责提供的存储请求。 1、管理员准备好要使用的存储系统，它应是某种网络文件系统（NFS）或者云储存系统，一般来说应该具备跨主机共享的能力。2、管理员根据存储系统的实际情况手工预先分配好若干个PersistentVolume，并定义好每个PersistentVolume可以提供的具体能力。3、用户根据业务系统的实际情况创建PersistentVolumeClaim，声明Pod运行所需的存储能力。4、Kubernetes在创建Pod的过程中，会根据系统中PersistentVolume与Persistent-VolumeClaim的供需关系对两者进行撮合。如果系统中存在满足PersistentVolumeClaim声明中要求能力的PersistentVolume，则撮合成功，将它们绑定。如果撮合不成功，Pod就不会被继续创建，直至系统中出现新的或让出空闲的PersistentVolume资源。 Kubernetes的存储插件：In-Tree、Out-of-Tree Kubernetes目前同时支持FlexVolume与CSI（Container Storage Interface，容器存储接口）两套独立的存储扩展机制。 容器编排（资源与调度）“一切皆为资源”的设计是Kubernetes能够顺利施行声明式API的必要前提。Kubernetes以资源为载体，建立了一套同时囊括抽象元素（如策略、依赖、权限）和物理元素（如软件、硬件、网络）的领域特定语言。 从编排系统的角度来看，Node是资源的提供者，Pod是资源的使用者，调度是对两者进行恰当的撮合。 Kubernetes目前提供的服务质量等级一共分为三级，由高到低分别为Guaranteed、Burstable和BestEffort。如果Pod中所有的容器都设置了limits和requests，且两者的值相等，那此Pod的服务质量等级便为最高的Guaranteed；如果Pod中有部分容器的requests值小于limits值，或者只设置了requests而未设置limits，那此Pod的服务质量等级为第二级Burstable；如果是上文说的那种情况，limits和requests两个都没设置则属于最低的BestEffort。 Pod的驱逐机制是通过kubelet来执行的，kubelet是部署在每个节点的集群管理程序，由于本身就运行在节点中，所以最容易感知到节点的资源实时消耗情况。kubelet一旦发现某种不可压缩资源将要耗尽时，就会主动终止节点上较低服务质量等级的Pod，以保证其他更重要的Pod的安全。被驱逐的Pod中的所有容器都会被终止，Pod的状态也会被更改为Failed。 服务网格（Service Mesh）容器编排系统管理的最细粒度只能到达容器层次，在此粒度之下的技术细节，仍然只能依赖程序员自己来管理，编排系统很难提供有效的支持。服务网格之所以能够获得企业与社区的重视，是因为它很好地弥补了容器编排系统对分布式应用细粒度管控能力不足的缺憾。 服务网格是一种用于管控服务间通信的基础设施，职责是支持现代云原生应用网络请求在复杂拓扑环境中的可靠传递。在实践中，服务网格通常会以轻量化网络代理的形式来体现，这些代理与应用程序代码会部署在一起，对应用程序来说，它完全不会感知到代理的存在。——透明通信的实现希望 从总体架构看，服务网格包括两大块内容，分别是由一系列与微服务共同部署的边车代理，以及用于控制这些代理的管理器所构成。代理与代理之间需要通信，用以转发程序间通信的数据包；代理与管理器之间也需要通信，用以传递路由管理、服务发现、数据遥测等控制信息。服务网格使用数据平面（Data Plane）通信和控制平面（Control Plane）通信来形容这两类流量。在工业界，数据平面已有Linkerd、Nginx、Envoy等产品，控制平面也有Istio、Open Service Mesh、Consul等产品。 微服务理论IBM大型机之父Fred Brooks在他的两本著作《没有银弹：软件工程的本质性与附属性工作》和《人月神话：软件项目管理之道》里都反复强调一个观点：“软件研发中任何一项技术、方法、架构都不可能是银弹。”这个结论已经被软件工程里无数事实所验证，现在对于微服务也依然成立。 为何选择微服务：为异构能力进行的分布式部署，并不是你想或者不想的问题，而是没有选择、不可避免的。保证系统整体的稳定和局部的容错、自愈与快速迭代。让系统有更好的可观测性和回弹性（自愈能力）。 微服务最主要的目的是对系统进行有效拆分，实现物理层面的隔离，微服务的核心价值就是拆分之后的系统能够让局部的单个服务有可能实现敏捷地卸载、部署、开发、升级，而局部的持续更迭，是系统整体具备Phoenix特性的必要条件。 设计系统的架构受制于产生这些设计的组织的沟通结构。（Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.）——Melvin Conway，康威定律，1968年 长期来看，多数服务的结局都是报废而非演进。——Martin Fowle 微服务的前提：决策者与执行者都能意识到康威定律在软件设计中的关键作用。组织中具备一些对微服务有充分理解、有一定实践经验的技术专家。系统应具有以自治为目标的自动化与监控度量能力。复杂性已经成为制约生产力的主要矛盾。 “识别微服务的边界”其实已取得了较为一致的观点，也找到了指导具体实践的方法论，即领域驱动设计（Domain-Driven Design，DDD）。 微服务粒度的下界是它至少应满足独立——能够独立发布、独立部署、独立运行与独立测试，内聚——强相关的功能与数据在同一个服务中处理，完备——一个服务包含至少一项业务实体与对应的完整操作。 微服务粒度的上界是一个2 Pizza Team能够在一个研发周期内完成的全部需求范围。 治理就是让产品能够符合预期地稳定运行，并能够持续保持在一定的质量水平上。——Magic Quadrant for SOA Governance，Gartner，2007年","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"架构","slug":"架构","permalink":"https://lchml.com/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"《中国通史》——五千年简史","slug":"zgts","date":"2021-08-18T16:00:00.000Z","updated":"2022-05-12T05:56:21.637Z","comments":true,"path":"book/zgts/","link":"","permalink":"https://lchml.com/book/zgts/","excerpt":"吕思勉先生在本书（此书写于1939年，正值中国大地战火纷飞，外敌入侵之际）最后写到：我们现在，所处的境界，诚极沉闷，却不可无一百二十分的自信心。岂有数万万的大族，数千年的大国、古国，而没有前途之理？！","text":"吕思勉先生在本书（此书写于1939年，正值中国大地战火纷飞，外敌入侵之际）最后写到：我们现在，所处的境界，诚极沉闷，却不可无一百二十分的自信心。岂有数万万的大族，数千年的大国、古国，而没有前途之理？！ 传说时代传说始于盘古开天地，主要分为旧石器时代、中石器时代、新石器时代。 夏（公元前21世纪~前17世纪，约432年）以燧人、伏羲、神农为三皇，《史记·五帝本纪》以黄帝、颛顼、帝喾、尧、舜为五帝之说。 神农亦称炎帝，炎帝之后为黄帝，《史记·五帝本纪》说：“神农氏世衰，诸侯相侵伐，弗能征，而蚩尤氏最为暴。”“黄帝乃征师诸侯，与蚩尤战于涿鹿之野，遂擒杀蚩尤。轩辕“与炎帝战于阪泉之野，三战然后得其志”。 《说文》川部：“州，水中可居者。昔尧遭洪水，民居水中高土，故曰九州。”此系唐、虞、夏间九州的真相。 禹的儿子启，荒于音乐和饮食。死后，他的儿子太康兄弟五人，起而作乱，是为五观。 太康因此失国，人民和政权，都入于有穷后羿之手。 太康传弟仲康，仲康传子相。 羿因荒于游畋，又为其臣寒浞所杀。寒浞占据了羿的妻妾，生了两个儿子：一个唤做浇，一个唤做豷。夏朝这时候，依靠他同姓之国斟灌和斟寻。寒浞使浇把他们都灭掉，又灭掉夏后相。使浇住在唤做过，豷住在唤做戈的地方。夏后相的皇后是仍国的女儿，相被灭时，正有身孕，逃归母家，生了一个儿子，是为少康。做了仍国的牧正。寒浞听得他有才干，使浇去寻找他。少康逃到虞国。虞国的国君，把两个女儿嫁给他，又把唤做纶的地方封他。有一个唤做靡的，当羿死时，逃到有鬲氏，就从有鬲氏收合斟灌、斟寻的余众，把寒浞灭掉。少康灭掉了浇，少康的儿子杼又灭掉了豷。穷国就此灭亡。 后来由于水患，夏朝从安徽西部迁往河南。夏朝卒亡于商。根据《史记》的《夏本纪》，夏朝传国共十七代。 商（公元前17世纪~前11世纪，约629年）商朝的始祖名契，封于商。根据《殷本纪》商朝共三十代。自契至于成汤八迁。契（蕃，今山东滕县）-昭明（砥石）-相士（商丘，今河南商丘）-成汤（亳，又称亳殷，商朝都城，故又称殷朝）。汤伐昆吾、夏桀。商兴于今鲁、豫之间，汤先平定了河南北境，然后向南攻桀。商朝事迹，较夏传者略多。成汤以后，第四代大甲，第九代大戊，第十三代祖乙，第十九代盘庚，第二十二代武丁，都是贤君。武丁之时，尤其强盛。商朝都城是屡次迁徙的。至其第三十代即最后一个君主纣，居于朝歌（今河南淇县）。纵观历代都邑，都在河南省内的黄河两岸。周朝的势力，却更深入西北部了。 周（公元前11世纪~前256年，约867年）西周（前11世纪~前771）周朝的始祖名弃，是舜之时居稷官的，封于邰（tái，今陕西的武功县）。历若干代至不窋(zhú)，失官，奔于戎狄之间。再传至公刘，居邠（bīn，今陕西的邠县），仍从事于农业。又十传至古公亶(dǎn)父，复为狄所逼，徙岐山（今陕西的岐山县）下。古公亶父亦称太王，周至其时始强盛。传幼子季历以及文王，文王之子武王，遂灭纣。然武王虽胜纣，并未能把商朝灭掉，仍以纣地封其子武庚，而使其弟管叔、蔡叔监之。武王崩，子成王幼，武王弟周公摄政，管、蔡和武庚都叛。是时叛者，又有徐、奄及熊、盈。徐即后来的徐国，地在泗水流域，奄即后来的鲁国，熊为楚国的氏族，盈即嬴，乃秦国的姓。周公平定东方之后，据说就制礼作乐，摄政共七年，而归政于成王（周公辅成王）。 成王和他的儿子康王之时，称为西周的盛世。康王的儿子昭王，“南巡守不返，卒于江上。”（《史记·周本纪》）。其实昭王是伐楚而败，淹死在汉水里的。昭王子穆王，西征犬戎。穆王是周朝的雄主，在位颇久，当其时，周朝的声势，是颇振起的，穆王死后，就无此盛况了。 穆王五传至厉王，因暴虐，为国人所逐，居外十四年。周朝的卿士周公、召公当国行政，谓之共和。厉王死于外，才立其子宣王。西方戎狄的势力，渐次抬头。至于幽王，遂为犬戎和南阳地方的申国所灭。则幽王死后，西畿之地，还有一个携王。携王为诸侯所废，周朝对于西畿之地，就不能控制了，只有对于东畿，还保存着相当的势力。平王于是迁居洛阳，号称东周，其事在公元前770年。 东周-春秋（公元前770年~前476年，约242年）春秋五霸在历史有多种说法，这里把所有候选人的列出来：齐桓公、秦穆公、楚庄王、晋悼公、晋文公、晋襄公、晋景公、宋襄公、郑庄公、越王勾践、吴王阖闾、吴王夫差。按其中得票数来排序的话来算的话，前五名应该是：齐桓公、晋文公、楚庄王、秦穆公、越王勾践。 春秋之世，首起而称霸的是齐桓公。齐桓公的在位，系自前685至643年。桓公死后，齐国内乱，霸业遽衰。 此时的秦国，亦已尽取西周旧地，东境至河，为西方一强国，然尚未能干涉中原之事。秦穆公初和晋国竞争不胜，前624年，打败了晋国的兵，亦仅称霸于西戎。 前597年，楚庄王败晋于邲（今河南郑县），称霸。前591年卒。 此时齐顷公亦图与晋争霸。前589年，为晋所败。前575年，晋厉公又败楚于鄢陵（今河南鄢县）。然楚仍与晋兵争不息。至前561年，楚国放弃争郑，晋悼公才称复霸。 前473年，越勾践灭吴，越遂徙都琅邪，与齐，晋会于徐州（今山东诸城县），称为霸王。然根基因此不固，至前333年而为楚所灭。 东周-战国（公元前475年~前221年，约259年）战国七雄：齐楚秦燕赵魏韩。三国分晋：赵、魏、韩 公元前480年为战国之始，算至前222年秦灭六国的前一年为止，共259年。春秋时期，一等国之间一般不动干戈，而到了战国时期，由于二三等国已经基本被吞并，一等国国立日盛开始称王，并寻求凌驾诸侯王之上称帝。 秦国之强，起于献公而成于孝公，献公之立，在公元前385年，是入战国后的九十六年，孝公（嬴渠梁，商鞅变法）之立，在公元前361年，是入战国后的一百二十年了。再经秦惠文王（嬴驷，丞相张仪合纵）、武王（嬴荡）、昭襄王（嬴稷，又称秦昭王，前256年灭东周末主赧王，长平之战，和氏璧，丞相范睢，武安君白起）、孝文王（嬴柱，守孝后继位仅三天暴崩）、庄襄王（赢子楚，异人，在位三年，奇货可居，丞相吕不韦）。至前246年，秦始皇立。前230年，灭韩。前228年，灭赵。燕大子丹使荆轲刺秦王，不中，秦大发兵以攻燕。前226年，燕王喜奔辽东。前225年，秦人灭魏。前223年，灭楚。前222年，发兵攻辽东，灭燕。前221年，即以灭燕之兵南灭齐，而天下遂统一。 秦（公元前221年~前206年，共16年）秦始皇尽灭六国，事在公元前221年，自公元前206年，子婴投降，秦朝灭亡。秦废分封制，建封建制。 秦始皇帝以前210年，东巡死于沙丘（今河北邢台县）。他大的儿子，名唤扶苏，先已谪罚到上郡去（今陕西绥德县），做蒙恬军队中的监军了。从前政治上的惯例，太子是不出京城，不做军队中的事务的，苟其如此，就是表示不拟立他的意思。所以秦始皇的不立扶苏，是预定了的。 胡亥既立，是为二世皇帝。他诛戮群公子，又杀掉蒙恬的兄弟蒙毅。最后，连劳苦功高、资格很老的李斯都被杀掉。于是秦朝的政府，失其重心，再不能箝制天下了。 秦始皇死的明年，戍卒陈胜、吴广起兵于蕲（今安徽宿县），北取陈。胜自立为王，号张楚。 秦将章邯，镇压了陈胜、吴广，又打死了新立的魏王。战国时楚国的名将，即最后支持楚国而战死的项燕的儿子项梁，和其兄子项籍（项羽，名籍，字羽），起兵于吴，引兵渡江而西（今江苏之江南，古称江东。古所谓江南，指今之湖南）。以居巢人范增的游说，立楚怀王的后裔于盱眙（居巢，今安徽巢县。盱眙，今安徽盱眙县），仍称为楚怀王（以祖谥为生号）。项梁引兵而北，兵锋颇锐，连战皆胜，后亦为章邯所袭杀。 起兵于沛的刘邦即汉高祖西入关（沛，今江苏沛县）。项籍大破秦兵于巨鹿。汉高祖亦自武关而入。此时二世和赵高，不知如何又翻了脸，赵高弑二世，立其兄子婴，婴又刺杀高，正当纷乱之际，汉高祖的兵已到霸上（在今陕西长安县东）子婴只得投降，秦朝就此灭亡。此事在前206年。 楚（公元前208年~202年，共5年）项籍既破章邯之后，亦引兵西入关。汉高祖先已入关了，即遣将守关。项羽怒，把他攻破。进兵至鸿门（在今陕西临潼县），和高祖几乎开战。幸而有人居间调解，汉高祖自己去见项籍，解释了一番，战事得以未成（鸿门宴）。此时即议定了分封之事。这一件事，《史记》的《自序》称为“诸侯之相王”，可见形式上是取决于公议的。其所封的：为（一）六国之后，（二）亡秦有功之人，（三）而楚怀王则以空名尊为义帝，（四）实权则在称为西楚霸王的项籍（都彭城，当时称其地为西楚。江陵为南楚，吴为东楚）。这是摹仿东周以后，天子仅拥虚名，而实权在于霸主的。分封的办法，我们看《史记》所载，并不能说他不公平。汉朝人说：楚怀王遣诸将入关时，与之约：先入关者王之，所以汉高祖当王关中，项籍把他改封在巴、蜀、汉中为背约。姑无论这话的真假，即使是真的，楚怀王的命令，安能约束楚国以外的人呢？这且不必论他。分封甫定，而叛乱即起于东方。项籍因为是霸王，有征讨的责任，用兵于齐。汉高祖乘机北定关中。又出关，合诸侯之兵，攻破彭城。项籍虽然还兵把他打败，然汉高祖坚守荥阳、成皋（荥阳，今河南荥泽县。成皋，今河南汜水县），得萧何镇守关中，继续供给兵员和粮饷。遣韩信渡河，北定赵、代，东破齐。彭越又直接扰乱项籍的后方。至前202年，项籍遂因兵少食尽，为汉所灭。从秦亡至此，不过五年。 汉（公元前202年~公元220年，共407年）西汉（公元前202年~公元8年，共210年）所以汉高祖的灭楚，以实在情形论，与其说是汉灭楚，毋宁说是许多诸侯，亦即许多支新崛起的军队，联合以灭楚，汉高祖不过是联军中的首领罢了。 汉初异姓之王，有楚王韩信、梁王彭越、赵王张敖、韩王信、淮南王英布、燕王臧荼、长沙王吴芮。 到前195年汉高祖死时，只剩得一个地小而且偏僻的长沙国了。天下至此，才真正可以算是姓刘的天下。其成功之速，可以说和汉高祖的灭楚，同是一个奇迹。 以一个政府之力统治全国，秦始皇是有此魄力的，或亦可以说是有此公心，替天下废除封建，汉高祖却无有了。既猜忌异姓，就要大封同姓以自辅，于是随着异姓诸侯的灭亡，而同姓诸国次第建立。 宗族社会中，所信任的，不是同姓，便是外戚汉高祖东征西讨，频年在外，中央政府所委任的便是他的皇后吕氏（吕雉）。 高祖死后，在吕后的统治下，惠帝在位七年，其后少帝在位四年被吕后所废而立其弟。吕后活着的时候，虽然封了几个母家的人为王，却都没有到国。吕后其实并无推翻刘氏、重用吕氏的意思。 吕后死后，齐王起兵，和吕氏对峙。最后丞相陈平、太尉周勃等，策反军人，反对吕氏。把吕禄、吕产和其余吕氏的人都杀掉。在高帝现存的儿子中，择其最长的，迎立了代王恒，是为文帝。文帝以手段解决了齐样。汉初宗室、外戚、功臣的三角斗争，至此才告结束。 此后同姓诸侯逐渐成为问题，前157年，文帝死，子景帝立。再到武帝，又用主父偃之计，令诸侯得以其地分封自己的子弟，在平和的手腕中，把“众建诸侯而少其力”一语，彻底实行了。封建政体反动的余波，至此才算解决。 汉武帝在大家印象中都是一代雄主，但是吕思勉在本书中却把武帝写的很平庸，甚至还有些昏庸。不过无论如何，在武帝时期，击退了匈奴，开辟了丝绸之路，扩大了中国的版图。 前87年，武帝死，立赵婕妤所生幼子弗陵，是为昭帝。霍光、上官桀、桑弘羊、金日￼同受遗诏辅政。赵婕妤先以谴死。褚先生《补外戚世家》说：是武帝怕身死之后，嗣君年少，母后专权，先行把他除去的。《汉书·霍光传》又说：武帝看中了霍光，使画工画了一幅周公负成王朝诸侯的图赏给他。 前74年，昭帝死，无子。霍光迎立昌邑王的儿子贺，旋又为光所废，而迎太子据之孙病已于民间，是为宣帝。宣帝既立，自然委政于光，立六年而光死，事权仍在霍氏手里。宣帝不动声色地，逐渐把他们的权柄夺去，任用自己的亲信。至前66年，而霍氏被诛灭。 前49年，宣帝崩，子元帝立。前36年，西域副都护陈汤矫诏发诸国兵袭杀郅支。汉朝国威之盛，至此亦达于极点。 自霍光秉政之时的，那便是宰相之权，移于尚书。朝无重臣，遂至嬖倖得干相位，外戚得移朝祚，西汉的灭亡，相权的丧失实在是一个重要的原因。 元帝以前33年死，子成帝立。成帝是个荒淫无度的人，喜欢了一个歌者赵飞燕，立为皇后。成帝性又优柔寡断，事权遂入于外家王氏之手。前7年，成帝崩，哀帝立。前1年，哀帝崩，无子，王莽乘机复出，迎立平帝。诛灭丁、傅、董贤，旋弑平帝而立孺子婴（哀、平二帝皆元帝孙，孺子为宣帝曾孙）。王莽从居摄改称假皇帝，又从假皇帝变做真皇帝，改国号为新，而前汉遂亡。此事在公元9年。 新朝（王莽篡汉，改制，公元9年~公元23年，共15年）公元17年，叛乱四起，汉朝宗室后人多股势力。直到公元36年，光武帝刘秀平定天下，建立东汉。而自王莽举行这样的大改革而失败后，政治家的眼光，亦为之一变。根本之计，再也没有人敢提及。社会渐被视为不可以人力控制之物，只能听其迁流所至。“治天下不如安天下，安天下不如与天下安”，遂被视为政治上的金科玉律了。所以说：这是中国历史上的一个大转变。 东汉（公元25年~公元220年，共192年）后汉自公元25年光武帝即位起，至公元220年为魏所篡止，共计一百九十二年；若算到公元189年董卓行废立，东方起兵讨卓，实际分裂之时为止，则共得一百七十五年；东汉国力的充实，则远不如西汉了。这是因为东汉移都洛阳，对于西北两面的控制，不如西汉之便；又承大乱之后，海内凋敝已极，休养未几，而羌乱即起，其富力亦不如西汉之盛之故。公元57年，光武帝崩，子明帝立。亦能守其遗法。公元75年，明帝崩，子章帝立，政治虽渐见宽弛，然尚能蒙业而安。章帝以公元88年崩。自公元36年公孙述平定至此，共计五十二年，为东汉治平之世。 东汉的乱源，共有好几个，其中最重要的，就是外戚和宦官。多任皇帝都在依靠外戚消灭宦官或依靠宦官消灭外戚。后汉外戚之祸，起于章帝时。章帝崩，肇立，是为和帝。后兄窦宪专权。和帝既长，与宦者郑众谋诛之，是为后汉皇帝和宦官合谋以诛外威之始。 105年，和帝崩。据说和帝的皇子，屡次夭殇，所以生才百余日的殇帝，是寄养于民间的。皇后邓氏迎而立之。明年，复死。乃迎立清河王的儿子，是为安帝。邓太后临朝，凡十五年。太后崩后，安帝亲政，任用皇后的哥哥阎显，又宠信宦官和乳母王圣，政治甚为紊乱。阎皇后无子，后宫李氏生子保，立为太子。后谮杀李氏而废保。125年，安帝如宛，道崩。皇后秘丧驰归，迎立章帝之孙北乡侯懿。当年即死。宦者孙程等迎立废太子保，是为顺帝。程等十九人皆封列侯。然未久即多遭谴斥。顺帝任用皇后的父亲梁商，梁商为人还算谨慎。商死后，子冀继之，其骄淫纵恣，为前此所未有。144年，顺帝崩，子冲帝立。明年崩。梁冀迎立章帝的玄孙质帝。因年小聪明，为冀所弑。又迎立章帝的曾孙桓帝。桓帝立十三年后，才和宦者单超等五人合谋把梁冀诛戮，自此宦官又得势了。（东汉后面这帮皇帝简直就是走马灯一样啊） 167年，桓帝崩，无子，窦后和武定策禁中，迎立了章帝的玄孙灵帝。灵帝年长，不徒不知整顿，反更崇信宦官，听其把持朝政，浊乱四海。 三国（220年~280年，共60年）汉灵帝崩，未及定太子。校尉、宦官、太后等势力争夺致京城大乱。凉州将董卓拥兵入京，废了废帝，立协为献帝。后司徒王允联合董卓亲信吕布把董卓杀了。董卓将校李傕、郭汜又回兵替董卓报仇。吕布出奔，王允被杀。汉中央政府就此瓦解，不再能号令全国。 当时割据情况：幽州有公孙瓒。冀州有袁绍。兖州有曹操。徐州始而是陶谦，后来成为刘备和吕布争夺之场。扬州，今寿县一带，为袁术所据，江东则入于孙策。荆州有刘表。益州有刘焉。这是较大而在中原之地的，其较小较偏僻的，则汉中有张鲁，凉州有马腾、韩遂，辽东有公孙度。袁绍击灭了公孙瓒，又占据了并州，地盘最大，而曹操最有雄才大略。献帝因不堪李傕、郭汜的压迫，逃归洛阳，贫弱不能自立，召曹操入卫，操移献帝于许昌，遂成挟天子以令诸侯之势。 刘备为吕布所破，逃归曹操，曹操和他合力击杀了吕布。袁术因荒淫无度，不能自立，想走归袁绍，曹操又使刘备邀击，术退走，旋死。刘备叛操，操又击破之。 公元200年，袁绍举大兵南下，与操相持于官渡（城名，在今河南中牟县北），为操所败。绍气愤死。公元205年，绍二子并为操所灭。于是北方无与操抗者。 208年，操南征荆州。刘表适死，其幼子琮，以襄阳降（今湖北襄阳县，当时荆州治此）。刘备时在荆州，走江陵。操追败之。备奔刘表的长子琦于江夏（汉郡，后汉时，郡治在今湖北黄冈县境），和孙权合力，败操于赤壁（山名，在今湖北嘉鱼县）。于是刘备屯兵荆州，而孙权亦觊觎其地。后备乘刘焉的儿子刘璋暗弱，夺取益州。孙权想攻荆州，刘备同他讲和，把荆州之地平分了。时马腾的儿子马超和韩遂反叛，曹操击破之。又降伏了张鲁。刘备北取汉中。曹操自争之，不能克，只得退回。天下渐成三分之势。 刘备初见诸葛亮时，诸葛亮替他计划，就是据有荆、益两州，天下有变，命将将荆州之兵以向宛、洛，而自率益州之众以出秦川的。这时的形势，颇合乎这个条件。备乃命关羽自荆州北伐，取襄阳，北方颇为震动，而孙权遣兵袭取江陵，羽还救，为权所杀。刘备忿怒，自将大兵攻权，又大败于猇亭（在今湖北宜都县西）。于是荆州全入于吴。备旋以惭愤而死，此事在公元223年。先是220年，曹操死，子丕篡汉自立，是为魏文帝。其明年，刘备称帝于蜀，是为蜀汉昭烈帝。孙权是到229年才称帝的，是为吴大帝。天下正式成为三分之局。 魏文帝本来无甚才略。死后，儿子明帝继立，荒淫奢侈，朝政更坏。其时司马懿屡次带兵在关中和诸葛亮相持，又平定了辽东。明帝死后，于齐王芳年幼，司马懿和曹爽同受遗诏辅政。其初大权为曹爽所专。司马懿托病不出，而暗中运用诡谋，到底把曹爽推翻，大权遂尽入其手。司马懿死后，他的儿子司马师、司马昭相继把持朝局。蜀自诸葛亮死后，蒋琬、费祎继之，不复能出兵北伐。费祎死后，姜维继之，频年出兵北伐而无功，民力颇为疲敝。后主又信任宦官，政局渐坏。司马昭乘此机会，于263年发兵灭蜀。司马昭死后，他的儿子司马炎继之，于265年篡魏，是为晋武帝。至280年而灭吴统一中国。 晋（265年~420年，共154年）西晋（265年~316年，共51年）魏晋以降，清谈之风，奢侈之风大盛。门阀制度渐次形成，影响及于选举，高位多为贵族所盘据，起自中下阶层中较有活气的人，参与政治的机会较少，政治自然不免腐败。门阀用人之习既成，贵游子弟，出身便做好官，富贵吾所自有，朝代变换，这班人却并不更动，遂至“忠君之念已亡，保家之念弥切”（说本《南史·褚渊传论》）。后汉以来，因贪一时便利之故，多用降伏的异族为兵，兵权倒持在异族手里，遂成为五胡扰乱的直接原因。 东晋（五胡乱华、十六国）（317年~420年，共103年）晋初五胡的形势，是如此的：（一）匈奴。散布在并州即今山西省境内。（二）羯。史籍上说是匈奴的别种，以居于上党武乡的羯室而得名的（在今山西辽县）。（三）鲜卑。后汉时，北匈奴败亡，鲜卑徙居其地。其酋长檀石槐，曾一时控制今蒙古之地，东接夫余（与高句丽同属貉族。其都城，即今吉林的长春县），西至西域。五胡中人数最多、分布最广的一族。（四）氐。氐人本来是居于武都的（即白马氐之地，今甘肃成县），魏武帝怕被蜀人所利用，把他迁徙到关中。（五）羌。即后汉时叛乱之余。氐、羌都在泾、渭两水流域。当时的五胡大部分是居于塞内的，间或有在塞外的，亦和边塞很为接近。八王之乱是五胡之乱的导火索。 南北朝（（420年~589年，共170年）南北朝的对立，始于公园420年宋之代晋，终于公园589年隋之灭陈。期间涉及的很多的国家、民族和氏族，比如北魏的拓跋氏，宇文氏，慕容氏等，其中有大量的胡人氏族。国家政权和皇帝频繁更替，因此两晋南北朝时期向来被视为黑暗时代。其实也不尽然，这一时代只是政治上稍形黑暗，社会文化还是依然如故。而且正因时局动荡，文化乃得以更大的发展。三国之世，南方的风气还是很剽悍的。而自东晋以来，此种风气，亦潜移默化。谈玄学佛，成文全国文化的重心。 五胡之中虽然有荒淫暴虐之人，但更多的还是能服从汉族文化。如石勒、苻坚、慕容氏，北魏孝文帝等。其中有些政治思想和制度为隋唐所沿袭。这时的异族除了血统之外，几乎已经和汉族无异。到了隋唐时代，所谓五胡便已泯然无迹。 隋（581年~619年，共39年）南北朝时期的君主，有荒淫暴虐的，也有励精图治的。隋文帝是十足的后一种典型。他勤于政务，躬身行俭。在位时免除苛捐杂税，国库充盈，大破突厥，并通过离间使其分化为东西突厥。从南北朝以来畏服北狄的心理由此一变。但政局虽然好转了，文化却不能一时急转。隋文帝的太子勇，具有胡化性质。次子广，也就是隋炀帝，又有荒淫猜忌的性质。太子因失欢于文帝后独孤氏被废。炀帝立，以洛阳为东都。开通运河，乘龙舟往来于洛阳、江都之间。于611、613、614年，三次发兵高句丽，天下骚动，乱者四起。炀帝见中原已乱，无心北归，滞留江都，618年，为其下所弑。 唐（618年~907年，共289年）唐朝通常分为四个时期，高祖至高宗的“初唐”、武则天至玄宗的“盛唐”、肃宗至文宗的“中唐”、武宗至哀帝的“晚唐”。 隋炀帝死后，当时的北方群雄，以河北窦建德、河南李密为最大。而唐高祖李渊，以太原留守，于617年起兵，西据关中，又平定河西、陇右，形势最为完固。炀帝死后，其将王世充用众北归，据洛阳。李密为其所败，降唐。又出关谋叛，为唐将所斩。唐兵围洛阳，窦建德来救，唐兵大败擒之，王世充亦降。南方割据的，以江陵的萧铣为最大，亦为唐所灭。北边依附突厥的，亦次第破灭。隋亡后约十年，而天下复定。 贞观之治唐朝开国之君虽为高祖，然其事业，实在大部分是太宗做的。天下既定之后，其哥哥太子建成和兄弟齐王元吉，要想谋害他，为太宗所杀。高祖传位于太宗，遂开出公元627至649的二十三年间的“贞观之治”。 唐朝对外的声威，至此可谓达于最高峰了。太宗又被胡人尊为天可汗。因国威之遐畅，而我国的文化，和别国的文化，就起了交流互织的作用。东北一隅，自高句丽、百济平后，新罗即大注意于增进文化。日本亦屡遣通唐使，带了许多僧侣和留学生来。朝鲜半岛南部和日本的举国华文化，实在此时。西方则大食帝国勃兴于此时。大食在文化上实在是继承希腊，而为欧洲近世的再兴导其先路的。中国和大食，政治上无甚接触，而在文化上则彼此颇有关系。回教的经典和历数等知识，都早经输入中国。而称为欧洲近世文明之源的印刷术、罗盘针、火药，亦都经中国人直接传入回教国，再经回教国人之手，传入欧洲。 在史学界有大量关于李唐是汉族还是胡人的争执，然而民族的特征，乃文化而非血统。 太宗太子承乾与魏王李泰互斗被废，立高宗李治，高宗的性质是失之于柔懦的。他即位之初，还能遵守太宗的成规，所以永徽之政，史称其比美贞观。公元655年，高宗惑于才人武氏，废皇后王氏而立之。武后本有政治上的才能，高宗又因风眩之故，委任于她，政权遂渐入其手。 683年，高宗崩，子中宗立。明年，即为武后所废，徙之房州（今湖北竹山县），立其弟豫王旦（即后来的睿宗）。690年，又废之，改国号为周，自称则天皇帝。后以宰相狄仁杰之言，召回中宗，立为太子。705年，宰相张柬之等乘武后卧病，结宿卫将，奉中宗复位。自武后废中宗执掌政权至此，凡二十二年，若并其为皇后时计之，则达五十五年之久。武后虽有才能，可是宅心不正。她是一种只计维持自己的权势地位而不顾大局的政治家。 中宗是个昏庸之主，并不能铲除武后时的恶势力。皇后韦氏专权，和武后的侄儿子武三思私通，武氏因此复盛。张柬之等反遭贬谪而死。韦后的女儿安乐公主，中宗的婕妤上官婉儿，亦都干乱政治。 开元盛世710年，中宗为韦后所弑。相王旦之子临淄王隆基定乱而立相王，是为睿宗。立隆基为太子。武后的女儿太平公主仍干政，惮太子英明，要想摇动他。幸而未能有成，太平公主被谪，睿宗亦传位于太子，是为玄宗。玄宗用姚崇为相，廓清从武后以来的积弊。自713至741年，史家称为开元之治。末年，突厥复衰乱，744年，乘机灭之；连年和吐蕃苦战，把中宗时所失的河西九曲之地亦收复；国威似乎复振。然自武后已来，荒淫奢侈之习，渐染已深。玄宗初年，虽能在政治上略加整顿，实亦堕入其中而不能自拔。中岁以后，遂渐即怠荒。宠爱杨贵妃，把政事都交给一个奸佞的李林甫。李林甫死后，又用一个善于夤缘的杨国忠。天宝之乱，就无可遏止了。 安史之乱唐朝的盛衰，以安史之乱为关键。安史之乱，皇室的腐败只是一个诱因，其根源是别有所在的。（一）唐朝的武功从表面看，虽和汉朝相等，其声威所至，或且超过汉朝，但此乃世运进步使然，以经营域外的实力论，唐朝实非汉朝之比。汉武帝时，攻击匈奴，前后凡数十次；以至征伐大宛，救护乌孙，都是仗自己的实力去摧破强敌。唐朝的征服突厥、薛延陀等则多因利乘便，且对外多用蕃兵。玄宗时，府兵制度业已废坏，而吐蕃、突厥都强，契丹势亦渐盛。欲图控制、守御，都不得不加重边兵，所谓藩镇，遂兴起于此时，天下势成偏重。（二）胡字本是匈奴的专称，后渐移于一切北族。再后，又因文化的异同易泯，种族的外观难改，遂移为西域白种人的专称（详见拙著《胡考》，在《燕石札记》中，商务印书馆本）。唐朝对待被征服的异族，亦和汉朝不同。汉朝多使之入居塞内，唐朝则仍留之于塞外，而设立都护府或都督府去管理他。所以唐朝所征服的异族虽多，未曾引起像五胡乱华一般的杂居内地的异族之患。然环伺塞外的异族既多，当其种类昌炽，而中国政治力量减退时，就不免有被其侵入的危险了。唐朝都中后期，已经约束不了藩镇节度使。 安禄山，《唐书》说他是营州柳城胡。他本姓康，随母嫁虏将安延偃，因冒姓安。安、康都是西域姓。史思明，《唐书》虽说他是突厥种，然其状貌，“鸢肩伛背，廞目侧鼻”，怕亦是一个混血儿。安禄山和史思明都能通六蕃译，为互市郎，可见其兼具西胡和北族两种性质。755年，自范阳举兵反。不一月而河北失陷，河南继之，潼关亦不守，玄宗逃向成都。于路留太子讨贼，太子西北走向灵武（灵州，治今宁夏灵武县），即位，是为肃宗。安禄山虽有强兵，却无政治方略，诸将亦都有勇无谋，既得长安之后，不能再行进取。朔方节度使郭子仪（朔方军，治灵州），乃得先平河东，就借回纥的兵力，收复两京（长安，洛阳）。安禄山为其子庆绪所杀。九节度之师围庆绪于邺。因号令不一，久而无功。史思明既降复叛，自范阳来救，九节度之师大溃。思明杀庆绪，复陷东京。李光弼与之相持。思明又为其子朝义所杀。唐朝乃得再借回纥之力，将其打平。此事在762年。其时肃宗已死，是代宗的元年了。安史之乱首尾不过八年，然对外的威力自此大衰，内治亦陷于紊乱、唐朝就日入于衰运了。 沙陀入侵公元779年，代宗崩，子德宗立，颇思振作。德宗因屡遭叛变，不敢相信臣下。回京之后，使宦官带领神策军，宦官就从此握权。805年，德宗崩，子顺宗立。顺宗在东宫时，即深知宦官之弊。即位后，用东宫旧臣王叔文等，想要除去宦官。然顺宗在位仅八个月，即传位于子宪宗。宪宗死后，穆宗即位。穆宗崩，敬宗立，为宦官刘克明所弑。宦官王守澄讨贼而立文宗。文宗初用宋申锡为宰相，与之谋诛宦官，不克。文宗自此受制于宦官，几同傀儡。文宗死后，弟武宗靠着仇士良之力，杀太子而自立。武宗能任用李德裕，政治尚称清明。宣宗立，尤能勤于政事，人称之为小太宗。然于宦官，亦都无可如何。宣宗死后，子懿宗立。886年，徐、泗卒戍桂州者作乱（徐州，今江苏铜山县。泗州，今安徽泗县。桂州，今广西桂林县），用沙陀兵讨平之，沙陀入据中原之祸，遂于是乎开始。 873年，懿宗崩，子僖宗立。年幼，信任宦官田令孜。时山东连年荒歉。875年，王仙芝起兵作乱，黄巢聚众应之。后来仙芝被杀，而黄巢到处流窜。后攻入长安。时为880年。当黄巢横行时，藩镇都坐视不肯出兵剿讨。京城失陷之后，各路的援兵又不肯进攻。不得已，就只好再借重沙陀。朝廷乃赦李克用的罪，召他回来。打败黄巢，收复长安。李克用镇守河东，沙陀的根据地更深入腹地了。 朱温代唐在此情势之下，汉民族有一个人，能够和沙陀抵抗的，那便是朱全忠。全忠本名温，是黄巢的将，巢败后降唐，为宣武节度使。僖宗死于888年，弟昭宗立，颇为英武。然其时的事势，业已不能有为。到10世纪初年，全忠的势力已经远超出乎李克用之上了。唐朝的宰相崔胤，乃结合了他，以谋宦官。宦官见事急，挟昭宗走凤翔。全忠围凤翔经年，李茂贞不能抗，只得把皇帝送出，同朱全忠讲和。昭宗回到京城，就把宦官悉行诛灭。唐朝中叶后的痼疾，不是藩镇，实在是宦官。因为唐朝的藩镇，并没有敢公然背叛，或者互相攻击，不过据土自专，更代之际，不听命令而已。而唐朝中叶后的君主，如顺宗、文宗、武宗、宣宗、昭宗等，又都未尝不可与有为。其始终不能有为，则全是因被宦官把持之故。 宦官既亡，唐朝亦与之同尽。公元903年，朱全忠迁帝于洛阳，弑之而立其子昭宣帝。至907年，遂废之而自立，是为梁太祖。此时海内割据的：淮南有杨行密，是为吴。两浙有钱镠，是为吴越。湖南有马殷，是为楚。福建有王审知，是为闽。岭南有刘岩，是为南汉。剑南有王建，是为前蜀。遂入于五代十国之世。 五代十国 - 中国文化的三个阶段（907年~960年，共53年）在唐、宋之间，中国的文化，是有一个转变的。中国的文化，截至近世受西洋文化的影响以前，可以分做三个时期：第一期为先秦、两汉时代的诸子之学。第二期为魏、晋、南北朝、隋、唐时代的玄学和佛学。第三期为宋、元、明时代的理学。这三期，恰是一个正、反、合。 原来先秦时代的学术，是注重于矫正社会的病态的，所谓“拨乱世，反之正”，实不仅儒家，而为各家通有的思想。王莽变法失败以后，大家认为此路不通，而此等议论，渐趋消沉。魏、晋以后，文化乃渐转向，不向社会而向个人方面求解决。他们所讨论的，不是社会的组织如何。这种动机，确和佛教相契。在这一千年中，传统的儒家，仅仅从事于笺疏，较有思想的人，都走入玄学和佛学一路，就是其明证。但其结果却是怎样呢？显然的，从个人方面着想，所能改良的，只有极小一部分，合全体而观之，依然无济于事。而其改善个人之法，推求到深刻之处，就不能不偏重于内心。工夫用在内心上的多，用在外务上的，自然少了。他们既把社会看做各个分子所构成；社会的好坏，原因在于个人的好坏，而个人的好坏，则原于其内心的好坏；如此，社会上一切问题，自然都不是根本。而他们的所谓好，则实和此世界上的生活不相容，所以他们最彻底的思想，是要消灭这一个世界。明知此路不通，则又一转变而认为现在的世界就是佛国；只要心上觉悟，一切行为虽和俗人一样，也就是圣人。这么一来，社会已经是好的了，根本用不着改良。这两种见解，都是和常识不相容的，都是和生活不相合的。凡是和生活不相合的，而事情一到和大多数人的生活相矛盾，就是他的致命伤。物极必反，到唐朝佛学极盛时，此项矛盾，业经开始发展了，于是有韩愈的辟佛。他的议论很粗浅，不过在常识范围中批评佛说而已，到宋儒，才在哲学上取得一个立足点。 宋学从第十一世纪的中叶起，到第十七世纪的中叶止，支配中国的思想界，约六百年。他们仍把社会看做是各分子所构成的；仍以改良个人为改良社会之本；要改良个人，还是注重在内心上；这些和佛学并无以异。所不同的，则佛家认世界的现状，根本是坏的，若其所谓好的世界而获实现，则现社会的组织，必彻底被破坏，宋学则认现社会的组织，根本是合理的，只因为人不能在此组织中，各处于其所当处的地位，各尽其所应尽的责任，以致不好。而其所认为合理的组织，则是一套封建社会和农业社会中的道德、伦理和政治制度。 在商业兴起，广大的分工合作日日在扩充，每一个地方自给自足的规模，业已破坏净尽，含有自给自足性质的大家族，亦不复存在之时，早已不复适宜了。宋儒还要根据这一个时代的道德、伦理和政治制度，略加修改，制成一种方案，而强人以实行，岂非削足适屦？岂非等人性于杞柳，而欲以为杯棬？所以宋儒治心的方法，是有很大的价值的，而其治世的方法，则根本不可用。不过在当时，中国的思想界，只能在先秦诸子和玄学、佛学两种思想中抉择去取，融化改造，是只能有这个结果的，而文化进化的趋向，亦就不得不受其指导。在君主专制政体下，政治上的纲纪所恃以维持的，就是所谓君臣之义这种纲纪，是要秩序安定，人心也随着安定，才能够维持的。到兵荒马乱，人人习惯于裂冠毁裳之日，就不免要动摇了。南北朝之世因其君不足以为君，而有“殉国之感无因，保家之念宜切”的贵族。到晚唐、五代之世，此种风气，又盛行了。于是既有历事五朝，而自称长乐老以鸣其得意的冯道，又有许多想借重异族，以自便私图的杜重威。由今之道，无变今之俗，如何可以一朝居？所以宋儒要竭力提倡气节。经宋儒提倡之后，士大夫的气节，确实是远胜于前代。但宋儒（一）因其修养的工夫，偏于内心，而处事多疏。（二持躬过于严整，而即欲以是律人，因此，其取人过于严格，而有才能之士，皆为其所排斥。（三）又其持论过高，往往不切于实际。（四）意气过甚，则易陷于党争。党争最易使人动于感情，失却理性，就使宅心公正，也不免有流弊，何况党争既启，哪有个个人都宅心公正之理？自然有一班好名好利、多方掩饰的伪君子，不恤决裂的真小人混进去。到争端扩大而无可收拾，是非淆乱而无从辨别时，就真有宅心公正、顾全大局的人，也苦于无从措手了。所以宋儒根本是不适宜于做政治事业的。若说在社会上做些自治事业，宋儒似乎很为相宜。宋儒有一个优点，他们是知道社会上要百废俱举，尽其相生相养之道，才能够养生送死无憾，使人人各得其所的。他们否认“治天下不如安天下，安天下不如与天下安”的苟简心理，这一点，的确是他们的长处。但他们所以能如此，乃是读了经书而然。而经书所述的，乃是古代自给自足，有互助而无矛盾的社会所留诣，到封建势力逐渐发展时，此等组织，就逐渐破坏了。宋儒不知其所主张的道德、伦理、政治制度，正和这一种规制相反，却要藉其所主张的道德、伦理和政治制度之力，以达到这一个目的。其极端的，遂至要恢复井田封建。平易一些的，亦视智愚贤不肖为自然不可泯的，一切繁密的社会制度，还是要以士大夫去指导着实行，而其所谓组织，亦仍脱不了阶级的对立。所以其结果，还是打不倒土豪劣绅，而宋学家，特如其中关学一派，所草拟的极详密的计划，以极大的热心去推行，终于实现的寥若晨星，而且还是昙花一现。这时候，外有强敌的压迫，最主要的事务，就是富国强兵，而宋儒却不能以全力贯注于此。最需要的，是严肃的官僚政治，而宋学家好作诛心之论，而忽略形迹；又因党争而淆乱是非，则适与之相反。宋学是不适宜于竞争的，而从第十一世纪以来，中国的文化，却受其指导，那无怪其要迭招外侮了。 宋（960年~1279年，共319年）北宋（960年~1127年，共167年）959年，北周周世宗遂举兵伐辽，恢复了瀛、莫、易三州，直逼幽州。此时正直契丹中衰之际，倘使周世宗不死，燕、云十六州，是很有恢复的希望的，以后的历史，就全然改观了。惜乎世宗在途中遇疾，只得还军，未几就死了。嗣子幼弱，明年，遂为宋太祖所篡。962年宋太祖因朗州和衡州相攻击（衡州，今湖南衡山县），遣人来求救，遣兵假道南平前往，把南平和朗州都破掉（衡州先已为朗州所破）。965年，遣兵灭后蜀。971年，遣兵灭南汉。975年，遣兵灭南唐。是年，太祖崩，弟太宗立。976年，吴越纳土归降。明年，太宗遂大举灭北汉。于是中国复见统一。 五代末年，偏方割据诸国，多微弱不振。契丹则是新兴之国，气完力厚的，颇不容易对付，所以宋太祖要厚集其力以对付他。宋朝若要以力服契丹，非有几十万大兵，能够连年出征，攻下了城能够守，对于契丹地方，还要能加以破坏扰乱不可。这不是容易的事，所以宋太祖不肯轻举。而太宗失之轻敌，灭北汉后，不顾兵力的疲敝，立刻进攻。于是有高梁河之败（在北平西）。至公元985年，太宗又命将分道北伐，亦不利。而契丹反频岁南侵。契丹大举深入，便可直达汴梁对岸的大名，宋朝受威胁殊甚。1004年，辽圣宗奉其母入寇，至澶州（今河北濮阳县）。真宗听了宰相寇准的话，御驾亲征，才算把契丹吓退。然毕竟以岁币成和（银十万两，绢二十万匹）。宋朝开国未几，国势业已陷于不振了。1022年，真宗崩，仁宗立。1034年，德明之子元昊反，兵锋颇锐。宋朝屯大兵数十万于陕西，还不能戢其侵寇。到1044年，才以岁赐成和（银、绢、茶、彩，共二十五万五千）。此时辽圣宗已死，兴宗在位，年少气盛，先两年，遣使来求关南之地（瓦桥关，在雄县。周世宗复瀛、莫后，与辽以此为界），宋亦增加了岁币（增银十万两，绢十万匹），然后和议得以维持。给付岁币的名义，《宋史》说是纳字，《辽史》却说是贡字，未知谁真谁假。然即使用纳字，亦已经不甚光荣了。仁宗在位岁久，政颇宽仁，然亦极因循腐败。兵多而不能战，财用竭蹶而不易支持，已成不能振作之势。1063年，仁宗崩，英宗立，在位仅四年。神宗继之，乃有用王安石变法之事。 宋朝当日，相须最急的是富国强兵。王安石改革的规模颇大，旧日史家的议论，则说他是专注意于富强的（尤其说王安石偏于理财。此因关于改革社会的行政，不为从前的政治家所了解之故）。安石为相仅七年，然终神宗之世，守其法未变。1085年，神宗崩，子哲宗立。神宗之母高氏临朝，起用旧臣，尽废新法。其死后，哲宗亲政，复行新法，谓之“绍述”。1100年，哲宗崩，徽宗立，太后向氏权同听政。想调和新旧之见，特改元为建中靖国。徽宗亲政后，仍倾向于新法。而其所用的蔡京，则是反复于新旧两党间的巧宦。徽宗性极奢侈，蔡京则搜括了各方面的钱，去供给他浪用。政治情形一落千丈。恢复燕、云和西北，可说是神宗和王安石一个很大的抱负。但因事势的不容许，只得先从事于其易。徽宗时，宦者童贯，继续用兵西北，则徒招劳费而已。总之：宋朝此时的情势，业已岌岌难支，幸辽、夏亦已就衰，暂得无事，而塞外有一个新兴民族崛起，就要大祸临头了。 金朝的先世，便是古代的所谓肃慎，南北朝、隋、唐时的靺鞨。宋以后则称为女真（女真两字，似即肃慎的异译。清人自称为满洲，据明人的书，实作满住，乃大酋之称，非部族之名）。金朝的始祖名唤函普，是从高句丽旧地入居生女真的完颜部，而为其酋长的。部众受其教导，渐次开化。其子孙又以渐征服诸部族，势力渐强。而辽自兴宗后，子道宗立，政治渐乱。宋人约金攻辽之事又起。先是童贯当权，闻金人攻辽屡胜，意图侥幸。遣使于金，求其破辽之后，将石晋所割之地，还给中国。金人约以彼此夹攻，得即有之。而童贯进兵屡败，乃又求助于金。金太祖自居庸关入，把南京攻下。太祖旋死，弟太宗立。天祚帝展转漠南，至1125年为金人所获，辽亡。 辽朝灭亡之年，金朝便举兵南下。宗翰自云州至太原，为张孝纯所阻，而宗望自平州直抵汴京。时徽宗已传位于钦宗。初任李纲守御，然救兵来的都不能解围。不得已，许割太原、中山、河间三镇（中山，今河北定县。河间，今河北河间县）；宋主称金主为伯父。 金朝此时，是不知什么国际的礼法的，宗翰听闻宗望得了赂，也使人来求赂。宋人不许。宗翰怒，攻破威胜军和隆德府（威胜军，今山西沁县。隆德府，今山西长治县）。宗翰、宗望再分道南下，两路都抵汴京。徽、钦两宗，遂于1127年北狩。 南宋（1127年~1279年，共152年）公元1129年，金宗翰、宗望会师濮州（今山东濮县）分遣娄室入陕西。其正兵南下，前锋直打到扬州。高宗奔杭州（今浙江杭县）。明年，金宗弼渡江，自独松关入（今安徽广德县东），高宗奔明州（今浙江鄞县）。金兵再进迫，高宗逃入海。金兵亦入海追之，不及乃还。自此以后，金人亦以“士马疲敝，粮储未丰”（宗弼语），不能再行进取了。 秦桧是当金人立张邦昌时，率领朝官，力争立赵氏之后，被金人捉去的。后来以赐挞懒。秦桧从海路逃归。秦桧的意思，是偏重于对内的。因为当时，宋朝的将帅颇为骄横。所以要对外言和，得一个整理内部的机会。当其南还之时，就说要“南人归南，北人归北”。高宗既无进取的雄才，自然意见与之相合。于是用为宰相。1137年，刘豫为宗弼所废。秦桧乘机，使人向挞懒要求，把河南、陕西之地，还给宋朝。挞懒允许了。明年，遂以其地来归。而金朝突起政变。1139年，宗弼回上京（今吉林阿城县）。挞懒南走。至燕京，为金人所追及，被杀。和议遂废。岳飞从湖北进兵，亦有郾城之捷（今河南偃城县）。吴璘亦出兵收复了陕西若干州郡。倘使内部没有矛盾，自可和金兵相持。而高宗、秦桧执意言和，把诸将召还，和金人成立和约：东以淮水，西以大散关为界（在陕西宝鸡县南）；岁奉银、绢各二十五万两、匹。宋高宗称臣于金，可谓屈辱极了。 1162年，高宗传位于孝宗。孝宗颇有志于恢复，任张浚以图进取。浚使李显忠进兵，至符离（集名，在今安徽宿县）大败。进取遂成画饼。 公元1194年，孝宗传位于光宗。此时金世宗亦死，子章宗立，北边颇有叛乱，河南、山东，亦有荒歉之处，金朝的国势渐衰。宋光宗多病，皇后李氏又和太上皇不睦。1194年，孝宗崩，光宗不能出而持丧，人心颇为疑惑。宰相赵汝愚，因閤门使韩侂胄，请于高宗后吴氏，扶嘉王扩内禅，是为宁宗。韩侂胄排去赵汝愚，代为宰相，颇为士流所攻击，想立恢复之功，以间执众口。1206年遂贸然北伐。谁想金兵虽弱，宋兵亦不强。兵交之后，襄阳和淮东西州郡，次第失陷。韩侂胄又想谋和，而金人复书，要斩侂胄之首，和议复绝。皇后杨氏，本和韩侂胄有隙，使其兄次山，勾结侍郎史弥远，把韩侂胄杀掉，函首以畀金。1208年，以增加岁币为三十万两、匹的条件成和。和议成后两年，金章宗死，世宗子卫绍王立。其明年，蒙古侵金，金人就一败涂地。可见金朝是时，业已势成弩末，宋朝并没有急于讲和的必要了。 金亡之前十年，宋宁宗崩，无子。史弥远援立理宗，仍专政。金亡前一年，史弥远死，贾似道继之。忽必烈已平吐蕃、大理，亦东北上至鄂州（今湖北武昌县）。宋将王坚守合州（今四川合川县），宪宗受伤，死于城下。贾似道督大军援鄂，不敢战，使人求和，许称臣，画江为界。忽必烈亦急图自立，乃许之而北归。贾似道掩其事，以大捷闻于朝。忽必烈北还后，自立，是为元世祖。世祖在宪宗时，本来是分治漠南的，他手下又多西域人和中国人。于是以1264年定都燕京。蒙古的根据地，就移到中国来了。明年，理宗崩，子度宗立。宋将刘整叛降元，劝元人攻襄阳。自1268年至1273年，被围凡五年，宋人不能救，襄阳遂陷。明年，度宗崩，子恭帝立。伯颜自两湖长驱南下。1276年，临安不守，谢太后和恭帝都北狩。故相陈宜中立其弟益王于福州（今福建闽侯县），后来转徙，崩于碙州（在今广东吴川县海中）。其弟卫王昺立，迁于崖山（在今广东新会县海中）。1279年，汉奸张弘范来攻，宰相陆秀夫负帝赴海殉国。张世杰收兵图再举，到海陵山（在今广东海阳县海中），舟覆而死。宋亡。中国遂整个为北族所征伏。 元（1271年~1368年，共97年）蒙古所征服之地，几于包括整个亚洲，而且还跨有欧洲的一部分。安史乱后，中国对于西域，就不再过问了。辽朝灭亡后，其宗室耶律大石，会十八部王众于西州（唐西州，今新疆吐鲁番县），简其精锐西行。此时大食的纪纲，久已颓废，东方诸酋，据土自专，形同独立。大石兵至，灭掉雄据呼罗珊的塞而柱克（Seljuks），并压服了花剌子模（Khorazme, 《唐书》作货利习尔），使之纳贡，而立国于吹河之滨，是为西辽。成吉思汗平漠南北时，今蒙古西部乃蛮部的酋长古出鲁克奔西辽，运用阴谋，和花剌子模里应外合而取其国。又有在鄂尔坤、色楞格两河间的蔑儿乞，其酋长忽秃亦西奔，和古出鲁克，都有卷土重来之意。成吉思汗怕根本之地动摇，乃于1213年北归，遣哲别、速不台把这两人击灭。 元世祖时，中国既定，又要介高丽以招致日本。日本不听。世祖遂于1274、1281两年遣兵渡海东征。前一次损失还小。后一次因飓风将作，其将择坚舰先走，余众二十余万，尽为日本所虏，杀蒙古人、高丽人、汉人，而以南人为奴隶，其败绩可谓残酷了。世祖欲图再举，因有事于安南，遂不果。此时后印度半岛之地，安南已独立为国。其南，今柬埔寨之地为占城，蒲甘河附近则有缅国。元兵侵入安南和占城。其人都不服，1284、1285、1287三年，三次发兵南征，因天时地利的不宜，始终不甚得利。其在南洋，则曾一度用兵于爪哇。此外被招致来朝的共有十国，都是今南洋群岛和印度沿岸之地。自成吉思汗崛起至世祖灭宋，共历一百一十二年，而蒙古的武功，臻于极盛。其人的勇于战斗；征服各地方后，亦颇长于统治（如不干涉各国的信教自由，即其一端），自有足称。 如此广大的疆域，自非一个大汗所能直接统治；况且野蛮人的征服，其意义原是掠夺；封建制度自然要随之而兴。蒙古的制度，宗室、外戚、功臣是各有分地的，而以成吉思汗的四个儿子为最大。而分裂即起于其间。太宗死后，其后人和拖雷的后人，就有争夺之意。定宗幸获继立而身弱多病，未久即死。拖雷之子宪宗被推戴。太宗后人，另谋拥戴失烈门，为宪宗所杀，并夺去太宗后王的兵柄。蒙古的内争，于是开始。宪宗死后，世祖不待大会的推戴而自立，阿里不哥亦自立于漠北，为世祖所败，而太宗之子海都自立于西北，察合台、钦察两汗国都附和他。伊儿汗国虽附世祖，却在地势上被隔绝了。终世祖之世不能定。直到1310年，海都之子才来归降。然自海都之叛，蒙古大汗的号令，就不能行于全帝国，此时亦不能恢复了。所以蒙古可说是至世祖时而臻于极盛，亦可说自世祖时而开始衰颓。 辽、金、元三朝，立国的情形，各有不同。契丹虽然占据了中国的一部分，然其立国之本，始终寄于部族，和汉人并未发生深切的关系。金朝所侵占的重要之地，惟有中国。他的故土和他固有的部族，文化尚未发展，虽可借其贫瘠而好掠夺的欲望，及因其进化之浅，社会组织简单，内部矛盾较少，因而以诚朴之气、勇敢之风而崛起于一时，然究不能据女真之地，用女真之人，以建立一个大国。所以从海陵迁都以后，他国家的生命，已经寄托在他所侵占的中国的土地上了。所以他压迫汉人较甚，而其了解汉人却亦较深。至蒙古，则所征服之地极广，中国不过是其一部分。虽然从元世祖以后，大帝国业已瓦解，所谓元朝者，其生命亦已寄托于中国，然自以为是一个极大的帝国，看了中国，不过是其所占据的地方的一部分的观念，始终未能改变。所以对于中国，并不能十分了解，试看元朝诸帝，多不通汉文及汉语可知。元朝诸帝，惟世祖较为聪明，所用的汉人和西域人较多，亦颇能厘定治法。此后则惟仁宗在位较久，政治亦较清明。其余诸帝，大抵荒淫愚昧。这个和其继嗣之争，亦颇有关系。 元朝可谓无一善政，所以仍能占据中国数十年，则因中国社会，自有其深根宁极之理，并非政治现象，所能彻底扰乱，所以他以异族入据中原，虽为人心所不服，亦不得不隐忍以待时。到顺帝时，政治既乱，而又时有水旱偏灾，草泽的英雄，就要乘机而起了。 1358年，刘福通分兵三道：一军入山、陕，一军入山东，自奉韩林儿复开封。虽终于无成，然继起的则业已养成气力。明太祖初起时，本来是附随郭子兴的。后来别为一军，渡江取集庆（今南京，元集庆路）。时徐寿辉为其将陈友谅所杀，陈友谅据江西、湖北，势颇强盛（寿辉将明玉珍据四川自立，传子昇，为明太祖所灭），后为太祖所灭。太祖又降方国珍、破张士诚，几乎全据了长江流域。 1370年，顺帝死，明兵再出，爱猷识理达腊亦奔和林。不久便死，子脱古思帖木儿嗣。1387年，太祖使蓝玉平辽东，乘胜袭破脱古思帖木儿于捕鱼海（今达里泊）。脱古思帖木儿北走，为其下所杀。其后五传皆被弑，蒙古大汗的统系遂绝。元宗室分封在内地的亦多降，惟梁王把匝剌瓦尔密据云南不服。1381年，亦为太祖所灭。中原之地，就无元人的遗孽了。自1279年元朝灭宋，至1368年顺帝北走，凡八十九年。 明（1368年~1644年，共276年）明太祖起于草泽，而能铲除胡元，戡定群雄，其才不可谓不雄。他虽然起于草泽，亦颇能了解政治，所定的学校、科举、赋役之法，皆为清代所沿袭，行之凡六百年。卫所之制，后来虽不能无弊，然推原其立法之始，亦确是一种很完整的制度，能不烦民力而造成多而且强的军队。所以明朝开国的规模，并不能算不弘远。只可惜他私心太重。废宰相，使朝无重臣，至后世，权遂入于阉宦之手。重任公侯伯的子孙，开军政腐败之端。他用刑本来严酷，又立锦衣卫，使司侦缉事务，至后世，东厂、西厂、内厂遂纷纷而起（东厂为成祖所设，西厂设于宪宗时，内厂设于武宗时，皆以内监领其事）。这都不能不归咎于诒谋之不臧。其封建诸子于各地，则直接引起了靖难之变。 太祖建都南京，对于北边的控制，是不甚便利的。成祖既篡建文帝，即移都北京。对于北方的控制，本可更形便利。确实，他亦曾屡次出征，打破鞑靼和瓦剌。但当他初起兵时，怕节制三卫的宁王权要袭其后，把他诱执，而将大宁都司，自今平泉县境迁徙到保定。成祖死后，子仁宗立，仅一年而死。子宣宗继之。明初的经略，还不仅对于北方。安南从五代时离中国独立，成祖于1406年，因其内乱，将其征服，于其地设立交趾布政使司，同于内地。他又遣中官郑和下南洋，前后凡七次。其事在1405至1433年之间，早于欧人的东航有好几十年。据近人的考究：郑和当日的航路，实自南海入印度洋，达波斯湾及红海，且拂非洲的东北岸，其所至亦可谓远了。 明朝取安南后，还是如此。其时中官奉使的多，横暴太甚，安南屡次背叛。宣宗立，即弃之。此事在1427年，安南重隶中国的版图，不过二十二年而已。自郑和下南洋之后，中国对于南方的航行，更为熟悉，华人移殖海外的渐多。近代的南洋，华人实成为其地的主要民族，其发端实在此时。然此亦是社会自然的发展，得政治的助力很小。 明代政治的败坏，实始于成祖时。其（一）为用刑的残酷，其（二）为宦官的专权，而两事亦互相依倚。太祖定制，内侍本不许读书。成祖反叛时，得内监为内应，始选官入内教习。又使在京营为监军，随诸将出镇。又设立东厂，使司侦缉之事。宦官之势骤盛。 宣宗崩，英宗立，年幼，宠太监王振。1449年，瓦剌酋长也先入寇。王振贸然怂恿英宗亲征。至大同，知兵势不敌，还师。为敌军追及于土木堡，英宗北狩。朝臣徐有贞等主张迁都。于谦力主守御。奉英宗之弟景帝监国，旋即位。也先入寇，谦任总兵石亨等力战御之。也先攻京城，不能克，后屡寇边，又不得利，乃奉英宗归。 大凡敌兵入寇，京城危急之时，迁都与否，要看情势而定，敌兵强，非坚守所能捍御，而中央政府，为一国政治的中心，失陷了，则全国的政治，一时要陷于混乱，则宜退守一可据的据点，徐图整顿。在这情势之下，误执古代国君死社稷之义，不肯迁都，是要误事的，崇祯的已事，是其殷鉴。 徐有贞因此内惭，石亨又以赏薄怨望，遂结内监曹吉祥等，乘景帝卧病，闯入宫中，迎英宗复辟，是为“夺门”之变。于谦被杀。英宗复辟后，亦无善政。传子宪宗，宠太监汪直。宪宗传孝宗，政治较称清明。孝宗传武宗，又宠太监刘瑾，这不能不说是成祖恶政的流毒了。明自中叶以后，又出了三个昏君。其（一）是武宗的荒淫。其（二）是世宗的昏愦。其（三）是神宗的怠荒。明事遂陷于不可收拾之局。 武宗无子，世宗以外藩入继。驭宦官颇严，内监的不敢恣肆，是无过于世宗时的。但其性质严而不明，中年又好神仙，日事斋醮，不问政事。严嵩因之，故激其怒，以入人罪，而窃握大权，政事遂至大坏。其时倭寇大起，沿海七省，无一不被其患，甚至沿江深入，直抵南京。 世宗时，曾三次入犯京畿。有一次，京城外火光烛天，严嵩竟骗世宗，说是民家失火，其蒙蔽，亦可谓骇人听闻了。世宗崩，穆宗立，未久而死。神宗立，年幼，张居正为相。此为明朝中兴的一个好机会。当穆宗时，高拱为相，任李成梁守辽东，戚继光守蓟镇以敌之。成梁善战，继光善守，张居正相神宗，益推心任用此二人，东北边亦获安静。明朝政治，久苦因循。张居正则能行严肃的官僚政治。下一纸书，万里之外，无敢不奉行惟谨者，所以吏治大有起色。百孔千疮的财政，整理后亦见充实。惜乎居正为相不过十年，死后神宗亲政，又复昏乱。他不视朝至于二十余年。群臣都结党相攻。其时无锡顾宪成，居东林书院讲学，喜欢议论时政，于是朝廷上的私党，和民间的清议，渐至纠结而不可分。 神宗信任中官，使其到各省去开矿，名为开矿，实则借此索诈。又在穷乡僻壤，设立税使，骚扰无所不至。日本丰臣秀吉犯朝鲜，明朝发大兵数十万以援之，相持凡七年，并不能却敌，到秀吉死，日本兵才自退。神宗死后，熹宗继之。信任宦官魏忠贤，其专横又为前此所未有。统计明朝之事，自武宗以后，即已大坏，而其中世宗、神宗，均在位甚久。武宗即位，在1506年，熹宗之死，在1627年，此一百二十二年之中，内忧外患，迭起交乘，明事已成不可收拾之局。思宗立，虽有志于振作，而已无能为力了。 清（1644年~1912年，共269年）清朝真正的祖先，所谓肇祖都督孟特穆，就是1412年受职为建州卫指挥使的猛哥帖木儿（明人所授指挥使，清人则称为都督。孟特穆为孟哥帖木儿异译），其初曾入贡受职于朝鲜的李朝的。后为七姓野人所杀。其时的建州卫还在朝鲜会宁府河谷。其弟凡察立，后猛哥帖木儿之子董山，出而与凡察争袭。明朝乃分建州为左右两卫，以董山为左卫指挥使，凡察为右卫指挥使。董山渐跋扈，明朝檄致广宁诛之。部下拥其子脱罗扰边（《清实录》作妥罗，为肇祖之孙。其弟曰锡宝斋篇古。锡宝斋篇古之子曰兴祖都督福满，即景祖之父），声称报仇，但未久即寂然。自此左卫衰而右卫盛。右卫酋长王杲，居宽甸附近。为李成梁所破，奔扈伦部的哈达（叶赫在吉林西南，明人称为北关。哈达在开原北，明人称为南关）。哈达执送成梁，成梁杀之。其子阿台，助叶赫攻哈达。满洲苏克苏浒部长尼堪外兰，为李成梁做乡导，攻杀阿台。满洲酋长叫场，即清朝所谓景祖觉昌安，其子他失，则清朝所谓显祖塔克世，塔克世的儿子弩尔哈赤，就是清朝的太祖了。 满洲人得以沐浴中国的文化，且借互市以润泽其经济，其势渐强。先服满洲诸部。扈伦、长白山诸部联合蒙古的科尔沁部来攻，清太祖败之，威声且达蒙古东部。又合叶赫灭哈达。至1616年，遂叛明。清当太祖时，尚无意于入据中原，专发挥其仇视汉人的观念，得儒士辄杀。得平民则给满洲人为奴。太宗始变计抚用汉人，尤其优待一班降将。洪承畴等遂不恤背弃祖国，为之效力。于是政治军事的形势，又渐变了。但明兵坚守了山海关，清兵还无力攻陷。不过明朝剿流寇的兵，时被其牵制而已。1643年，李自成陷西安。明年，在其地称帝。东陷太原，分兵出真定（今河北正定县），自陷大同、宣府，入居庸关。北京不守，思宗殉国于煤山。山海关守将吴三挂入援，至丰润，京城已陷。自成招三桂降，三桂业经允许了。旋闻爱妾陈沅被掠，大怒，遂走关外降清。“痛哭六军皆缟素，冲冠一怒为红颜”，民族战争时惟一重要的据点，竟因此兵不血刃而失陷，武人不知礼义的危险，真令人言之而色变了。 时清太宗已死，子世祖继立，年幼，叔父睿亲王多尔兖摄政，正在关外略地，闻三桂来降，大喜，疾趋受之。李自成战败，奔回陕西，清人遂移都北京。时在1645年。清朝既定江南，乃下令强迫人民剃发。当时有“留头不留发，留发不留头”之谚，其执行的严厉可想。此举是所以摧挫中国的民气的，其用意极为深刻酷毒。清人遣吴三桂陷四川，张献忠败死。别一军下江南，鲁王败走舟山。清兵遂入福建，隆武帝亦殉国。 汉族在大陆上虽已无根据地，然天南片土，还有保存着上国的衣冠的，是为郑成功。郑成功为郑芝龙的儿子。芝龙本系海盗，受明招安的。清兵入闽时，芝龙阴行通款，以致隆武帝败亡。成功却不肯叛国，退据厦门，练兵造船为兴复之计。清兵入滇时。成功曾大举入江，直迫江宁。后从荷兰人之手，夺取台湾，务农，训兵，定法律，设学校，俨然独立国的规模。清朝平定西南，本来全靠降将之力，所以事定之后，清朝并不能直接统治。乃封尚可喜于广东，耿仲明之子继茂于福建，吴三桂于云南，是为三藩。三藩中，吴三桂功最高，兵亦最强。1673年，尚可喜因年老，将兵事交给其儿子之信，反为所制，请求撤藩，清人许之。三桂和耿继茂的儿子耿精忠不自安，亦请撤藩，以觇朝意。时清世祖已死，子圣祖在位，年少气盛，独断许之，三桂遂叛清。耿、尚两藩亦相继举兵。清朝在西南，本无实力，三桂一举兵，而贵州、湖南、四川、广西俱下。但三桂暮气不振，既不能弃滇北上；想自出应援陕西响应的兵，又不及；徒据湖南，和清兵相持；耿、尚两藩，本来是反覆无常的，此时苦三桂征饷，又叛降清；三桂兵势遂日蹙。1678年，三桂称帝于衡州。旋死，诸将乖离，其孙世璠，遂于1681年为清人所灭。清平定西南，已经出于意外了，如何再有余力，觊觎东南海外之地？所以清朝是时，已有和郑氏言和，听其不剃发，不易衣冠之意。但又有降将作祟。先是郑成功以1662年卒，子经袭，初和耿氏相攻，曾略得漳、泉之地。后并失厦门，退归台湾。其将施琅降清，清人用为提督。1681年，郑经卒，内部乖离。1683年，施琅渡海入台湾，郑氏亡。 清圣祖的为人，颇为聪明，也颇能勤于政治；就世宗也还精明。他们是一个新兴的野蛮民族，其骄奢淫佚，比之历年已久的皇室，自然要好些。一切弊政，以明末为鉴，自然也有相当的改良。所以康、雍之世，政治还算清明，财政亦颇有余蓄。到乾隆时，虽然政治业已腐败，社会的元气，亦已暗中凋耗了，然表面上却还维持着一个盛况。 清朝的衰机，可说是起于乾隆之世的。高宗性本奢侈，在位时六次南巡，耗费无艺。中岁后又任用和珅，贪渎为古今所无。官吏都不得不剥民以奉之，上司诛求于下属，下属虐取于人民，于是吏治大坏。清朝历代的皇帝，都是颇能自握魁柄，不肯授权于臣下的。他以异族入主中原，汉族真有大志的人，本来未必帮他的忙。加以他们予智自雄，折辱大臣，摧挫言路，抑压士气，自然愈形孤立了。所以到乾、嘉之间，而局面遂一变。 一个民族，进步到达于某一程度之后，就决不会自忘其为一个独立的民族了。虽然进化的路径，是曲线的，有时不免暂为他族所压服。清朝最大的会党，在北为哥老会，在南为天地会，其传说大致相同。天地会亦称三合会，有人说就是三点会，南方的清水、匕首、双刀等会，皆其支派。据他们的传说：福建莆田县九连山中有少林寺十八个和尚，且战且走，十三个战死了。剩下来的五个，就是所谓前五祖。又得五勇士和后五祖为辅，矢志反㳉复汨，㳉就是清字，汨就是明字，乃会中所用的秘密符号。他们自称为洪家。把洪字拆开来则是三八二十一，他们亦即用为符号。洪字大约是用的明太祖开国的年号洪武；或者洪与红同音，红与朱同色，寓的明朝国姓的意思，亦未可知。据他们的传说：他们会的成立，在1674年。 鸦片战争既起，三合会党尚有和海峡殖民地的政府接洽，图谋颠覆清朝的。”其反清复明之志，可谓终始不渝了。而北方的白莲教徒的反清，起于1793年，即乾隆五十八年，蔓延四川、湖北、河南、陕西四省，至1804年，即仁宗嘉庆九年而后平定，此即向来的史家称为川、楚教匪，为清朝最大的内乱之始的，其所奉的王发生，亦诈称明朝后裔，可见北方的会党，反清复明之志，亦未尝变。后来到1813年，即嘉庆十八年，又有天理教首林清，图谋在京城中举事，至于内监亦为其内应，可见其势力之大。天理教亦白莲教的支派余裔，又可见反清复明之志，各党各派，殊途同归了。而其明目张胆，首传讨胡之檄的则为太平天国。 清朝的衰机，是潜伏于高宗，暴露于仁宗，而大溃于宣宗、文宗之世的。当是时，外有五口通商和咸丰戊午、庚申之役，内则有太平天国和捻、回的反抗，几于不可收拾了。其所以能奠定海宇，号称中兴，全是一班汉人，即所谓中兴诸将，替他效力的。一切内政、外交的大任，多是湘、淮军中人物，以疆臣的资格决策或身当其冲。军机及内阁中，汉人的势力亦渐扩张。所以在这个时候，满洲的政权，在实际上已经覆亡了，只因汉人一方面，一时未有便利把他推倒，所以名义又维持了好几十年。 1911年10月10日，即旧历辛亥八月十九日，革命军起事于武昌。清朝本无与立，在无事时，亲贵虽欲专权，至危急时，仍不得不起用袁世凯。袁世凯亦非有诚意扶持清朝的，清人力尽势穷，遂不得不于其明年即中华民国元年二月十二日退位。沦陷了268年的中华，至此光复；且将数千年来的君主专制政体，一举而加以颠覆。 中华民国这部分可参看《蒋介石与现代中国》一书，更为详细。 中华人名共和国这部分可参看《毛泽东传》、《邓小平时代》两本书，更为详细。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"中国通史","slug":"中国通史","permalink":"https://lchml.com/tags/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2/"}]},{"title":"《邓小平时代》","slug":"dxpsd","date":"2021-08-04T16:00:00.000Z","updated":"2022-05-24T06:26:57.980Z","comments":true,"path":"book/dxpsd/","link":"","permalink":"https://lchml.com/book/dxpsd/","excerpt":"挽狂澜于既倒，扶大厦之将倾！他引导中国完成了从落后、封闭、僵化的社会主义制度走向一个有国际影响的现代化经济强国的艰难过渡。精神和肉体都留给了这个让他奋斗一生，贡献一生的国家。邓公千古！","text":"挽狂澜于既倒，扶大厦之将倾！他引导中国完成了从落后、封闭、僵化的社会主义制度走向一个有国际影响的现代化经济强国的艰难过渡。精神和肉体都留给了这个让他奋斗一生，贡献一生的国家。邓公千古！ 1904年出生于四川广安牌坊村，法国留学，回国加入共产党，参加过地下工作，养成了所有东西都记在脑子里不留文字记录的习惯。负责过组织西南起义以及创建西南根据地，最终失败（因此对毛能成功在江西创建根据地非常佩服）。期间作为毛派头子被打倒（第一落，由此获得了毛长期的认同）。长征期间负责宣传工作，之后作为政委搭配刘伯承司令组成刘邓大军。 建国初期领导西南局，待地方稳定后，调回中央，跟随毛和周工作。文化大革命期间，被指控资本主义思想，下放江西，儿子被红卫兵斗成全身瘫痪（第二落）。在此期间，邓深刻思考了中国未来和政策。 文革末期，毛重新启用邓，但由于邓坚决不肯遵从毛希望对文革的肯定（毛非常在意自己身后的评价，担心变成斯大林，而邓是赫鲁晓夫）同时加上江青为首的激进派疯狂咬人，最终被除权居家（第三落）。毛最终选择了坚决拥护他线路的华国锋。但毛最后也没有把邓彻底打倒，应该是因为他心里也清楚邓是当下情况下最有能力，最能解决问题的人。 毛去世后，华国锋解决了四人帮问题，但由于文革中的大部分老干部对华国锋的两个凡是不满意，通过叶剑英等核心元老的运作，邓开始复出掌握大局，在十一届三中全会上启用陈云，李先念，胡耀邦，赵紫阳等一批新人，原先支持华国锋的汪东兴等政治局常委被边缘化。在没有出现大范围政治斗争的情况下，顺利完成权力过渡。同时客观评价了大跃进和文革的错误，同时维护了毛泽东思想的地位。逐步淡化毛时代的阶级斗争，转为以经济建设为中心。 邓的首要目标是为中国实现四个现代化，同时基于苏联的压力。实现中美关系正常化，签订中日友好条约。自己频繁出国访问，同时派出大量官员出国考察，让全国逐步意识到中国落后的现状，并积极学习国外的科学技术。79年决定攻打越南，并在取得胜利后迅速撤出。由此解决了越南意图依附苏联称霸东南亚，并协助苏联围困中国的战略问题。 改革开放中，广东福建试点，陈云李先念习仲勋谷牧万里等一批人，通过宣传试点取得的成果逐步改变全国人民的思想。现在看来很多理所当然的事情，在当时是大胆突破，需要极大的魄力和能力。自古改革之路改革之人都曲折艰辛。同时纵观中国历史上的改革成败，改革者掌握最高权力是至关重要的。 解决台湾、香港、西藏问题。敌人处处埋坑，邓公步步为营。蒋经国、撒切尔、达赖。 解决军队问题，从610w裁军到320w。培养大批年轻新人，为之后的军队现代化打下基础。同时判断当时形势，认为短时间不可能出现大规模战争，尽可能缩减军费开支，把资源用于发展民用经济。 对胡耀邦处理学生运动的“软弱”表现不满意将其撤职，在之后89年胡的去世，成了64的导火索。同样赵紫阳由于在64中的表现过于亲近学生而被撤职。这一章我特地对比了港版和内地版。确实有一些删减，但是纵观全局，从我当前对世界的认知来说，我依然觉得邓的决定是没有问题的。当然胡和赵的做法也没有问题，但是当国家面临这样的问题时，需要有人站出来对国家负责，就算背负骂名。 江由于在之前学运中的良好表现，被指定为第三代领导核心，之后几个月邓为了开启领导人退休制度，主动退休，退出政治局。（这也是中国几千年来的第一次）。 最后的南巡，在89至92年之间，保守派的计划经济逐渐占据上风，邓为了加速经济发展，扩大改革开放，在92年以87岁的高龄，开始了南巡，为后续的加速发展点燃了星星之火。这也是邓最后一次为了中国政治奔波，在之后的十四大上，江坚定了邓的开放路线，正式接过所有权柄，中国进入了第三代领导核心时代。 邓于1997年2月19日午夜后去世，享年92岁。按照邓小平的遗愿，他的眼角膜被捐出供眼科研究，脏被捐出供医学研究，遗体被火化，骨灰盒上覆盖着中国共产党党旗。1997年3月2日，他的骨灰被撒入大海。在看到此段之前，对邓公一直是敬佩，但阅读至此竟突然泪目，最后的最后还在用自己的肉体为中国的进步作出最后一次努力。","categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"传记","slug":"传记","permalink":"https://lchml.com/tags/%E4%BC%A0%E8%AE%B0/"}]},{"title":"网易互客敏捷交付实践","slug":"scrum","date":"2021-02-06T16:00:00.000Z","updated":"2022-05-12T05:58:11.435Z","comments":true,"path":"technology/scrum/","link":"","permalink":"https://lchml.com/technology/scrum/","excerpt":"敏捷开发的一个重要目标是建立持续价值交付的能力。这种能力最终必须服务于业务的创新，促进业务的成功。","text":"敏捷开发的一个重要目标是建立持续价值交付的能力。这种能力最终必须服务于业务的创新，促进业务的成功。 不知道大家最近有没有关注新闻，阿里开始拆中台了，张勇对目前阿里的中台并不满意，他直言，现在阿里的业务发展太慢，要把中台变薄，要变得敏捷和快速。很显然，敏捷对业务有着非常高的价值。 面临的问题在过去的开发中，我们面临很多问题，如： 临时调整需求，牵一发而动全身。大家应该经常碰到离版本上线没几天了，产品说有个很重要的需求必须得加急上，不上不行。这种临时的需求调整，对版本的交付影响是很大的。 因为一个不重要的需求，延期整个版本的上线。上线当天，可能发现有一个不是很重要的点有问题，这个时候，整个版本都必须等这个问题解决，有时候直接回导致版本的延期，或者产生很多临时方案。 整个团队上线发布到凌晨。由于一个版本交付的内容太多了，准备工作很长，影响的范围也很大，通常会安排在晚上做发布，而发布过程中只要遇到一两个问题，通常发布就会搞到凌晨甚至后半夜。 有checklist依然不能避免遗漏。同样也是当版本越大，内容越多时，就越容易遗漏。 不同价值的需求，相互影响。一个版本中通常会包含各种优先级的需求，而不同优先级的需求同时开发交付，就一定会存在相互影响的问题。 需求相互耦合，上线交叉感染。这是指什么呢？一个版本上线出现问题时，由于上线的内容很多，定位问题就会变得更困难，不能确定是哪个需求的变更引起的问题。我们就出现过相互认为是对方的需求有问题，而浪费了很长时间。 产研团队交付效率上不去。所有问题最后都导致了交付效率上不去，交付质量上不去。相信大家也有碰到过和我们类似的这些问题。这其中有很多问题，都是可以通过敏捷交付来解决或减轻。 敏捷VS瀑布那什么是敏捷呢？关于敏捷模式和瀑布模式的理论知识，相信大家都已经有些了解，这里就不细说其中的理论知识了。我们把敏捷和瀑布的区别简单理解为，瀑布是按版本交付的，敏捷是按需求交付的。瀑布模式中版本的需求、时间、资源是确定的，三个因素相互制约。最大的优势在于可预测性，流程简单，有固定的时间点。但同时带来的问题是缺乏灵活性，进入版本后，调整需求或时间的代价会非常大，并且版本越大时带来的风险和不确定性越大。大多数研发团队采用的都是瀑布模型。敏捷模式中需求变成了变量，在固定时间和资源的情况下，灵活调整需求，从而获得最大交付加值。如图所示，瀑布模式中整个团队按步骤一步步执行，最终全量交付。而在敏捷模式中，在固定的时间内（迭代周期）将一个版本拆分为一个个可以独立交付上线的需求，优先交付高优先级（高价值）的需求，并由一个个独立的小团队负责交付。最大的优势是非常灵活，可以根据实际情况随时调整需求，同时由于交付单元限定在最小范围内，使得上线发布的影响范围最小，风险可控，也可以提高交付质量。目标是在尽可能短的时间内交付尽可能高的价值。 先试点再推广进行敏捷交付的转型前，我们进行了很多调研和沟通工作，学习公司内部外部已经实现敏捷交付的团队的经验。然后制定了初步的方案，并在小范围内进行试点，试点过程中不断调整方案，调试工具，当试点方案执行顺利以后再推广到整个团队。互客刚开始的时候，就是选择其中一些比较小的简单的需求来进行试点的。在转型的过程中，我们总结出四个重要的要素，分别是：环境、流程、工具、人。 需要准备什么系统架构首先想要进行敏捷交付，需要有能适应敏捷模型的研发环境，包括系统的合理拆分、边界清晰的业务、可以进行独立开发测试的环境隔离能力。要有平滑发布的能力，任何时间发布任何服务不应该因为发布动作本身引起问题。还需要有完善的监控可以实时反馈系统的异常，特别在实践初期总会有意外情况，研发应该能第一时间获知系统发生异常。如果研发环境本身还是非常耦合，牵一发而动全身的情况，需求的负责人都不知道影响范围在哪里。那就很去难实现敏捷的交付方式。如果没有准确的异常监控能力，会有很大的风险。因此合理的架构是敏捷的基础 流程规范然后是流程规范。从需求拆分、时间规划、代码分支管理、技术方案评审、测试报告、发布审核、自动化回归。团队中的每个人必须严格按照流程进行，因为越灵活的方案，背后意味着更多的不可控。所以在转型初期，严格执行流程是非常必要的。敏捷交付的前提是需求必须是合理拆分的，而我们对合理的定义就是，可以独立交付上线的称为一个需求。如果两个需求之间是相互耦合的，少了其中一个，另一个需求都不能独立交付。那么这样的需求就是不合理的，应该合并为一个需求。这个是互客上一个版本的需求列表，以及分工，时间规划等等。可以看到大部分是正常需求，黄色部分是比较大的不跟版本的需求，红色和划线的是延期或取消的需求。需求的交付变成了一个灵活的过程。 这个是我们的需求分支管理，非常简单，大家都能看懂。其中比较重要的是一定要经常从master合最新代码到自己的feature分支。 实施工具工具是流程的承载，没有合适的工具是很难把流程执行起来的。网易内部的ovemrind效能平台可以很好的支持我们的流程，配合飞书文档，TC平台和gotest平台，基本上可以比较好的支持整个流程了。下面的截图是某一天下午的发布单，可以看到一下午就有多次发布。 团队组织最后我们需要根据敏捷交付的逻辑去适当的调整团队的组织形式，原先的团队组织形式，边界在于职能，所有的需求在不同的职能间流转，最后由版本负责人负责交付上线。这种模式下，各职能团队的人只能接触到自己工作范围内的东西，所以对需求的理解程度高低不等，当产生需求变更时，也更容易产生抵触情绪，当出现调整或返工时也会付出很大的代价。右边是为了适应敏捷交付调整的组织形式，每个需求都会有一个临时的虚拟小组来负责，需求只在这个小组内部流转，最后由需求负责人交付上线。在这种模式下，团队组织的边界不再是职能，而在于需求。虚拟小组的成员需要关心一个需求的全生命周期，能更好的理解需求。当有需求变更时，影响范围也相对小得多。并且通常会在方案设计过程中研发和产品一起讨论调整需求。不管是环境、流程还是工具，最后一定都是需要人去执行的，也就是团队中的每个成员。因此团队成员的思维转变是敏捷转型中的重点，在工作进行前，首先应该在团队内进行足够的沟通，让每个人理解转型的价值和意义，让每个人都愿意为之努力。当团队达成一致的目标时，离成功就已经不远了。 得到了什么这是互客过去几个版本的需求吞吐量，缺陷密度（七八月份由于需求统计问题，需要除以二），不管质量还是吞吐量都是有比较明显的提升的。 当然，我觉得更重要的是，我们得到了持续快速的交付价值的能力，得到了沟通顺畅，相互信任的团队。另外从我个人做需求感觉来说，在敏捷模式下，我对需求的理解会更好，工作会变的更聚焦，会自然而然的关注需求从评审到上线的整个过程，会及时的关注自己的需求的情况等等。比如今天就有一单，是因为我们上了一个数据看板的需求，客户的下单直观的反馈到了这个需求的负责团队，这可以让产研统一目标，相互促进，产生良性循环。 经验总结在网易互客实践敏捷交付的过程中我们踩了许多坑，这里列举一些比较典型的例子，希望可以帮助大家少走一点点弯路。 不要过分追求模式，我们的目标是质量和效率，而不是模式 沟通，充分的沟通，要达成理解一致 转型初期流程要严格执行 需求一定要有负责人 需求交付尽量不要搭车，容易搭到黑车 对质量负责的不是QA，是每个需求的小组 系统实时反馈很重要最后期望所有的研发团队都能让有限的资源产生最大的价值。 未来规划","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"LC","slug":"LC","permalink":"https://lchml.com/tags/LC/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"团队协作的五大障碍","slug":"team-manager","date":"2020-11-11T16:00:00.000Z","updated":"2022-05-12T05:57:20.263Z","comments":true,"path":"technology/team-manager/","link":"","permalink":"https://lchml.com/technology/team-manager/","excerpt":"如果你能让一个组织中的所有成员齐心协力，你就可以在任何时候、任何市场状况下、任何行业中纵横驰骋，战胜挑战。","text":"如果你能让一个组织中的所有成员齐心协力，你就可以在任何时候、任何市场状况下、任何行业中纵横驰骋，战胜挑战。 在《系统架构》一书中作者提出：系统的功效必须大于各自元素的功效之和。而任何一个团队都可以视为一个系统，对于大多数管理者来说，让团队相互协作发挥出一加一大于二的力量是其最重要的工作。团队协作之所以不能良好的实现，是因为总是不自觉的陷入了五个很普通但却很危险的沼泽之中。我们这里称其为团队协作的五大障碍。他们并不是相互独立，而是共同作用，互为因果的。 团队协作的第一大障碍是团队成员之间缺乏信任。因为缺乏信任，团队就无法产生直接而激烈的思想交锋，不敢发表自己的意见，也就产生了第二大障碍——惧怕冲突。因为惧怕冲突，缺乏必要的争论，也就不能真正统一意见，从而导致团队成员缺乏投入。因为缺乏投入，又没有真正达成共识，当出现不好的结果时，团队成员就会逃避责任，甚至相互抱怨。最终会使团队成员把个人利益放在团队的共同利益之上，也就导致了团队无视结果。 与此相反的，当我们从积极的角度去思考时，一个真正团结一致的团队应该是下图这样的，看起来简单，在实际中要做到却是很难的，需要高度的组织纪律性和持久性。 那么我们该如何克服这五大障碍呢？ 缺乏信任信任是高效、团结一致的团队的核心，没有信任，团队协作就无从谈起。在这里信任是指团队成员之间相信同事的言行是出于好意，在团队里不必过分小心或互相戒备，成员之间可以放心的接受彼此的批评。充满信任的团队成员具有以下表现： 承认自己的弱点和错误 主动寻求别人的帮助 欢迎别人对自己所负责的领域提出问题和给予关注 在工作可能出现问题时，相互提醒 愿意给别人提出反馈意见和帮助 赞赏并且学习别人的技术经验 把时间和精力花在解决实际问题上，而不是流于形式 必要时向别人道歉，接受别人的道歉 珍惜集体会议或其他可以进行团队协作的机会 克服缺乏信任障碍可以通过以下方法（不限于）： 个人背景介绍，彼此了解 成员工作效率讨论 个性及行为特点测试 360度意见反馈 集体外出实践 作为团队领导需要率先承认自己的不足，勇于在下属面前抛开面子问题。团队领导必须保证大家承认弱点后不会因此而受到不利影响。 惧怕冲突良好而持久的合作关系，需要积极的冲突和争论来促使其前进。我们需要降积极的争论和消极的争吵或个人矛盾区分开。争论的唯一目的是在最短的时间内找到最佳的解决方案。拥抱冲突的团队具有以下特点： 召开活跃、有趣的会议 汲取所有团队成员的意见 快速的解决实际问题 将形式主义控制在最小限度 把大家持不同意见的问题拿出来讨论 克服惧怕冲突障碍的方法可以有： 挖掘争论话题，有意的挖掘一些隐藏的分歧摆到桌面上 实时提醒，成员相互监督，不要放弃有益的辩论话题 团队领导在发生争论时，不应该试图去维护成员之间的平衡，怕他们受到伤害。应该冷静审视、顺其发展，即使有些混乱也不要随意打断。同时领导也要以身作则，参与争论。 缺乏投入优秀的团队可以在很短的时间内达成明确的共识，大家都按照最终决定进行工作，即使先前反对这项决定的人也是如此。而缺乏投入的两个重要原因通常是追求绝对一致和追求绝对把握，全力投入的团队具有以下表现： 制定出明确的工作方向和重点 公平听取全体成员的意见 培养从失误中学习的能力 毫不犹豫，勇往直前 必要时果断调整方向 克服缺乏投入障碍的方法有： 统一口径 设置最终期限（deadline） 风险预估 低风险激进法 团队领导应该比其他成员更能接受可能做出错误决策的事实，不应该把过多注意力放在追求绝对一致和绝对把握上。 逃避责任当涉及到工作质量和绩效时，逃避责任就会变得非常敏感。而当团队成员由于逃避责任而导致整体效益下降时，他们就会真的相互怪罪。要保持团队高效率地工作，最有效的方法就是同事间相互施加压力。负责任的团队会具有以下表现： 确保让表现不尽如人意的成员感到压力，使其尽快改进工作 发现潜在问题时毫无顾虑的向同事指出 尊重团队中以高标准要求工作的同事 免除绩效管理以及改进计划这类过度形式主义的措施 克服这一障碍的方法有： 公布工作目标和标准 定期对成果进行简要回顾 团队嘉奖 团队领导应该避免使自己成为团队的唯一负责人，为团队建立整体的负责机制，要求大家共同承担责任。 无视结果如果团队成员倾向于关注集体工作目标以外的事情，往往会带来巨大的危害。尽管人人都有自我意识，但一直优秀的队伍，成员必须把集体利益放在个人利益之上。重视集体成绩的团队应该有以下表现： 有得力的员工加入 不提倡注重个人表现 正确对待成功和失败 团队成员能够为团体利益牺牲个人利益 凝聚力强，不会轻易解体 要客服这一障碍，可以通过公布工作目标和奖励团队成就的办法实现。公布自己的工作目标，向公众承诺要获取成功的团队会具有更高的工作热情，更渴望取得结果。而仅仅声称“我们会尽力而为”的团队则无意识、微妙的为自己的失败做好了准备。激励团队成员追求集体利益的另一个有效方法就是将他们的奖励，尤其是奖金，与团队的工作成绩联系在一起。而不是仅仅让员工以“努力工作”的名义取得奖励，这等于传递了一种是否取得成果也无关紧要的信息。 对于这种障碍，团队领导首先要自己走出自我主义的误区，培养客观的态度，奖励那些真正为集体利益作出贡献的成员。 团队是由人组成，每个人都是不完美的，最终需要团队成员克服人性的弱点，建立信任，充分表达，全力投入，重视集体，从而取得成功。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"绩效沟通之PRO&GROW模型实践","slug":"pro-grow","date":"2020-11-02T16:00:00.000Z","updated":"2022-05-12T06:09:00.001Z","comments":true,"path":"technology/pro-grow/","link":"","permalink":"https://lchml.com/technology/pro-grow/","excerpt":"关于绩效沟通","text":"关于绩效沟通 暖场开场后，先简单聊一些非工作的内容，如最近的一些热门话题，或对方关注的话题，缓和气氛利于后续的沟通。这里不能太刻意，应尽量挑一些平时大家有聊过的话题。 呈现（P）暖场后可以做出一些开放性提问，如：过去一个季度觉得怎么样？自己有哪些满意或不满意的地方？引导员工去回忆思考，尝试总结过去一个季度的工作。部分员工可能会忘了过去自己做了些什么，可以适当做一些提醒，如xxx技术优化的工作就做的很不错，或xxx需求比较难，最后按时上线了。这就要求管理者沟通前需要做好充分的准备，不能自己都不知道员工做了一些什么。在这个阶段尽量先不要去讨论工作结果的好坏，更多的是引导员工主动去回忆思考。当回忆的内容差不多了，最后再告知绩效结果。 回应及现状（R）告知绩效结果后，大多数员工会有一些情绪上的沮丧甚至愤怒。这时管理者需要倾听、理解下属的情绪，对他的表达表示认同，不要让事实本身影响到相互关系。并帮助员工认识到目前绩效表现中存在的具体问题或状况。如负责的某个需求上线后，线上反馈bug超过了正常水平，或导致了系统多长时间的不可用，而正常的水平应该是怎么样的。表达你对他的期望并鼓励他去思考改进的方法的，如：我觉得你完全可以做的更好的，或上次的某个需求上线后效果就很好，你觉得这次没做好的问题是出在了哪里呢？促使员工去思考和表达，并在站在员工的角度和他一起探讨原因和改进方法，从而获得更多的信息，追求相互理解的状态。 在这个阶段，员工很可能会产生各种负面情绪，如找借口、防御姿态、反击、消极怠工等等，而作为管理者最重要的是不能情绪化，可以反复的尝试沟通，或者冷静一段时间后再继续沟通，如果员工不能充分接纳问题并承担责任，那后续的阶段是走不下去的。 责任感（O）当管理者察觉到员工已经有了承担解决问题的责任感和意愿度时，接下来就可以进行实际的管理动作。如制定下一个季度的改进计划等。接下来就是可以进入GROW模型了。 在进行PRO流程中，最重要也是最难的是处理员工的情绪并让员工有责任感。在到达O之前，可能需要反复多次的PR。要记住PRO是用来转移责任感和处理问题意愿的，而非用于解决问题。 设定目标（G）设定目标我认为是GROW模型中非常重要的一步，因为一个合适的目标才能让后面的工作更加顺利的进行，而现实中大部分员工的目标通常是太高或者太低，过高的目标定，几乎不可能做到，这时目标就成了摆设，失去了引导力，过低的目标太容易做到，员工容易自我满足，原地踏步。在设定目标这个过程中，管理者可以参考OKR的思想，将目标设定为有挑战的且可实现的。例如服务可用性达到100%，或线上bug数小于多少等。在制定目标的过程中，管理者应该通过不停的提问去引导员工自己制定一个合适的目标，因为自己定的目标会更有完成动力。如：你希望接下里的Q4做一些什么，在过程中你希望得到怎么样的帮助，你觉得这个目标对你的难度有多大，等等。 分析现状（R）确定目标后，接下来需要分析当前的现状或问题。当前的情况是怎么样的，如上个季度的质量情况、服务可用率、性能等指标，并分析这些情况带来了什么影响。如性能不好带来的成本和隐患是什么。接着分析现状和目标之间的差距是什么，如服务可用率当前是99.9%，下个Q要做到100%，如当前线上缺陷密度是0.5，下个Q我们需要达到0.4等。询问员工自己怎么看到这些差距，怎么理解目标的设定，怎么看目标的可行性。在这个过程中，管理者需要通过大量的开放式提问，与员工再次确认对目标的理解一致，如果发现理解有不一致的情况，可以退回到第一步，重新讨论目标。 选择方案（O）确定了目标，分析完现状，接着就是寻找解决方案了。在这一步，管理者不应该急着过早评价判断方案的好坏，而应该尽可能找出各种可能的解决方案。同时解决方案应尽可能由员工自己提出，管理者可以设定一些条件或前提，比如在保证质量的情况下，你觉得怎么才能提高交付效率。在这个阶段，管理者很容易会反客为主，没有去探寻员工的想法观点，反而在输出自己的想法，变成了告知。并不是说主动告知就一定不好，但我们这里讨论的目标主要是绩效比较好的员工，这种员工更适合于探寻挖掘为主，可以充分调动主动性。适当的沉默也可以在这个阶段发挥作用，当员工陷入思考时，不要急于去帮助他或给出自己的方案。 行动意愿（W）最后一步，确定行动意愿，确保员工对上一个阶段的方案有初步的行动计划，并且对计划充满信心。在这一步中，管理者需要表现出对即将采取的行动表示支持并积极参与其中。 实践心得：在实际的应用过程中，有很多意料之外的情况需要灵活应用grow模型，在谈话的任何一个阶段都可能会跳跃到另一个阶段，并不一定是按顺序进行的。但有一个原则是确定的，要充分的沟通，积极的倾听，适时的回应。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"网易互客Mac版","slug":"pyqt","date":"2020-09-08T16:00:00.000Z","updated":"2022-05-24T06:00:45.354Z","comments":true,"path":"technology/pyqt/","link":"","permalink":"https://lchml.com/technology/pyqt/","excerpt":"网易互客Mac版：下载地址","text":"网易互客Mac版：下载地址 现在越来越多的服务都只在web端提供，很少有人去开发原生的桌面应用。但桌面应用依然有它的便捷性，有什么办法把web服务封装成桌面应用呢？ 以网易互客的SaaS服务为例，在浏览器中使用，通常会被其他tab干扰，或者容易误关。如果可以把它变成一个桌面应用就会方便许多。Python的UI框架有很多，Tkinter是最轻量级的，但它不支持WebEngine，所以我们选择PyQt来实现。首先通过homebrew安装PyQt： 1$brew install pyqt 然后通过简单的代码封装一个web页 12345678910111213141516171819202122232425#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;Created by lc on 2020/09/08.&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QApplication, QMainWindowfrom PyQt5.QtWebEngineWidgets import QWebEngineViewfrom PyQt5.QtCore import QUrl, Qtfrom PyQt5.QtGui import QIconif __name__ == &#x27;__main__&#x27;: QApplication.setAttribute(Qt.AA_EnableHighDpiScaling) # Qt从5.6.0开始，支持High-DPI app = QApplication(sys.argv) w = QMainWindow() w.browser = QWebEngineView() w.browser.setUrl(QUrl(&quot;https://huke.163.com/login/&quot;)) w.setCentralWidget(w.browser) w.setGeometry(100, 100, 1600, 1200) w.setWindowTitle(&#x27;网易互客&#x27;) w.setWindowIcon(QIcon(&#x27;huke.icns&#x27;)) w.show() sys.exit(app.exec_()) 接着需要把它打包成一个可以随处运行的可执行程序。需要用到Pyinstaller，通过pip安装即可。 1$pip install pyinstaller 安装完以后，通过以下命令来打包 12$sudo pyinstaller --windowed --icon huke.icns --osx-bundle-identifier com.netease.huke --onedir huke.py --name 网易互客$sudo pyinstaller huke.spec 这样在dist目录下就可以找到最后的可执行程序了 如果你在高分辨率的屏幕上打开这个程序，会发现字体非常模糊。需要在spec文件中加上如下配置 然后重新对spec文件打包，最后的运行效果","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"python","slug":"python","permalink":"https://lchml.com/tags/python/"}]},{"title":"两个小问题","slug":"two-bugs","date":"2020-05-02T16:00:00.000Z","updated":"2022-05-12T06:11:07.786Z","comments":true,"path":"technology/two-bugs/","link":"","permalink":"https://lchml.com/technology/two-bugs/","excerpt":"好久没有写东西了，下个月要给智慧企业技术公众号写一篇文章，得抓紧时间找找感觉了，就记录一下最近业务上遇到的两个小问题吧。","text":"好久没有写东西了，下个月要给智慧企业技术公众号写一篇文章，得抓紧时间找找感觉了，就记录一下最近业务上遇到的两个小问题吧。 httpclient请求偶现异常业务上请求第三方http服务时，偶尔会出现org.apache.http.NoHttpResponseException: The target server failed to respond异常报警。一开始以为是对方服务的偶尔不可能用，但后来发现对于多个第三方服务都会出现一样的情况，那基本可以断定问题是出在自己这里。（当觉得别人都有问题的时候，要想一下是不是自己有问题。） 首先通过异常堆栈我们可以判断，请求是通过apache的httpclient发起的。 123Caused by: org.apache.http.NoHttpResponseException: *********** failed to respond at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:143) at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:57) 可以从网上查到相关的错误原因： 1234567org.apache.commons.httpclient.NoHttpResponseException java.io.IOException +- org.apache.commons.httpclient.NoHttpResponseExceptionIn some circumstances, usually when under heavy load, the web server may be able to receive requests but unable to process them. A lack of sufficient resources like worker threads is a good example. This may cause the server to drop the connection to the client without giving any response. HttpClient throws NoHttpResponseException when it encounters such a condition. In most cases it is safe to retry a method that failed with NoHttpResponseException. 可以看到产生错误的原因是，服务关闭连接时没有通知客户端，当客户端再次使用该连接时会产生这个错误。打开httpclient的debug日志，我们可以看到，出现错误时最后的日志是end of steam，我们知道一般产生end of stream的原因是TCP连接的服务端主动关闭连接造成。查看http服务端的nginx配置，发现设置了keepAlive 32s，也就是说当连接空闲超过32s时，服务端就会主动发起FIN请求，进入tcp关闭的四次挥手流程。由于httpclient没有主动关闭连接，导致连接处于半关闭状态，而连接还存在于连接池中，所以当下次再被取出来用时就会收到服务端的RST。 apache httpclient提供了两个办法来解决这个问题，具体源码实现可以在AbstractConnPool.java中看到，这里就不贴了。 1、通过PoolingHttpClientConnectionManager.setValidateAfterInactivity(evictIdle);设置连接空闲多久以后需要进行validate检查 2、通过HttpClientBuilder.evictIdleConnections(evictIdle, TimeUnit.MILLISECONDS)设置连接空闲多久后将被清理出连接池。因此只要我们配置上这两个参数，保证它小于服务端保持连接的时间就可以了。 jvm进程异常崩溃最近线上某个服务的进程相继发生崩溃，jvm进程直接崩溃了。通过服务监控平台可以看到，在崩溃的时间点，cpu、内存、磁盘等资源都没有出现异常，只有load彪到了100。找SA排查了宿主机steal等因素，都没有发现可疑的情况。怀疑load飙升不是引起进程崩溃的原因，而是进程崩溃系统生成coredump才引起load飙升。而该服务之前半年都没有发生过崩溃，上个版本的最大的改动是引入了系统ffmpeg的调用。因此首先怀疑是ffmpeg调用引起的，接下来找到系统的崩溃日志hs_err_pid103051.log，该日志的最上方有一个总结性的描述： 123456# JRE version: Java(TM) SE Runtime Environment (8.0_101-b13) (build 1.8.0_101-b13)# Java VM: Java HotSpot(TM) 64-Bit Server VM (25.101-b13 mixed mode linux-amd64 compressed oops)# Problematic frame:# J 11860 C2 com.google.gson.internal.bind. .write(Lcom/google/gson/stream/JsonWriter;Ljava/lang/Object;)V (81 bytes) @ 0x00007fa06f256b66 [0x00007fa06f256ae0+0x86]## Core dump written. Default location: /xxx/xxx/core or core.103051 可以看到它指出可能的问题是gson的序列化引起的，但是这个gson库已经在其他线上业务使用了几年了，从来没有发生过这样的问题，所以还是有怀疑，继续找到上面描述的core dump文件。 常情况下，coredump（亦称为core文件）文件包含程序运行时的内存信息，含寄存器状态、堆栈指针、内存管理信息、操作系统flags及其他信息，可以理解为把程序工作的当前状态存储成一个文件。Coredump文件通常于程序异常终止（crashed）时自动生成，常用于辅助分析和解决bug，可通过 coredump 文件进行栈回溯和反汇编。 通过gdb对core文件进行backtrace操作，可以看到如下信息： 说明引起崩溃的进程并不是我们怀疑的ffmpeg进程，而是jvm本身引起的，所以看来只能继续从jvm的原因入手，网上找关于gson序列化引起崩溃的例子，很少有提到类似的情况，我们找到上面错误日志里说的导致崩溃的方法源码，从方法中并没有看出有什么会引起jvm崩溃的地方。 1234567891011121314151617181920212223242526@Overridepublic void write(JsonWriter out, T value) throws IOException &#123; // Order of preference for choosing type adapters // First preference: a type adapter registered for the runtime type // Second preference: a type adapter registered for the declared type // Third preference: reflective type adapter for the runtime type (if it is a sub class of the declared type) // Fourth preference: reflective type adapter for the declared type TypeAdapter chosen = delegate; Type runtimeType = getRuntimeTypeIfMoreSpecific(type, value); if (runtimeType != type) &#123; TypeAdapter runtimeTypeAdapter = context.getAdapter(TypeToken.get(runtimeType)); if (!(runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter)) &#123; // The user registered a type adapter for the runtime type, so we will use that chosen = runtimeTypeAdapter; &#125; else if (!(delegate instanceof ReflectiveTypeAdapterFactory.Adapter)) &#123; // The user registered a type adapter for Base class, so we prefer it over the // reflective type adapter for the runtime type chosen = delegate; &#125; else &#123; // Use the type adapter for runtime type chosen = runtimeTypeAdapter; &#125; &#125; chosen.write(out, value);&#125; 最后我们给所有进程都加上了-XX:+HeapDumpOnOutOfMemoryError参数，等再次发生进程崩溃时，我们可以拿到对应的堆栈信息，更精确的定位问题。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"},{"name":"httpclient","slug":"httpclient","permalink":"https://lchml.com/tags/httpclient/"},{"name":"jvm","slug":"jvm","permalink":"https://lchml.com/tags/jvm/"},{"name":"coredump","slug":"coredump","permalink":"https://lchml.com/tags/coredump/"},{"name":"crash","slug":"crash","permalink":"https://lchml.com/tags/crash/"}]},{"title":"延时消息队列","slug":"delayq","date":"2019-11-22T16:00:00.000Z","updated":"2022-05-12T06:05:23.853Z","comments":true,"path":"technology/delayq/","link":"","permalink":"https://lchml.com/technology/delayq/","excerpt":"延时队列，顾名思义是延时消费的队列。","text":"延时队列，顾名思义是延时消费的队列。 延时&#x2F;定时队列延时&#x2F;定时消息是指生产者(producer)发送消息到server后，server并不将消息立即发送给消费者(consumer)，而是在producer指定的时间之后送达。比如在电商交易中，经常有这样的场景：下单后如果半个小时内没有支付，自动将订单取消。那么如果不使用延时&#x2F;定时消息，则一般的做法是使用定时任务定期扫描订单状态表，如果半个小时后订单状态还未支付，则将订单取消。而使用延时&#x2F;定时消息实现起来更高效更优雅：用户下单后，发送一个延时消息，指定半个小时后消息送达，那么消费者在半个小时后收到消息就查询消息状态，如果这个时候订单是未支付状态，则取消订单。 Kafka是目前行业使用最广泛的消息队列之一，大部分业务系统中都会部署kafka作为消息队列来实现异步解耦，但是kafka本身并不支持延时投递的能力。RocketMq是阿里基于kafka的理念用java实现的一个消息队列，在开源版本中它也只支持了某几个特定时长的延时投递，满足不了大部分业务场景。因此我们基于kafka实现了自研的延时消息队列，该延时队列基于Kafka扩展，使用方只需对接kafka接口，而无需关心延时队列服务的存在，接入方便快捷。 架构设计 消息流转 发送延时消息延时消息是指消息在当前时间之后一段时间后发送（以发送方本地时间为准）。 1234// 通过kafkaTemplate初始化DelayqClientDelayqClient client = new DelayqClient(kafkaTemplate);// 往test-topic发送一条hello delayq消息，并指定1分钟以后触发。client.delay(&quot;test-topic&quot;, &quot;hello delayq&quot;, 60000L); 发送定时消息定时消息是指指定消息的发送时间（以delayq-server的时间为准）。 1234// 通过kafkaTemplate初始化DelayqClientDelayqClient client = new DelayqClient(kafkaTemplate);// 往test-topic发送一条hello delayq消息，并指定触发时间戳。client.trigger(&quot;test-topic&quot;, &quot;hello delayq&quot;, 1560253828888L); 序列化生产者的value-serializer必须是：com.netease.ysf.delayq.DelayMsg2JsonSerializer消费者的value-deserializer必须是：org.apache.kafka.common.serialization.StringDeserializer 时间信息延时消息的消费方可以通过KafkaMessage的header（kafka版本&gt;&#x3D;0.11）获得与消息有关的时间信息 1234567@KafkaListener(topics = &#123;&quot;DelayqDemoTopic&quot;&#125;)public void listen(@Payload String msg, // 消息内容 @Header(&quot;produceTime&quot;) long produceTime, // 消息生产时间 @Header(&quot;triggerTime&quot;) long triggerTime, // 消息设定触发时间 @Header(&quot;reputTime&quot;) long reputTime) &#123; // 消息实际触发时间 // TODO&#125;","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"消息队列","slug":"消息队列","permalink":"https://lchml.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"MQ","slug":"MQ","permalink":"https://lchml.com/tags/MQ/"},{"name":"Kafka","slug":"Kafka","permalink":"https://lchml.com/tags/Kafka/"},{"name":"延时消息","slug":"延时消息","permalink":"https://lchml.com/tags/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF/"}]},{"title":"最佳日志实践","slug":"log","date":"2019-06-02T16:00:00.000Z","updated":"2022-05-12T05:59:45.802Z","comments":true,"path":"technology/log/","link":"","permalink":"https://lchml.com/technology/log/","excerpt":"日志对于一个软件系统的重要程度是不言而喻的，线上问题定位、运营数据统计、用户画像分析、系统状态监控等都离不开日志。然而，由于日志通常与业务系统的核心能力没有直接关联，所以经常会被开发人员忽视。对于一些简单的小规模应用程序，也许不需要在日志上花费大量精力。但是对于高复杂度的大型系统来说，日志是保证系统可靠运行必不可少的一环。","text":"日志对于一个软件系统的重要程度是不言而喻的，线上问题定位、运营数据统计、用户画像分析、系统状态监控等都离不开日志。然而，由于日志通常与业务系统的核心能力没有直接关联，所以经常会被开发人员忽视。对于一些简单的小规模应用程序，也许不需要在日志上花费大量精力。但是对于高复杂度的大型系统来说，日志是保证系统可靠运行必不可少的一环。 日志需要包含什么内容 良好的日志内容应该是记录的信息不多不少刚刚好的。记录信息太少的问题很明显，但是太多也同样会有问题，会导致真正有用的信息被稀释，增加整个日志系统的负担，甚至影响到核心业务的性能。 通常日志中应该包含的信息包含四类：错误信息、调试信息、运行信息、状态信息。不同的应用类型有不一样的信息，以常用dubbo服务为例，日志应该包含dubbo的调用方IP、接口名、方法名、入参、结果、线程、开始时间、消耗时间、其它关键信息等等。对于webapp应用，日志应该包含调用方IP、请求path、参数、返回码、开始时间、消耗时间等等。对于某些非必须的信息，或者不确定是否需要输出的信息，可以结合配置中心做动态控制。如下所示，是一个典型的dubbo请求日志： 前缀 1[INFO ]2019-03-22 16:39:19.877 [DubboServerHandler-10.122.79.159:32001-thread-242]DS | 主体 1234567891011&#123; &quot;trace&quot;:&quot;5c949f372393dfdd18b9c417fd3b7960&quot;, &quot;service&quot;:&quot;com.netease.nbim.service.api.JackpotService&quot;, &quot;method&quot;:&quot;queryAwardTotal&quot;, &quot;spend&quot;:12, &quot;params&quot;:[&quot;f4f0c38d9ca14f2e9522c4f3fee3b8e8&quot;], &quot;props&quot;:&#123;&quot;ex&quot;:0&#125;, &quot;result&quot;:&#123;&quot;inviteCount&quot;:0,&quot;award&quot;:142.81,&quot;awardWait&quot;:350.40,&quot;awardUsed&quot;:142.81,&quot;level&quot;:1,&quot;levelTodo&quot;:1&#125;, &quot;peer&quot;:&quot;10.122.79.155&quot;, &quot;beginTime&quot;:1553243959864&#125; 常用日志框架Java体系中有很多的日志框架，目前常用的包括log4j、log4j2、commons-logging、slf4j、logback、JUL。这些日志框架总体分为两类：一类是日志门面或者称为接口标准，是一种标准API的封装，例如commons-logging和slf4j，另一类是剩下的日志实现框架。 在早期比较流行的日志门面是Apache的commons-logging，它通过动态查找机制，在程序运行时，使用自己的ClassLoader寻找和载入本地具体的实现。目前使用最广泛的日志门面是slf4j，slf4j在编译期间，静态绑定本地的LOG库使得通用性要比commons-logging要好，它的实现机制决定了slf4j限制较少，使用范围更广。 在日志实现框架中，log4j是最老牌的，也是早期使用最多的。log4j2的log4j的升级版，但是与log4j不兼容。logback是由log4j的作者后来另外出品的（slf4j也是他写的），JUL是jdk官方推出的日志实现。 在各种组合中，常用的组合有：slf4j+logback，slf4j+log4j，commons-logging+log4j。对于新项目，建议使用slf4j+logback组合。 日志单元和日志链路在实际业务中如何有效的管理和使用日志？日志单元+日志链路 日志单元什么是日志最小单元？对于业务日志，我们可以把业务进程分为三类：webapp、RPC(dubbo)、javaapp。webapp和rpc服务都有非常明确的输入输出，可以以一个请求作为日志的最小单元，一个请求内的所有信息汇总到一条日志内。对于其他javaapp进程，也同样可以找出一个日志最小单元，例如mq消费者中的每一次消费可以做为一个最小单元。 被汇总的最小单元日志相比平铺式的日志有很多好处。如在需要定位问题时，日志单元可以有足够的汇总信息，而普通的平铺式日志中，你需要去查询非常多的日志，每条日志都只包含了很小一部分的信息，甚至很多时候你都不知道哪条日志是属于哪个请求的，定位问题会非常困难。在同步输出的情况下日志单元可以减少了落盘次数，减小磁盘IO。日志单元有统一的生命周期管理，可以规范代码中的日志使用。实现方式如下： 代码实现以webapp为例，首先定义好日志单元LogBean： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200public class WebLogBean &#123; private static final Logger logger = LoggerFactory.getLogger(&quot;static&quot;); private static final ThreadLocal&lt;WebLogBean&gt; LOG_BEAN_THREAD_LOCAL = ThreadLocal.withInitial(WebLogBean::new); private long uid = 0; private String path = &quot;&quot;; private String ip = &quot;&quot;; private int code = 0; private long begintime = 0; private long spendtime = 0; private Object headers; private Object params; private Object payload; private String traceid; private Map&lt;String, Object&gt; props = new LinkedHashMap&lt;&gt;(); private Object result; private Object error; public long getUid() &#123; return uid; &#125; public void setUid(long uid) &#123; this.uid = uid; &#125; public static void uid(long uid) &#123; get().setUid(uid); &#125; public String getPath() &#123; return path; &#125; public void setPath(String path) &#123; this.path = path; &#125; public void setTraceid(String traceid) &#123; this.traceid = traceid; &#125; public String getTraceid() &#123; return traceid; &#125; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public static void code(int code) &#123; get().setCode(code); &#125; public long getBegintime() &#123; return begintime; &#125; public void setBegintime(long begintime) &#123; this.begintime = begintime; &#125; public long getSpendtime() &#123; return spendtime; &#125; public void setSpendtime(long spendtime) &#123; this.spendtime = spendtime; &#125; public Object getHeaders() &#123; return headers; &#125; public void setHeaders(Object headers) &#123; this.headers = headers; &#125; public Object getParams() &#123; return params; &#125; public void setParams(Object params) &#123; this.params = params; &#125; public Object getPayload() &#123; return payload; &#125; public void setPayload(Object payload) &#123; this.payload = payload; &#125; public Map&lt;String, Object&gt; getProps() &#123; return props; &#125; public void setProps(Map&lt;String, Object&gt; props) &#123; this.props = props; &#125; public Object getResult() &#123; return result; &#125; public void setResult(Object result) &#123; this.result = result; &#125; public Object getError() &#123; return error; &#125; public void setError(Object error) &#123; this.error = error; &#125; public WebLogBean addProp(String key, Object value) &#123; if (this.getProps() != null) &#123; this.getProps().put(key, (value == null ? &quot;null&quot; : value)); &#125; return this; &#125; public static void prop(String key, Object value) &#123; get().props.put(key, value); &#125; public Object delProp(String key) &#123; if (this.getProps() != null) &#123; return this.getProps().remove(key); &#125; return null; &#125; public Object getProp(String key) &#123; if (this.getProps() != null) &#123; return this.getProps().get(key); &#125; return null; &#125; public void log() &#123; logger.info(GsonBox.LOG.gson().toJson(this)); &#125; public void print() &#123; this.print(System.currentTimeMillis()); &#125; public void print(long now) &#123; this.setSpendtime(now - this.getBegintime()); this.log(); &#125; public static WebLogBean get() &#123; return LOG_BEAN_THREAD_LOCAL.get(); &#125; public static void remove() &#123; LOG_BEAN_THREAD_LOCAL.remove(); &#125; public static WebLogBean start() &#123; WebLogBean logBean = get(); logBean.setBegintime(System.currentTimeMillis()); return logBean; &#125; public static void end() &#123; get().print(); remove(); &#125;&#125; 然后通过interceptor进行日志管理： 12345678910111213141516171819public class LogInterceptor extends HandlerInterceptorAdapter &#123; private static final Logger logger = LoggerFactory.getLogger(LogInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; WebLogBean.start(); WebLogBean logBean = WebLogBean.get(); logBean.setPath(request.getRequestURI()); logBean.setIp(RequestUtil.getIp(request)); logBean.setHeaders(RequestUtil.getHeaders(request)); logBean.setParams(request.getParameterMap()); return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; WebLogBean.end(); &#125;&#125; 由interceptor统一管理日志单元以后（dubbo可以由filter管理，其它类型可以由aop切面管理），在业务中不再需要关心请求的其它信息，只需要往日志中添加自己需要内容即可。 123WebLogBean.prop(&quot;toAccid&quot;, toAccid);WebLogBean.prop(&quot;dbRet&quot;, 1);WebLogBean.prop(&quot;antispamRet&quot;, false); 上面在LogBean中我们可以看到Logger的名称不是类名，而是一个字符串“static”，这是为了将统一管理的日志单元单独输出到独立的日志文件中，便于后续的日志收集。只需要在logback的配置文件中单独为static配置一个appender就可以了： 123&lt;logger name=&quot;static&quot; level=&quot;INFO&quot; additivity=&quot;false&quot; &gt; &lt;appender-ref ref=&quot;STATS&quot; /&gt;&lt;/logger&gt; 日志链路有了日志单元，我们可以看到一个请求内的所有信息，但是在分布式系统中，光靠一个请求的信息有时候还不能定位出问题所在，所以我们需要有日志链路。把一次调用中的所有日志按先后顺序汇总在一起组成日志链路。要完成这个任务，光靠日志框架本身是做不到的，我们需要引入链路追踪组件。如常见的zipkin、pinpoint和网易云提供的NAPM。只需要把追踪的traceid和spanid信息输出到日志单元即可。 异常日志除了正常的业务日志以外，通常进程中还会存在一些不可预见的异常日志，例如由于Exception导致的异常日志，通常会包含完整的堆栈信息，这种堆栈信息不适合直接放入日志单元，通常做法应该是把简要的异常描述放入日志单元，日志堆栈则直接通过ERROR级别日志输出。后续可以通过哨兵对ERROR日志进行监控报警。 其它问题日志单元中有可能出现异步逻辑的情况，由于LogBean是基于ThreadLocal实现的，因此在异步逻辑中需要注意不能直接使用LogBean来添加日志信息，而应该通过原子类或其它中间变量来实现，虽然InheritableThreadLocal是可以继承的，但是实际业务中的异步逻辑通常会是线程池的实现，所以依然不能直接使用。 日志输出方式同步异步对于logback的日志实现，输出方式主要分为两种，同步和异步。 同步方式会在每次调用logger方法时直接写入磁盘并返回，因此它是会阻塞业务线程的，如果磁盘IO跟不上，就会导致业务逻辑被卡住，影响性能。好处是日志会及时输出，不会出现丢失情况。 异步方式在每次调用logger方法时不会落盘，只是把日志放到了一个内存队列中，会由另一个异步线程来负责把内存中的日志数据落盘，当队列超出限制时，会按规则丢弃低级别的日志。好处是异步的方式对业务的性能影响更小。异步配置： 1234567&lt;appender name =&quot;ASYNC&quot; class= &quot;ch.qos.logback.classic.AsyncAppender&quot;&gt; &lt;!-- 默认0不丢失日志。如果队列剩余20%空闲,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold &gt;20&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;256&lt;/queueSize&gt; &lt;appender-ref ref =&quot;FILE&quot;/&gt;&lt;/appender&gt; 动态变更logback支持定时reload配置文件并按照新的规则进行输出，通过这种方式可以临时修改日志输出级别和内容，日志文件等等。 12&lt;!-- 默认不reload，每隔60s reload一次 --&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60000&quot;&gt; 除了logback本身的配置可以reload以外，我们还可以结合配置中心来动态修改日志输出内容，例如可以在配置中心配置是否输出result，或根据param的长度决定是否要输出所有param到日志中等等。 日志滚动logback主要提供了两种日志文件的滚动方式：FixedWindowRollingPolicy和SizeAndTimeBasedRollingPolicy。 简单的解释，FixedWindowRollingPolicy就是按照文件名加索引的方式滚动，日志文件将会是yeaf.log、yeaf.log.1、yeaf.log.2这样的，SizeAndTimeBasedRollingPolicy是按照时间加索引进行滚动。日志文件将会是yeaf.log、yeaf.log.2019-05-15_0这样的。用哪种方式可以根据需求决定，这里推荐使用SizeAndTimeBasedRollingPolicy，不管用哪种一定要注意配置日志文件的存储限制，以免把机器磁盘跑满导致异常。 123456789101112&lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;LOG_FILE&#125;&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;_%i&lt;/fileNamePattern&gt; &lt;maxFileSize&gt;512MB&lt;/maxFileSize&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;totalSizeCap&gt;5GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;pattern&gt;[%-5level]%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread]%logger&#123;0&#125; | %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt; 使用日志输出到磁盘以后，改怎么使用它们呢？在分布式系统中，日志文件分散在成千上万的主机中，我们不可能为了一条日志，去登陆所有机器一台一台的查。因此日志输出以后需要进行收集汇总。 通常我们使用logstash之类的工具来做收集，用elk和HDFS来做存储。 收集日志时，应该把不同类型的日志分开收集，如dubbo服务的日志收集到一起，webapp的日志收集到一起，mq消费者的日志收集到一起，这样做的好处是日志导入elk后，可以为每种类型的日志建立不同的索引，可以提高搜索效率。 线上问题定位是可以通过elk快出查出调用的日志链路，也可以通过业务日志来做一些业务系统的监控，如每分钟登陆的人数，登陆用户的地理位置分布，每分钟的消息数，消息的地理位置分布，等。 还可以通过对HDFS中的日志进行数据挖掘分析，得出一些有价值的结果。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"},{"name":"日志","slug":"日志","permalink":"https://lchml.com/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"自驾新西兰","slug":"newzealand","date":"2019-05-14T16:00:00.000Z","updated":"2022-05-12T06:08:22.792Z","comments":true,"path":"life/newzealand/","link":"","permalink":"https://lchml.com/life/newzealand/","excerpt":"体验自然之美","text":"体验自然之美 这张做封面吧 自驾路线，13天，4人基督城去霍基蒂卡的路上，73号公路霍基蒂卡住的大别墅霍基蒂卡海滩Paparoa国家公园去福克斯冰川路边的呆牛福克斯冰川镜湖入夜去瓦纳卡路上的Bruce Bay中途休息瓦纳卡湖瓦纳卡去皇后镇路上的Cardrona Bra Fence远处那个湖就是皇后镇了彩虹跳伞箭镇，刚好碰上他们节日，好多车主出来展览他们的老爷车去蒂阿瑙的路上又见彩虹米尔福德峡湾因弗卡吉尔新西兰最南端，布拉夫（布拉夫生蚝不错）旦尼丁火车站第一教堂去费尔利的路上房东的农场有绵羊晚上出来找吃的，只有一家中餐厅还开着为了拍这张，冻的瑟瑟发抖去库克山的路上著名的好牧羊人教堂路上开始徒步","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"新西兰","slug":"新西兰","permalink":"https://lchml.com/tags/%E6%96%B0%E8%A5%BF%E5%85%B0/"},{"name":"自驾","slug":"自驾","permalink":"https://lchml.com/tags/%E8%87%AA%E9%A9%BE/"}]},{"title":"Java技能总结","slug":"java-engineer","date":"2019-05-09T16:00:00.000Z","updated":"2022-05-12T06:06:48.764Z","comments":true,"path":"technology/java-engineer/","link":"","permalink":"https://lchml.com/technology/java-engineer/","excerpt":"由于公司业务调整的原因，之前一个多月没有太多工作，所以抽时间出去看看外面的行业动向（面试）。","text":"由于公司业务调整的原因，之前一个多月没有太多工作，所以抽时间出去看看外面的行业动向（面试）。 经过一多月的时间，最终拿到了两个offer，一个是字节跳动（头条）杭州的服务端开发，一个是蚂蚁金服保险中台的P7服务端开发。两个offer的待遇总包差不多，头条的现金大于蚂蚁，期权少于蚂蚁。你猜我会选择哪一个呢？ 我都拒了，继续留在大网易搬砖吧，哈哈哈。虽然都拒了，但是过程还是有挺多收获的，所以专门在这里总结一下吧。 首先说说头条的面试，一共有3轮技术面加一轮hr面。头条的面试最有意思的一点是，会在每轮面试前发邮件直接告诉你，去多刷刷leetcode的算法题或者准备点什么，我们要考的，这是第一次碰到面试前告诉你我要考什么的公司。在面试过程中确实以算法为主，全部都是视频面试，通过桌面共享来现场算法编程，除此之外主要是简单的聊了一些项目经验和架构设计，都不是特别深入。可能由于头条是GoLang技术栈为主的原因，所以整个面试过程中，没有问过任何和java相关的问题。 然后就是蚂蚁的面试，蚂蚁其实一共面了三个部门。第一个是蚂蚁小程序团队，hr面结束以后天真的以为应该通过了，没想到居然第二天收到反馈说hr面挂了，我也是服。后来仔细回想了一下，当时hr问我薪资期望的时候，我可能要价太直接了，哈哈。然后很快简历被花呗的朋友捞过去，可能因为小程序那边通过了技术面的原因吧，所以花呗直接就是CTO聊的，聊得也还可以，但是最后他跟我说他是我现在所在部门大boss的同学，然后坏笑了一下，我就知道没搞头了，最后面试反馈上说的是业务匹配度较低。最后简历又被捞到了蚂蚁保险部门，约我去一个他们的招聘专场，说是可以一天走完所有流程。这次的面试整体都比较顺利，三面面试官是个很不错的人，在面试结束后还给我详细解释分析了我目前存在的不足，技术深度够了，但是广度和高度不够，需要提高自己的格局，形成个人的知识体系。让我更明确接下去该努力的方向，很感谢他，名字就不写出来了，最后顺利拿到offer，中间还博弈了一次薪资。 最后把面试的一些关键点总结成一张图，方便温故而知新吧。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://lchml.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"架构","slug":"架构","permalink":"https://lchml.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"Java基础","slug":"Java基础","permalink":"https://lchml.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Bimaconf —— 开源配置中心","slug":"bimaconf","date":"2019-01-24T16:00:00.000Z","updated":"2022-05-12T06:04:35.582Z","comments":true,"path":"technology/bimaconf/","link":"","permalink":"https://lchml.com/technology/bimaconf/","excerpt":"圈圈配置中心是为了服务网易圈圈开发的通用配置中心服务。","text":"圈圈配置中心是为了服务网易圈圈开发的通用配置中心服务。 项目介绍相比社区已有的开源配置中心，有更多的高级功能和更简洁的接入方式，如 暂停功能 定时更新 历史版本回滚 集群配置 开放能力 权限管理 报警组管理 邮件、泡泡、stone报警支持 格式检查 sdk载入预检查 继承 同时可以集成oauth账号鉴权，方便项目人员权限管理。目前已经在网易内部多个项目的线上环境部署使用。如有需要使用可以联系我提供任何支持。（目前项目处于公司内部开源阶段，因此还没有开放使用，计划后续会开源到社区。） 文件格式支持 后缀 sdk预检查 格式检查 继承 properties ✔️ ✔️ ✔️ yml ✔️ ✔️ ✘ json ✔️ ✔️ ✘ xml ✔️ ✔️ ✘ txt ✔️ ✘ ✘ 架构图 Springboot工程三步快速接入1、通过在Application类上注解@EnableBimaconf启动bimaconf 1234567891011@EnableBimaconf@SpringBootApplicationpublic class TestClient &#123; public static void main(String[] args) &#123; SpringApplication app = new SpringApplicationBuilder(TestClient.class) .bannerMode(Banner.Mode.OFF) .web(WebApplicationType.SERVLET).build(); app.run(args); &#125;&#125; 2、在application.yml中配置server, project 123bimaconf: server: &#x27;http://bimaconf.domain&#x27; project: test-project 3、在代码中增加对应的配置文件类 12345678910public class Configs &#123; @Bimaconf(app = &quot;test-app&quot;, cluster = &quot;dev&quot;, filename = &quot;testconf.properties&quot;) public static class TestXml implements BimaconfCallback &#123;​ @Override public void update(String filename) &#123; System.out.println(&quot;file update: &quot; + filename); &#125; &#125;&#125; SDK具体使用Bimaconf配置Bimaconf SDK启动时自身需要一个配置文件（普通sdk的withProperties启动模式可以不需要配置文件，但同样可以在代码中指定下面的参数），在springboot中直接在application.yml中配置，其它java进程中默认用bimaconf.properties文件，也可以自行指定。 除了快速接入中说的server和project配置以外，还可以一些可选配置参数来提供更加复杂的功能。 参数名 说明 enable 默认true，如果配置了false，怎bimaconf将不会启动 app 应用名，会被@Bimaconf或@BimaconfCluster注解中的app覆盖 cluster 集群名，会被@Bimaconf或@BimaconfCluster注解中的cluster覆盖 scanPackages 用于扫描main方法所在package以外的包中的注解，多个包名用,隔开 projectToken 如果控制台开启了项目的sdk鉴权功能，则需要配置该token，否则不可用 tempDir 下载配置文件时的临时目录，默认./bimaconf retry zookeeper连接参数，当连接断开或zk不可用时的重试次数 retryIntervalMills zookeeper连接参数，当连接断开或zk不可用时的重试时间间隔 @Bimaconf注解当一个类被注解为@Bimaconf，就表示这个类监听了一个配置文件。@Bimaconf中的各项参数用于指定配置文件和相应的行为。 参数名 说明 app 应用名，如果设置了，会覆盖yml或properties中的配置 cluster 集群名，如果设置了，会覆盖yml或properties中的配置 filename 配置文件名 polling 默认false，表示是否定时去配置中心服务器检查配置文件正确性 callbackAfterInit 默认false，表示Bimaconf启动完成后是否调用BimaconfCallback接口 @BimaconfCluster注解当一个类被注解为@BimaconfCluster，就表示这个类监听了一个配置集群。@BimaconfCluster中的各项参数用于指定配置文件和相应的行为。 如果监听了配置集群，则表示当该集群下有任何文件增加、文件修改（目前不支持文件删除同步）都会同步到sdk端，可以用于需要动态增加配置文件的场景。 参数名 说明 app 应用名，如果设置了，会覆盖yml或properties中的配置 cluster 集群名，如果设置了，会覆盖yml或properties中的配置 filePattern 配置文件名匹配正则，默认.*表示匹配任何文件，只有集群中文件名匹配的配置文件才会被下载 polling 默认false，表示是否定时去配置中心服务器检查配置文件正确性 callbackAfterInit 默认false，表示Bimaconf启动完成后是否调用BimaconfCallback接口 BimaconfCallback接口应用程序可以通过让注解了@Bimaconf或@BimaconfCluster的类实现BimaconfCallback接口来实现对配置文件变更事件的监听。接口包含两个方法：preCheck和update。 preCheck方法该方法有default实现，默认返回true。 当sdk监听到配置文件发生变更时，会先把新文件下载到一个临时目录中，此时会调用preCheck方法检查新文件的合法性。返回false，表示下载的配置文件不合法，在启动时会终止进程，在运行中会抛出异常并报警。返回true则会将新文件移动到classpath中，并继续后续的逻辑。 方法参数：path，表示新文件的临时路径（绝对路径） update方法当对应的配置文件发生变更时，且通过合法性检查，成功更新以后回调用update方法，通知应用程序变更事件。 方法参数：filename，表示发生变更的文件名 暂停功能如果某个应用程序使用了bimaconf，但是由于某些理由，希望暂时不适用配置中心的配置，而是在本地修改配置文件做一些测试。这时就需要使用bimaconf的暂停功能，如果不暂停，就算本地修改了配置文件，也会被配置中心的文件重新覆盖。 暂停方法：创建配置文件对应的.pause文件。 例如当需要暂停conf.xml文件的监听，需要先到bimaconf控制台上找到该配置，然后到使用状态中找到对应的主机，再根据控制台上显示的路径地址，到对应的主机目录中创建一个conf.xml.pause文件。这时conf.xml会和配置中心断开，不再同步后续的变更。控制台上也可以看到对应的主机状态变成暂停。当测试完需要重新同步配置中心的文件时，只需删掉.pause文件，就会自动触发重新同步，更新到最新的配置。 后台高级功能 控制台是图形界面，大部分功能只需自行探索就可以了，如创建应用，集群（可批量），配置文件，各种信息展示等。本节主要介绍一下几个可能会有疑惑的功能点。 权限管理 在Bimaconf中权限的管理是项目为边界分割的，不同项目中的权限没有任何联系。 进入项目后，控制台上方可以看到**权限管理**的按钮。进入权限管理页面后，可以添加用户。 被添加用户的权限可以分为三种： 读写权限 读写权限用户对项目中所有的操作都有权限，除了删除项目本身只有创建者可以。和其它权限互斥，当设置了读写权限后，该用户原有的其它权限会被全部清除。 只读权限 只读权限用户对项目中所有非修改类的操作都有权限，包括查看使用状态，查看所有配置文件。除了查看sdk鉴权的信息以外。和其它权限互斥，当设置了读写权限后，该用户原有的其它权限会被全部清除。 集群权限 集群全权限用户表示，只对某个集群中的所有配置文件有读写权限。集群权限可以多个并存，但是与读写和只读互斥。 报警组管理 报警组用于方便统一设置报警接收人 进入项目后，控制台上方可以看到**报警管理**的按钮。进入后有两个tab，一个是报警历史，可以用于查看历史报警信息。还有一个就是报警组管理，可以创建报警组，或修改已有的报警组。 注意：报警组添加成员时，需要输入成员的完整corp邮箱，或者yixin邮箱（yixin邮箱可能会收不到stone报警）。 创建好报警组以后，重新回到项目页面，在每个应用名的右边有一个**编辑**按钮，进入应用编辑页面后可以设置报警组。报警组和报警邮箱列表可以共存，服务器会自动做去重。 开放能力在某些场景下，除了在Bimaconf控制台修改文件以外，可能会需要在某些程序中修改配置文件，如某个配置文件需要暴露给第三方程序，并允许第三方修改该配置文件。这时就需要用到Bimaconf的配置文件开放能力。 在配置文件页面上方可以看到**开放能力**的按钮。进入以后可以选择添加key，确定以后就会生成一组key和secret。第三方可以通过这个key和secret来获取和修改对应的配置文件。 注意：开放能力中创建的key和secret是和创建者绑定在一起的，也就是说通过这个key操作的记录都会被记录在创建者名下。 SDK鉴权功能 默认情况下，项目中的所有配置文件都是可以被他人访问的。 虽然bimaconf.service.163.org是一个机房内网域名，但是只要网络互通，并且知道对应的项目、应用、集群、配置文件名时，任何主机都可以访问对应的配置文件。如果想要自己的配置文件更加安全，不希望被其它人访问，可以开启SDK鉴权功能。开启以后，访问配置文件将需要鉴权。 在控制台首页项目列表中，选择想要开启的项目，进入管理页面。选择开启SDK鉴权，确认以后就会生成一个SDK TOKEN。把这个token配置在sdk的projectToken中。 注意：如果项目有配置文件正在被使用，则切勿随意开启鉴权功能或刷新token，这样将会导致sdk不能访问配置中心。需要先确保sdk已经配置了对应的projectToken，然后再开启鉴权。 定时更新 在实际使用中，通常会需要在未来某个时间点修改某项配置。如在后天早上的0点开启强制更新开关，这个时候如果没有定时更新功能，就需要开发人员在半夜起来打开电脑去完成这次修改。 进入配置文件后，控制台上方可以看到**定时更新**的按钮。进入定时任务管理页面后，可以看到当前配置文件已执行过的和待执行的定时任务。可以有如下操作。 新增任务 对当前配置文件增加一个定时更新任务。点击新增任务按钮，选择计划执行时间并编辑文件内容。计划执行时间至少设置在当前时间的2分钟之后。如果还有其他未执行的任务，则任意两个任务之间的时间间隔必须大于2分钟。同一个配置文件的未执行任务不能超过5个。需要注意的是，由于定时任务会在未来执行，因此当一个配置文件设置了定时任务，在定时任务被执行或被删除之前，该配置文件将被任务创建者锁定，任何人都不能再编辑该配置文件。直到任务完成或删除，自动解除锁定。在任务锁定期间，其他人也不能再新增任务或修改任务。只有锁定人可以新增、修改、删除。 修改任务 只有任务的创建者可以修改任务，只有未执行的任务可以被修改。修改任务时可以重新设定文件内容和任务时间，但同样必须在当前时间的2分钟之后，以及与其他未执行任务的时间间隔大于2分钟。 删除任务 只有任务的创建者可以删除任务，只有未执行的任务可以被删除。 报警通知 以下情况：任务执行成功、执行失败、异常原因导致任务过期。都将会发送email、stone、popo消息给任务创建者。如果执行成功，并更新了配置文件依然会触发正常的文件更新通知。 TIPS: 可以通过设置一个内容没有修改的定时任务来锁定一个配置文件，达到在一段时间内不被其他人修改的目的。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"bimaconf","slug":"bimaconf","permalink":"https://lchml.com/tags/bimaconf/"},{"name":"配置中心","slug":"配置中心","permalink":"https://lchml.com/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"}]},{"title":"Grafana+InfluxDB构建项目数据大盘","slug":"grafana-influxdb-build","date":"2018-11-09T16:00:00.000Z","updated":"2022-05-12T06:05:59.523Z","comments":true,"path":"technology/grafana-influxdb-build/","link":"","permalink":"https://lchml.com/technology/grafana-influxdb-build/","excerpt":"在任何项目中，一个可以直观表示当前系统运行状态的数据大盘对开发和运维人员都是非常有价值的。","text":"在任何项目中，一个可以直观表示当前系统运行状态的数据大盘对开发和运维人员都是非常有价值的。 分析通常互联网大厂内部都会有一些提供监控运维供的公共平台。比如网易内部有哨兵、NDP等。这些平台通常能完成各种监控数据采集和展示。但也正是因为作为公共服务平台，它们无法做到为每个业务产生定制化的数据展示服务，甚至是基于数据的自动运维能力。因此，当项目达到一定量级以后，构建项目自身的数据大盘和自动运维系统就非常必要了。 目前业界使用最广泛的开源监控数据展示框架应属Grafana，它提供种类丰富的仪表盘，可以满足绝大多数的数据展示需求。同时它支持各种常见的数据库作为数据源，并对HQL做了可视化配置，可以快速搭建数据大盘。在数据源方便，虽然现在Grafana已经支持了MySQL之类的传统数据库和ElasticSearch之类的搜索引擎。但通常如果是作为数据大盘使用，最适合的还是时序数据库。时序数据库的数据存储方式本身就是完美匹配了监控数据的展示方式。在时序数据库中，InfluxDB属于老牌了，应该也是业界使用最广泛的时序数据库，其它常见的有OpenTSDB、Druid、Beringei，以及近年兴起的提供整套监控能力的Prometheus。至于选型的过程及原因这里就不做说明了。 实践InfluxDB搭建InfluxDB单机搭建非常简单，首先在官方下载页面找到对应版本下载地址并下载到主机上。 1wget https://dl.influxdata.com/influxdb/releases/influxdb-1.6.4_linux_amd64.tar.gz 解压后进入influxdb-1.6.4-1文件夹，会看到里面有三个子文件夹：etc、usr、var。其中etc&#x2F;influxdb中有配置文件influxdb.conf，用于配置各种启动参数和数据库属性。usr&#x2F;bin目录中是启动脚本，influx是启动客户端程序，默认连接当前主机的默认地址和端口，influxd用于启动数据库。运行.&#x2F;influxd help可以看各种命令参数。位置文件中的各项配置都有英文注释，根据需求配置后以后。运行./influxd &amp;启动，默认端口是8086。 启动以后就可以通过.&#x2F;influx运行客户端连接到当前数据库，influxdb的命令与mysql很接近，稍微看一下就可以学会了。其中有几个主要的常用概念： Database，表示数据库，与mysql的database类似。 Measurement，描述数据库存储结构，可以理解为mysql的table概念，只是不需要手动创建，可以再写入数据时自动创建。 Tag，类似于mysql中的字段，但是他不能被修改，且默认是被索引的。因此写入数据时最好都带上tag。只能是String类型 Field，类似于mysql中的字段，可以被修改。支持类型有floats，integers，strings，booleans。 Timestamp，每条数据都会有一个时间戳，精确到纳秒。 Series，measurement, tag set, retention policy 相同的数据集合算做一个series。理解这个概念至关重要，因为这些数据存储在内存中，如果series太多，会导致OOM。 Retention Policy，保留策略，可以在创建数据库时配置也可以在写入数据时指定，默认是永久保存，副本为1. Continuous Query，CQ 是预先配置好的一些查询命令，定期自动执行这些命令并将查询结果写入指定的 measurement 中，这个功能主要用于数据聚合。具体可参考：官方文档。 Shard，存储一定时间间隔的数据，每个目录对应一个shard，目录的名字就是shard id。每一个shard都有自己的cache、wal、tsm file 以及 compactor，目的就是通过时间来快速定位到要查询数据的相关资源，加速查询的过程，并且也让之后的批量删除数据的操作变得非常简单且高效。 目前官方说明，在1.7以后的版本中，将不再开源InfluxDB的集群模式。1.7及之前版本还可以通过官方的集群模式来部署高可用的InfluxDB集群。 Grafana搭建完成数据库搭建以后，接下来就是前端展示框架Grafana的搭建。同样在官网上找到对应的下载地址并下载到主机。 1wget https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-5.3.2.linux-amd64.tar.gz 解压后进入grafana-5.3.2文件夹，其中conf&#x2F;default.ini用于各种参数配置，bin&#x2F;grafana-server用于启动grafana服务。我们主要需要对defalut.ini中的参数进行修改。首先[path]目录下是关于数据库存储的一些配置，可以不修改。[server]目录下是关于服务的一些参数，如果是提供https访问，就需要把protocol改为https，并设置对应的cert_file和cert_key。http_port是提供服务的端口，domain是提供服务的域名。要注意，如果配置了domain但是又不是通过domain来访问Grafana的话会导致服务器不可用，并在页面会提示你。其中有一个root_url的配置需要注意，如果需要配置公司内的Opneid登陆，那么这个root_url会作为openbid认证的跳转链接。需要配置为在openid认证注册的跳转url。 接下来是Database目录，用于配置grafana自身的sqlite的配置。默认sqlite3文件在data&#x2F;grafana.db，可以通过sqlite3客户端直接访问，其中存储了一些用户信息数据和监控表盘配置数据。 再往下有各种认证支持的配置，如Google OAuth,Github OAuth等等，如果要接入公司内的Openid认证，那就找到Generic OAuth目录，把enable改为true，并配置上oauth相关的参数。如果没问题的话，这时候刷新页面应该就可以通过openid登录了。如果为了数据安全，不想让全公司的人都可以看，那就把其中allow_sign_up一项改为false，这样的话，用户就需要通过邀请才能登录。 其它各种配置这里就不一一说明了，基本都有英文注释，很容易看懂。 启动Grafana以后，首先以admin的默认账号登录，系统会引导你修改账号密码，创建dashboard等操作。如果是只允许openid用户登录，建议把普通登录框隐藏掉。disable_login_form改为false。不过这里似乎有个小bug，当隐藏了登录框以后，邀请用户的按钮会消失，不过可以直接在url上输入&#x2F;org&#x2F;users&#x2F;invite进入邀请页面。如果想要发送邀请邮件，需要在default.ini中配置stmp相关的参数。不配置的话，也可以直接在邀请页面把邀请链接复制给对方。 数据采集数据采集工作，就根据业务的需求来定制了，可以从公共监控平台获取已经采集好的数据按时序导入到Influxdb，也可以通过kafka得到业务抄送出来的直接数据，自己做清洗分析以后导入influxdb。还可以从ElasticSearch中获取采集好的日志，分析以后导入。总之数据源可以来自各种途径。 表盘插件Grafana支持插件模式，比如比较常用的Pie Chart和WorldMap，可以在官网上看到安装和实用方式。 扩展在搭建好基础的监控系统以后，接下来就可以根据数据分析得到的结果来进行自动运维的工作，如自动拉起进程，自动调整路由权重等等，这快内容相对就更加复杂和个性化了，在以后的文章中再另做分析。 最终效果","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Grafana","slug":"Grafana","permalink":"https://lchml.com/tags/Grafana/"},{"name":"InfluxDB","slug":"InfluxDB","permalink":"https://lchml.com/tags/InfluxDB/"},{"name":"数据大盘","slug":"数据大盘","permalink":"https://lchml.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%A7%E7%9B%98/"}]},{"title":"Tomcat配置CloudFlare免费ssl证书问题","slug":"tomcat-ssl","date":"2018-10-25T07:38:00.000Z","updated":"2022-05-12T06:10:50.136Z","comments":true,"path":"technology/tomcat-ssl/","link":"","permalink":"https://lchml.com/technology/tomcat-ssl/","excerpt":"花了三个小时时间才解决这个小问题。","text":"花了三个小时时间才解决这个小问题。 起因：在tomcat上配置cloudflare的免费ssl证书，确不起作用。 过程：在cloudflare上创建了免费的ssl证书，会拿到两个key，一个是证书，一个是私钥。分别保存为cert.pem和key.pem。 这时候如果按照一般的步骤，通过keytool把cert.pem导入到keystore中，然后在tomcat的server.xml中配置对应的Connector。会发现，虽然443端口打开了，但是访问443端口没有任何回包。去看tomcat的catalina日志，会发现在启动时有一个异常： 1Alias name [*] does not identify a key entry 但是通过keytool -list -v去查看jks中的证书，却又看到明明是有这个alias的。 分析：就是因为被这个异常误导，所以花了大量时间在研究是不是生成jks的方法有问题，然而其实问题和alias本身没有关系。之所以会有这个问题，是因为上面的做法中，keystore只导入了pem证书，却没有证书对应的私钥，因此无法使用。 解决：需要先把证书和私钥合并为p12证书，然后再把证书导入jks中。步骤如下： 合并证书和私钥，会要求输入合并后的证书密码：xxxxxx 1openssl pkcs12 -inkey key.pem -in cert.pem -export -out cert.p12 把生成后的证书导入jks中 1keytool -importkeystore -srckeystore cert.p12 -srcstorepass xxxxxx -srcstoretype pkcs12 -destkeystore mydomain.jks -deststoretype jks -deststorepass xxxxxx 生成mydomain.jks后在tomcat中配置对应的Connector并重启tomcat。 12345678910&lt;Connector port=&quot;443&quot; scheme=&quot;https&quot; secure=&quot;true&quot; SSLEnabled=&quot;true&quot; clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; disableUploadTimeout=&quot;true&quot; keyAlias=&quot;1&quot; keystoreFile=&quot;/root/mydomain.jks&quot; keystorePass=&quot;xxxxxx&quot;/&gt; 现在可以正常访问了：https://moviehell.net","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"SSL","slug":"SSL","permalink":"https://lchml.com/tags/SSL/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://lchml.com/tags/HTTPS/"},{"name":"CloudFlare","slug":"CloudFlare","permalink":"https://lchml.com/tags/CloudFlare/"}]},{"title":"Druid经常出现连接不可用的问题","slug":"druid-validation","date":"2018-09-05T16:00:00.000Z","updated":"2022-05-12T06:01:18.529Z","comments":true,"path":"technology/druid-validation/","link":"","permalink":"https://lchml.com/technology/druid-validation/","excerpt":"又踩了一个数据库连接池的坑，纪念一下。公司的分布式数据库由于更新驱动层，并且目前还只支持Druid连接池，因此项目的数据库连接池也从Hikari换到了Druid。然后换上没多久，测试服就开始频繁报警。","text":"又踩了一个数据库连接池的坑，纪念一下。公司的分布式数据库由于更新驱动层，并且目前还只支持Druid连接池，因此项目的数据库连接池也从Hikari换到了Druid。然后换上没多久，测试服就开始频繁报警。 123456The last packet successfully received from the server was 2,357,232 milliseconds ago. The last packet sent successfully to the server was 931,359 milliseconds ago.CommunicationsException, druid version 1.1.10, jdbcUrl : jdbc:mysql:ddb://xx.xxx.xxx.xxx:6000/dbname, testWhileIdle true, idle millis 22216001, minIdle 20, poolingCount 19, timeBetweenEvictionRunsMillis 60000, lastValidIdleMillis 22216001, driver com.netease.lbd.LBDriver, exceptionSorter com.alibaba.druid.pool.vendor.MySqlExceptionSorter 这个错误的原因很明显，使用了一个已经失效的连接去做db操作，就会返回这个错误。也就是说db操作的时候从数据库连接池里拿到了一个烂的连接。然而首先我们是配置了time-between-eviction-runs-millis的，理论上应该是会定时对连接池中的连接做检查的，但是实际结果显然并没有。 我们直接开始检查druid源码吧，在核心类DruidDataSource中我们可以看到初始化连接池的时候会调用createAndStartDestroyThread()创建一个定时任务来执行DestroyTask，再看DestroyTask里面做了什么。 123456789101112public class DestroyTask implements Runnable &#123; @Override public void run() &#123; shrink(true, keepAlive); if (isRemoveAbandoned()) &#123; removeAbandoned(); &#125; &#125;&#125; 其中isRemoveAbandoned()没有配置，默认是false的。所以，这个task就执行了一句话：shrink(true, keepAlive) 在shrink方法里面的最后我们可以看到有这段代码： 12345678910111213141516171819202122232425262728if (keepAliveCount &gt; 0) &#123; this.getDataSourceStat().addKeepAliveCheckCount(keepAliveCount); // keep order for (int i = keepAliveCount - 1; i &gt;= 0; --i) &#123; DruidConnectionHolder holer = keepAliveConnections[i]; Connection connection = holer.getConnection(); holer.incrementKeepAliveCheckCount(); boolean validate = false; try &#123; this.validateConnection(connection); // 重点 validate = true; &#125; catch (Throwable error) &#123; if (LOG.isDebugEnabled()) &#123; LOG.debug(&quot;keepAliveErr&quot;, error); &#125; // skip &#125; if (validate) &#123; holer.lastActiveTimeMillis = System.currentTimeMillis(); put(holer); &#125; else &#123; JdbcUtils.close(connection); &#125; &#125; Arrays.fill(keepAliveConnections, null);&#125; 用于检查经过shrink以后留存下来的连接是否可用。其中的主要方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void validateConnection(Connection conn) throws SQLException &#123; String query = getValidationQuery(); if (conn.isClosed()) &#123; throw new SQLException(&quot;validateConnection: connection closed&quot;); &#125; if (validConnectionChecker != null) &#123; boolean result = true; Exception error = null; try &#123; result = validConnectionChecker.isValidConnection(conn, validationQuery, validationQueryTimeout); &#125; catch (SQLException ex) &#123; throw ex; &#125; catch (Exception ex) &#123; error = ex; &#125; if (!result) &#123; SQLException sqlError = error != null ? // new SQLException(&quot;validateConnection false&quot;, error) // : new SQLException(&quot;validateConnection false&quot;); throw sqlError; &#125; return; &#125; if (null != query) &#123; Statement stmt = null; ResultSet rs = null; try &#123; stmt = conn.createStatement(); if (getValidationQueryTimeout() &gt; 0) &#123; stmt.setQueryTimeout(getValidationQueryTimeout()); &#125; rs = stmt.executeQuery(query); if (!rs.next()) &#123; throw new SQLException(&quot;validationQuery didn&#x27;t return a row&quot;); &#125; &#125; finally &#123; JdbcUtils.close(rs); JdbcUtils.close(stmt); &#125; &#125;&#125; 再跟进去到validConnectionChecker.isValidConnection(conn, validationQuery, validationQueryTimeout)方法。在这个方法里面可以看到 123456789101112131415161718192021222324252627public boolean isValidConnection(Connection conn, String validateQuery, int validationQueryTimeout) throws Exception &#123; if (conn.isClosed()) &#123; return false; &#125; // 省略 。。。 String query = validateQuery; if (validateQuery == null || validateQuery.isEmpty()) &#123; query = DEFAULT_VALIDATION_QUERY; &#125; Statement stmt = null; ResultSet rs = null; try &#123; stmt = conn.createStatement(); if (validationQueryTimeout &gt; 0) &#123; stmt.setQueryTimeout(validationQueryTimeout); &#125; rs = stmt.executeQuery(query); return true; &#125; finally &#123; JdbcUtils.close(rs); JdbcUtils.close(stmt); &#125;&#125; 如果没有配置validationQuery，会默认使用 “SELECT 1”。于是我们认为不配置validationQuery是没关系的。然后没过多久，还是继续出现了上面说的异常，说明就是有烂的连接留存在连接池里。 重新再看一遍代码，注意到上面的validConnectionChecker有没有可能是null呢？于是找到validConnectionChecker的初始化方法： 1234567891011121314151617181920212223private void initValidConnectionChecker() &#123; if (this.validConnectionChecker != null) &#123; return; &#125; String realDriverClassName = driver.getClass().getName(); if (JdbcUtils.isMySqlDriver(realDriverClassName)) &#123; this.validConnectionChecker = new MySqlValidConnectionChecker(); &#125; else if (realDriverClassName.equals(JdbcConstants.ORACLE_DRIVER) || realDriverClassName.equals(JdbcConstants.ORACLE_DRIVER2)) &#123; this.validConnectionChecker = new OracleValidConnectionChecker(); &#125; else if (realDriverClassName.equals(JdbcConstants.SQL_SERVER_DRIVER) || realDriverClassName.equals(JdbcConstants.SQL_SERVER_DRIVER_SQLJDBC4) || realDriverClassName.equals(JdbcConstants.SQL_SERVER_DRIVER_JTDS)) &#123; this.validConnectionChecker = new MSSQLValidConnectionChecker(); &#125; else if (realDriverClassName.equals(JdbcConstants.POSTGRESQL_DRIVER) || realDriverClassName.equals(JdbcConstants.ENTERPRISEDB_DRIVER)) &#123; this.validConnectionChecker = new PGValidConnectionChecker(); &#125;&#125; 发现如果是数据库的标准驱动，那么validConnectionChecker就是对应数据库的checker，然后恰巧我们的项目中用的是自己实现的db driver。所以这个地方其实根本没有初始化成功。所以validConnectionChecker果然是个null。因此上面的检查代码其实根本没有进到isValidConnection()方法中，所以默认的”SELECT 1”也不起作用了。validateConnection()方法再往下可以看到if (null !&#x3D; query) 的条件下，druid还有一个兜底检查行为。然而又恰好我们又没有配置validationQuery，所以最后兜底也没有兜到。 加上配置以后，第二天发现还是出现了一样的问题，说明连接池里还是有烂掉的连接。继续看源码，直接查看会调用validationConnection的核心方法shrink： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public void shrink(boolean checkTime, boolean keepAlive) &#123; try &#123; lock.lockInterruptibly(); &#125; catch (InterruptedException e) &#123; return; &#125; int evictCount = 0; int keepAliveCount = 0; try &#123; if (!inited) &#123; return; &#125; final int checkCount = poolingCount - minIdle; final long currentTimeMillis = System.currentTimeMillis(); for (int i = 0; i &lt; poolingCount; ++i) &#123; DruidConnectionHolder connection = connections[i]; if (checkTime) &#123; if (phyTimeoutMillis &gt; 0) &#123; long phyConnectTimeMillis = currentTimeMillis - connection.connectTimeMillis; if (phyConnectTimeMillis &gt; phyTimeoutMillis) &#123; evictConnections[evictCount++] = connection; continue; &#125; &#125; long idleMillis = currentTimeMillis - connection.lastActiveTimeMillis; if (idleMillis &lt; minEvictableIdleTimeMillis) &#123; break; &#125; if (checkTime &amp;&amp; i &lt; checkCount) &#123; evictConnections[evictCount++] = connection; &#125; else if (idleMillis &gt; maxEvictableIdleTimeMillis) &#123; evictConnections[evictCount++] = connection; &#125; else if (keepAlive) &#123; keepAliveConnections[keepAliveCount++] = connection; &#125; &#125; else &#123; if (i &lt; checkCount) &#123; evictConnections[evictCount++] = connection; &#125; else &#123; break; &#125; &#125; &#125; int removeCount = evictCount + keepAliveCount; if (removeCount &gt; 0) &#123; System.arraycopy(connections, removeCount, connections, 0, poolingCount - removeCount); Arrays.fill(connections, poolingCount - removeCount, poolingCount, null); poolingCount -= removeCount; &#125; keepAliveCheckCount += keepAliveCount; &#125; finally &#123; lock.unlock(); &#125; if (evictCount &gt; 0) &#123; for (int i = 0; i &lt; evictCount; ++i) &#123; DruidConnectionHolder item = evictConnections[i]; Connection connection = item.getConnection(); JdbcUtils.close(connection); destroyCountUpdater.incrementAndGet(this); &#125; Arrays.fill(evictConnections, null); &#125; if (keepAliveCount &gt; 0) &#123; this.getDataSourceStat().addKeepAliveCheckCount(keepAliveCount); // keep order for (int i = keepAliveCount - 1; i &gt;= 0; --i) &#123; DruidConnectionHolder holer = keepAliveConnections[i]; Connection connection = holer.getConnection(); holer.incrementKeepAliveCheckCount(); boolean validate = false; try &#123; this.validateConnection(connection); validate = true; &#125; catch (Throwable error) &#123; if (LOG.isDebugEnabled()) &#123; LOG.debug(&quot;keepAliveErr&quot;, error); &#125; // skip &#125; if (validate) &#123; holer.lastActiveTimeMillis = System.currentTimeMillis(); put(holer); &#125; else &#123; JdbcUtils.close(connection); &#125; &#125; Arrays.fill(keepAliveConnections, null); &#125;&#125; 从代码中可以看出来，keepAlive的默认值是false，这样就会导致每次shrink之后的keepAliveCount&#x3D;&#x3D;0，也就进不到最后检查存活连接的逻辑中。并且会导致nimIdle的配置失效，连接池最后会被回收至只剩0个连接。所以，我们还差一下配置，keepAlive必须配置为true。 总结：用开源还是得多看源码。还有，druid的代码写的真的是乱，非常乱。对比Hikari的代码，代码可读性差的不是一点点。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Druid","slug":"Druid","permalink":"https://lchml.com/tags/Druid/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://lchml.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"分布式调用追踪系统Zipkin集成","slug":"zipkin","date":"2018-07-16T16:00:00.000Z","updated":"2022-05-12T05:56:13.596Z","comments":true,"path":"technology/zipkin/","link":"","permalink":"https://lchml.com/technology/zipkin/","excerpt":"首先给出demo地址，有问题也可以直接看代码。https://github.com/licheng-xd/dubbo-sleuth","text":"首先给出demo地址，有问题也可以直接看代码。https://github.com/licheng-xd/dubbo-sleuth 准备sleuth是springcloud对zipkin接入的封装，从2.0开始直接采用了brave提供的zipkin接入实现。 由于sleuth对dubbo的支持是从2.0开始的，所以一咬牙直接把整个项目升级成了springboot2.0，springboot2.0和springboot1.x有很多不兼容的地方，这里就不一一细说了，同时springboot升级到2.0以后，dubbo也必须要从0.1.0升级到0.2.0（Apache旗下的dubbo版本），整个过踩坑踩了一个星期。 因为springcloud的微服务框架是基于http构建的，所以sleuth默认是只支持http。在2.0版本中提供了对dubbo的支持，其实看一下源码就知道，就只是一个DubboFilter。后面实现自己的rpc接入sleuth就是参考了它的实现。zipkin本身支持多种collector和storage，默认采用异步http的collector，存储默认在内存中。考虑到对应用本身的性能影响，我们采用kafka来做collector，最大程度的解耦以及减少性能影响。存储选用es，用mysql的话当数据量较大时会影响zipkin-server的查询速度。 本地测试环境部署：本地采用vagrant管理开发环境，在debian的虚拟机中装好，zookeeper，kafka，es，其中es建议用docker镜像直接运行，不需要修改很多系统参数。 启动zipkinserver，采用kafka-collector和es-storage。我本地的vagrant虚拟机ip是192.168.100.101，首先下载zipkin-server，启动命令： 1KAFKA_BOOTSTRAP_SERVERS=192.168.100.101:9092 STORAGE_TYPE=elasticsearch ES_HOSTS=http://192.168.100.101:9200 java -jar zipkin-server-2.9.4-exec.jar 项目添加sleuth依赖由于采用kafka作为collector所以需要原来spring-kafka，同时添加了brave-dubbo的依赖。 12345678910// sleuthcompile &quot;org.springframework.kafka:spring-kafka:2.1.7.RELEASE&quot;compile &quot;org.springframework.cloud:spring-cloud-starter-sleuth:$&#123;SleuthVersion&#125;&quot;compile &quot;org.springframework.cloud:spring-cloud-starter-zipkin:$&#123;SleuthVersion&#125;&quot;compile &quot;org.springframework.cloud:spring-cloud-sleuth-core:$&#123;SleuthVersion&#125;&quot;compile &quot;org.springframework.cloud:spring-cloud-sleuth-zipkin:$&#123;SleuthVersion&#125;&quot;compile &quot;org.springframework.cloud:spring-cloud-sleuth-dependencies:$&#123;SleuthVersion&#125;&quot;compile (&quot;io.zipkin.brave:brave-instrumentation-dubbo-rpc:5.1.0&quot;) &#123; exclude(group: &#x27;com.alibaba&#x27;, module: &#x27;dubbo&#x27;)&#125; 配置12345678910111213spring: application: name: nim-bima-service-user zipkin: sender: type: kafka sleuth: enabled: true traceId128: true sampler: probability: 1.0 kafka: bootstrap-servers: xxx.xxx.xxx.xxx:9092,xxx.xxx.xxx.xxx:9092 dubbo服务和消费端都需要加上对应的tracing filter 12345dubbo: provider: filter: &#x27;tracing&#x27; consumer: filter: &#x27;tracing&#x27; 扩展自研RPC通过filter接入sleuth追踪。filter逻辑的核心在于filterchain的实现，而filterchain的核心逻辑其实就是一个链式的递归调用： 12345678if (this.currentPosition == this.realFilters.size()) &#123; invocation.invoke();&#125;else &#123; this.currentPosition++; NrpcFilter nextFilter = this.realFilters.get(this.currentPosition - 1); nextFilter.doFilter(invocation, this);&#125; 然后通过实现filter来加入追踪功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@FilterActivatepublic class TracingNrpcFilter implements NrpcFilter &#123; private static final Logger logger = LoggerFactory.getLogger(TracingNrpcFilter.class); private Tracer tracer; private TraceContext.Injector&lt;Map&lt;String, String&gt;&gt; injector; @Autowired public void setTracing(Tracing tracing) &#123; tracer = tracing.tracer(); injector = tracing.propagation().injector(SETTER); &#125; @Override public void doFilter(TaskInvocation invocation, NrpcFilterChain filterChain) throws Exception &#123; if (tracer == null) &#123; filterChain.doFilter(invocation, filterChain); return; &#125; logger.debug(&quot;NrpcTracingFilter hit ...&quot;); String className = invocation.getTask().getMethod().getDeclaringClass().getSimpleName(); String methodName = invocation.getTask().getMethod().getName(); final Span span = tracer.nextSpan(); injector.inject(span.context(), invocation.getAttachments()); if (!span.isNoop()) &#123; span.kind(Span.Kind.SERVER).start(); span.name(className + &quot;/&quot; + methodName); InetSocketAddress remoteAddress = invocation.getRemoteAddress(); Endpoint.Builder remoteEndpoint = Endpoint.newBuilder().port(remoteAddress.getPort()); if (!remoteEndpoint.parseIp(remoteAddress.getAddress())) &#123; remoteEndpoint.parseIp(remoteAddress.getHostName()); &#125; span.remoteEndpoint(remoteEndpoint.build()); &#125; String traceid = span.context().traceIdString(); DubboTraceFilter.initTraceid(traceid); invocation.getTask().setTraceid(traceid); try (Tracer.SpanInScope scope = tracer.withSpanInScope(span)) &#123; filterChain.doFilter(invocation, filterChain); &#125; catch (Error | RuntimeException e) &#123; onError(e, span); throw e; &#125; finally &#123; span.finish(); &#125; &#125; static void onError(Throwable error, Span span) &#123; span.error(error); if (error instanceof RpcException) &#123; span.tag(&quot;nrpc.error_code&quot;, Integer.toString(((RpcException) error).getCode())); &#125; &#125; static final Propagation.Setter&lt;Map&lt;String, String&gt;, String&gt; SETTER = new Propagation.Setter&lt;Map&lt;String, String&gt;, String&gt;() &#123; @Override public void put(Map&lt;String, String&gt; carrier, String key, String value) &#123; carrier.put(key, value); &#125; @Override public String toString() &#123; return &quot;Map::set&quot;; &#125; &#125;;&#125; 小技巧：通过tracer.currentSpan().context().traceIdString();把tracing中的traceid拿出来放到业务日志中，结合elk日志收集可以非常容易定位问题。 结果可以从zipkin的数据分析中清楚的看出来整个请求中的rpc调用链，以及每次rpc消耗的时间。 依赖分析你会发现依赖分析页面没有数据。对了，只有当数据在内存中存储的时候，zipkin-server才能直接分析出调用依赖关系。当采用外部存储的时候，就需要单独的依赖分析来实现了。下载zipkin-dependencies.jar并在crontab中创建定时任务，定时对存储数据进行分析，这样就可以看到依赖关系了。 奇怪的小问题 由于引入了springcloud-sleuth，而springcloud会在进程启动时启动一个自己的bootstrap context，作为当前应用ApplicationContext的父ApplicationContext，由于每初始化一个ApplicationContext就会加载一遍spring.factories配置文件中的ApplicationListener，所以配置在spring.factories中的listener都会被执行两次。因此dubbo的WelcomeLogoListener会被执行两次。 使用feign作为http客户端时，build传入的client必须是spring的bean，否则sleuth无法做拦截。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"zipkin","slug":"zipkin","permalink":"https://lchml.com/tags/zipkin/"},{"name":"sleuth","slug":"sleuth","permalink":"https://lchml.com/tags/sleuth/"},{"name":"springboot","slug":"springboot","permalink":"https://lchml.com/tags/springboot/"},{"name":"dubbo","slug":"dubbo","permalink":"https://lchml.com/tags/dubbo/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://lchml.com/tags/elasticsearch/"},{"name":"分布式追踪","slug":"分布式追踪","permalink":"https://lchml.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%BD%E8%B8%AA/"}]},{"title":"Hikari经常出现Failed to validate connection并阻塞应用线程问题","slug":"hikari-maxlifetime","date":"2018-07-10T16:00:00.000Z","updated":"2022-05-12T06:06:27.405Z","comments":true,"path":"technology/hikari-maxlifetime/","link":"","permalink":"https://lchml.com/technology/hikari-maxlifetime/","excerpt":"在分布式系统中的一个dubbo服务，日志中经常出现","text":"在分布式系统中的一个dubbo服务，日志中经常出现 问题描述在分布式系统中的一个dubbo服务，日志中经常出现： 1[WARN ]2018-07-06 19:30:49.581 [DubboServerHandler-10.206.56.200:20008-thread-195]PoolBase | HikariPool-1 - Failed to validate connection com.mysql.jdbc.JDBC4Connection@6a9ac783 (No operations allowed after connection closed.) 同时导致对应请求长时间阻塞，阻塞时间从5s~20s不等。 问题分析首先从Github上下载[Hikari源码][1]，在源码中直接搜索到对应的错误信息日志。 123456789101112131415161718192021222324252627282930313233343536boolean isConnectionAlive(final Connection connection)&#123; try &#123; try &#123; setNetworkTimeout(connection, validationTimeout); final int validationSeconds = (int) Math.max(1000L, validationTimeout) / 1000; if (isUseJdbc4Validation) &#123; return connection.isValid(validationSeconds); &#125; try (Statement statement = connection.createStatement()) &#123; if (isNetworkTimeoutSupported != TRUE) &#123; setQueryTimeout(statement, validationSeconds); &#125; statement.execute(config.getConnectionTestQuery()); &#125; &#125; finally &#123; setNetworkTimeout(connection, networkTimeout); if (isIsolateInternalQueries &amp;&amp; !isAutoCommit) &#123; connection.rollback(); &#125; &#125; return true; &#125; catch (Exception e) &#123; lastConnectionFailure.set(e); LOGGER.warn(&quot;&#123;&#125; - Failed to validate connection &#123;&#125; (&#123;&#125;). Possibly consider using a shorter maxLifetime value.&quot;, poolName, connection, e.getMessage()); return false; &#125;&#125; 从代码中可以看出，错误是从这个isConnectionAlive()中抛出来的，从堆栈可以看出异常是从setNetworkTimeout()方法抛出，这个方法里面逻辑很简单，就是对当前数据库连接设置一个网络超时时间，其实相当于同时检查了连接是否可用。所以这个异常的根本原因就是当前数据库连接已经不可用，但是却依旧存在于Hikari的连接池中。 再来看应用层获取连接的方法： 123456789101112131415161718192021222324252627282930313233343536public Connection getConnection(final long hardTimeout) throws SQLException&#123; suspendResumeLock.acquire(); final long startTime = currentTime(); try &#123; long timeout = hardTimeout; do &#123; PoolEntry poolEntry = connectionBag.borrow(timeout, MILLISECONDS); if (poolEntry == null) &#123; break; // We timed out... break and throw exception &#125; final long now = currentTime(); if (poolEntry.isMarkedEvicted() || (elapsedMillis(poolEntry.lastAccessed, now) &gt; ALIVE_BYPASS_WINDOW_MS &amp;&amp; !isConnectionAlive(poolEntry.connection))) &#123; closeConnection(poolEntry, poolEntry.isMarkedEvicted() ? EVICTED_CONNECTION_MESSAGE : DEAD_CONNECTION_MESSAGE); timeout = hardTimeout - elapsedMillis(startTime); &#125; else &#123; metricsTracker.recordBorrowStats(poolEntry, startTime); return poolEntry.createProxyConnection(leakTaskFactory.schedule(poolEntry), now); &#125; &#125; while (timeout &gt; 0L); metricsTracker.recordBorrowTimeoutStats(startTime); throw createTimeoutException(startTime); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); throw new SQLException(poolName + &quot; - Interrupted during connection acquisition&quot;, e); &#125; finally &#123; suspendResumeLock.release(); &#125;&#125; 逻辑很简答，在while循环里面会从连接池中拿到连接，并通过isConnectionAlive()方法来判断连接是否可用，其中会为连接设置忘了超时setNetworkTimeout()，因此如果连接失效，则会阻塞一个validationTImeout的时间周期并关闭连接。然后继续从连接池取一下连接，如此循环，直到拿到可用连接，或者连接池为空并抛出异常。这就解释了为什么我们在日志中看到的阻塞时间都是5s的倍数，因为这和连续几次拿到无效连接有关。 那为什么连接池中会有无效的连接呢？我们来看连接创建的方法： 1234567891011121314151617181920212223242526272829303132/** * Creating new poolEntry. If maxLifetime is configured, create a future End-of-life task with 2.5% variance from * the maxLifetime time to ensure there is no massive die-off of Connections in the pool. */private PoolEntry createPoolEntry()&#123; try &#123; final PoolEntry poolEntry = newPoolEntry(); final long maxLifetime = config.getMaxLifetime(); if (maxLifetime &gt; 0) &#123; // variance up to 2.5% of the maxlifetime final long variance = maxLifetime &gt; 10_000 ? ThreadLocalRandom.current().nextLong( maxLifetime / 40 ) : 0; final long lifetime = maxLifetime - variance; poolEntry.setFutureEol(houseKeepingExecutorService.schedule( () -&gt; &#123; if (softEvictConnection(poolEntry, &quot;(connection has passed maxLifetime)&quot;, false /* not owner */)) &#123; addBagItem(connectionBag.getWaitingThreadCount()); &#125; &#125;, lifetime, MILLISECONDS)); &#125; return poolEntry; &#125; catch (Exception e) &#123; if (poolState == POOL_NORMAL) &#123; // we check POOL_NORMAL to avoid a flood of messages if shutdown() is running concurrently LOGGER.debug(&quot;&#123;&#125; - Cannot acquire connection from data source&quot;, poolName, (e instanceof ConnectionSetupException ? e.getCause() : e)); &#125; return null; &#125;&#125; 可以看到每个连接创建时都会对应的创建一个schedule任务去调用softEvictConnection()方法将连接设置为Evicted状态，可以看到这个时间的lifetime就是根据我们设置的maxLifetime减去一个随机误差的。也就说如果在lifetime时间内，连接失效Hikari并不会把它从连接池中清理掉。Hikari的默认maxLifetime是30分钟，mysql默认的连接超时是8小时，所以一般不会碰到这个问题。但是由于我在项目中使用的是分布式数据库ddb，所以怀疑是ddb的连接超时小于30分钟导致的。去找dba询问，果然给出的时间是1000s，也就是16分钟左右。 问题解决把Hikari的maxlifetime（注意计算随机误差）设置成比数据库连接超时更短的时间。dbcp中也有类似的配置：minEvictableIdleTimeMillis。 [1]: https://github.com/brettwooldridge/HikariCP","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://lchml.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Hirika","slug":"Hirika","permalink":"https://lchml.com/tags/Hirika/"}]},{"title":"Java常见知识点","slug":"java-brief","date":"2018-07-05T16:00:00.000Z","updated":"2022-05-12T06:00:35.184Z","comments":true,"path":"technology/java-brief/","link":"","permalink":"https://lchml.com/technology/java-brief/","excerpt":"Java是解释执行还是编译运行？其实这个问题本身就是一个错误的问题，以现在jvm的发展来说，jvm在执行字节码时，本身就融合了解释和编译两种方式，部分代码由jvm解释执行，部分代码会由JIT一次性编译成机器指令直接运行。","text":"Java是解释执行还是编译运行？其实这个问题本身就是一个错误的问题，以现在jvm的发展来说，jvm在执行字节码时，本身就融合了解释和编译两种方式，部分代码由jvm解释执行，部分代码会由JIT一次性编译成机器指令直接运行。 泛型、反射原理泛型擦除，反射实现动态创建对象。动态编译 Java IO根据处理数据类型的不同分为：字符流、字节流。根据数据流向不同分为：输出流、输入流。常用的IO对象： 1234567891011121314151617181920212223JavaIO |--字符流 --Reader --BufferedReader --InputStreamReader --FileReader -- ...... --Writer --BufferedWriter --OutputSteamWriter --FileWriter -- ...... |--字节流 --InputStream --FileInputStream --FilterInputStream --BufferedInputStream -- ...... --OutputStream --FileOutputStream --FilterOutputStream --BufferedOutputStream -- ...... JVM：内存、GC、动态编译、类加载、字节码指令、工具 内存管理：直接内存、程序计数器、虚拟机栈、本地方法栈、堆、方法区、运行时常量池 内存模型：主内存、工作内存。 GC算法：标记清除算法、复制算法、标记整理算法 GC策略：Serial、ParNew、Paralle Scavenge、Serial Old、Paralle Old、CMS、G1 类加载过程：加载、验证、准备、解析、初始化、使用、卸载 类加载器：双亲委派模型、双亲委派模型逆向 字节码方法调用指令：invokestatic、invokespecial、invokevirtual、invokeinterface、invokedynamic。 调用分类：解析调用（Resolution）、分派调用（Dispatch） 类型分类：静态类型（Static Type）、实际类型（Actual Type） 常用工具：jps、jstat、jmap、jstack 哪些情况会引起OutOfMemoryError在上面说的内存管理中，除了虚拟机栈和本地方法栈溢出时是StackOverflowError，其他内存区域的溢出都是OutOfMemoryError。 wait，sleep区别 wait是Object的成员方法，sleep是Thread的静态方法 wait会释放锁，而sleep会一直持有锁。 两者都可以让线程暂停一段时间，但本质的区别是，sleep是线程运行状态的控制，而wait是线程之间通信的问题。wait可以把一个线程挂起，直到超时或同一个对象调用notify或notifyAll方法唤醒。wait，notify，notifyAll方法都只能在同步控制方法或代码块中使用。 sleep必须catch异常 Synchronized和ReentrantLock有什么区别，什么是偏向锁、自旋锁，什么是锁升级，膨胀，JUC中除了ReentrantLock外还有哪些锁？[锁相关知识点][1] Synchronized是java关键字，语言层面的同步实现，Lock是一个锁的抽象类，把同步控制交由用户处理 当发生异常时Synchronized会自动释放锁。Lock必须手动在finally中释放锁。 Synchronized无法判断当前锁的状态，Lock可以 Synchronized可重入，不可中断，非公平。Lock可重入，可中断，可以自由选择是否公平锁。 volatile关键字保证变量对所有线程的可见性。禁止指令重排序优化。由于java里的运算不是原子操作，所以volatile变量的运算在并发下依旧是不安全的。 jvm配置大内存时需要注意什么JVM配置大内存的问题主要是FullGC发生的频率和时间的控制。越大的内存，触发FullGC时需要的时间越长。根据业务需求，如果注重吞吐量，忽略延时。那么可以将FullGC的阈值调大。如果延时敏感，则要控制好FullGC发生时的时间。 -XX:-UseCompressedOops参数作用在64位JVM中采用32位的寻址方式，压缩指针，减少内存开销。实现方式是在机器码中植入压缩与解压指令，当对象被读取时，解压，存入heap时，压缩。 ThreadPoolExecutor的线程池工作方式从JDK的源码注释就可以知道。 corePoolSize： the number of threads to keep in the pool, even if they are idle, unless {@code allowCoreThreadTimeOut} is set maximumPoolSize： the maximum number of threads to allow in the pool keepAliveTime： when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating. workQueue： the queue to use for holding tasks before they are executed. This queue will hold only the {@code Runnable} tasks submitted by the {@code execute} method. threadFactory： the factory to use when the executor creates a new thread handler： the handler to use when execution is blocked because the thread bounds and queue capacities are reached Exception、Error、Throwable、RuntimeException区别Throwable是Error和Exception的父类，RuntimeException是Exception的子类 JDK动态代理和cglib的实现方式有何不同JDK动态代理是基于反射和字节码生成实现的，被代理类必须实现接口。cglib是通过继承实现的，所以可以不实现接口，但final类和private方法都无法被代理。还有一种更快的动态代理实现方法，就是采用javaassist或ASM库生成字节码的方式实现，比如HikariCP的连接池中就采用这种方式。 BIO、NIO、AIO区别。poll和epoll有什么区别。简单的理解：BIO一个请求对应一个线程，服务器线程资源会很紧张，导致服务能力上不去。NIO是事件驱动模型，由一个线程处理系统IO事件，上层应用只有在事件发生时才需要处理。AIO与NIO最大的区别是，NIO当有读写事件时，会通知上层做读写操作，而AIO会有系统先完成读写，数据存到缓冲去中，通知上层时数据已经准备好。 数据库：事物隔离级别，表锁和行锁，联合索引，聚簇索引InnoDB中的四种事务隔离级别： 隔离级别 脏读（Dirty Read） 不可重复读（NonRepeatable Read） 幻读（Phantom Read） 未提交读（Read uncommitted） 可能 可能 可能 已提交读（Read committed） 不可能 可能 可能 可重复读（Repeatable read） 不可能 不可能 可能 可串行化（Serializable ） 不可能 不可能 不可能 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读) 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞 MySQL的存储引擎是从MyISAM到InnoDB，锁从表锁到行锁。后者的出现从某种程度上是弥补前者的不足。比如：MyISAM不支持事务，InnoDB支持事务。表锁虽然开销小，锁表快，但高并发下性能低。行锁虽然开销大，锁表慢，但高并发下相比之下性能更高。事务和行锁都是在确保数据准确的基础上提高并发的处理能力。MySQL常用的存储引擎是InnoDB，相对于MyISAM而言。InnoDB更适合高并发场景，同时也支持事务处理。 联合索引的最左原则，如果where中是or条件，则对应的联合索引不起作用。mysql的聚簇索引是指innodb引擎的特性，mysiam并没有，如果需要该索引，只要将索引指定为主键（primary key）就可以了。聚簇索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接指向对应数据块。聚簇索引主键的插入速度要比非聚簇索引主键的插入速度慢很多。相比之下，聚簇索引适合排序，非聚簇索引（也叫二级索引）不适合用在排序的场合。 redis、memcached区别，内存实现。如何实现高可用。redis内存管理采用了自己实现的zmalloc.c，在内存管理上比C的malloc性能要好得多。memcache利用Slab Allocator机制管理内存。预先吧内存划分成数个大小IM的slab class仓库，再把每个仓库分成不同尺寸的块。C语言原生的malloc在不断的申请释放过程中会产生很多内存碎片，降低内存的使用率和访问效率。高可用实现，redis本身已经支持cluster和sentinel模式。redis，memcached都可以通过Twemproxy(又称为nutcracker)实现高可用。也可以自己采用一致性哈希的方式实现。[一致性哈希的原理][2] tcp timewait状态 [TCP相关知识][3]TIME_WAIT的产生条件：主动关闭方在发送四次挥手的最后一个ACK会变为TIME_WAIT状态，保留次状态的时间为两个MSL（linux里一个MSL为30s，是不可配置的）TIME_WAIT两个MSL的作用：可靠安全的关闭TCP连接。比如网络拥塞，主动方最后一个ACK被动方没收到，这时被动方会对FIN开启TCP重传，发送多个FIN包，在这时尚未关闭的TIME_WAIT就会把这些尾巴问题处理掉，不至于对新连接及其它服务产生影响。TIME_WAIT占用的资源：少量内存（大约4K，tcp socket buffer）和一个fd。TIME_WAIT关闭的危害：1、 网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被动方重传或延时过来的FIN包过来后会直接影响新的TCP连接；2、 同样网络情况不好并且无TIME_WAIT等待，关闭连接后无新连接，当接收到被动方重传或延迟的FIN包后，会给被动方回一个RST包，可能会影响被动方其它的服务连接。TCP: time wait bucket table overflow产生原因及影响：原因是超过了linux系统tw数量的阀值。危害是超过阀值后﹐系统会把多余的time-wait socket 删除掉，并且显示警告信息，如果是NAT网络环境又存在大量访问，会产生各种连接不稳定断开的情况。两个重要参数间net.ipv4.tcp_fin_timeout&#x3D;30，默认是60s。tcp_max_tw_buckets&#x3D;256000，最大允许的time_wait数量 spring bean的生命周期，spring源码，beanfactory和factorybean区别spring bean生命周期很多地方都有[详细的说明][4]。FactoryBean是用来生成Bean的工厂类接口，比如Mybatis中的SqlSessionFactoryBean，用于生产SqlSessionFactory类。BeanFactory是所有Spring容器的接口。 jdk序列化原理，fastjson为什么序列化会更快。jdk序列化最重要的两个类，ObjectInputStream和ObjectOutputStream，其中writeObject()是序列化方法，readObject是反序列化方法，注意集合类必须自己实现这两个方法。每个类也可以自己实现这两方法来自定义序列化。fastjson序列化的核心方法是serializer.write(object)。序列化的主要优化有：SerializeWriter.class实现了类似StringBuilder的功能，可以减少数组越界检查，可以性能更好的实现字符串拼接。使用ThreadLocal缓存buf提升性能引入ASM可以避免通过java反射的方式获取属性值，可以提升性能。json的object是一种key&#x2F;value结构，正常的hashmap是无序的，fastjson默认是排序输出的，这是为deserialize优化做准备。反序列化的主要优化有：JSONScanner中预测下一个值的方法nextToken()fastjson自己实现了一个特别的IdentityHashMap，去掉transfer操作的IdentityHashMap，能够在并发时工作，但是不会导致死循环。fastjson的serialize是按照key的顺序进行的，于是fastjson做deserializer时候，采用一种优化算法，就是假设key&#x2F;value的内容是有序的，读取的时候只需要做key的匹配，而不需要把key从输入中读取出来。通过这个优化，使得fastjson在处理json文本的时候，少读取超过50%的token，这个是一个十分关键的优化算法。基于这个算法，使用asm实现，性能提升十分明显，超过300％的性能提升。deserialize的时候，会使用asm来构造对象，并且做batch set，也就是说合并连续调用多个setter方法，而不是分散调用，这个能够提升性能。我们看xml或者javac的parser实现，经常会看到有一个这样的东西symbol table，它就是把一些经常使用的关键字缓存起来，在遍历char[]的时候，同时把hash计算好，通过这个hash值在hashtable中来获取缓存好的symbol，避免创建新的字符串对象。这种优化在fastjson里面用在key的读取，以及enum value的读取。这是也是parse性能优化的关键算法之一。 rabbitmq怎么保证有序在正常使用mq的场景中大多数都是不需要消息的有序的，如果要保证消息绝对有序，那么可以通过hash把需要保证有序的消息全部都分发到同一个队列中，队列只允许有一个消费者，尽量把消息拆多个有序的分组，提高处理速度。 什么是零拷贝传统意义的零拷贝：Zero-Copy describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. 传统方式需要四次数据拷贝和四次上下文切换： 数据从磁盘读取到内核的read buffer 数据从内核缓冲区拷贝到用户缓冲区 数据从用户缓冲区拷贝到内核的socket buffer 数据从内核的socket buffer拷贝到网卡接口的缓冲区 明显上面的第二步和第三步是没有必要的，通过java的FileChannel.transferTo方法（NIO），可以避免上面两次多余的拷贝（当然这需要底层操作系统支持） 调用transferTo,数据从文件由DMA引擎拷贝到内核read buffer 接着DMA从内核read buffer将数据拷贝到网卡接口buffer 上面的两次操作都不需要CPU参与，所以就达到了零拷贝。 Netty的零拷贝体现在三个方面： Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。 Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。 [1]: http://www.importnew.com/21933.html[2]: https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/[3]: https://github.com/BeginMan/BookNotes/blob/master/Unix/Unix-Network-Programming-Volume-1-The-Sockets-Networking-API-3rd-Edition/top2.md[4]: https://www.jianshu.com/p/3944792a5fff","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"java","slug":"java","permalink":"https://lchml.com/tags/java/"},{"name":"面试","slug":"面试","permalink":"https://lchml.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"碎片化思维","slug":"deep-think","date":"2018-03-12T16:00:00.000Z","updated":"2022-05-12T06:04:53.499Z","comments":true,"path":"life/deep-think/","link":"","permalink":"https://lchml.com/life/deep-think/","excerpt":"早上开车来公司的路上，突然意识到自己在很多事的思考上都停留在碎片化的阶段。","text":"早上开车来公司的路上，突然意识到自己在很多事的思考上都停留在碎片化的阶段。 经常会想到一件事，然后对应的想到一些观点，以及自己的态度等等，然后过几分钟以后就忘了这件事，切换到下一件事，然后不停的在这个循环中。最后会形成一种错觉，觉得自己对很多事都有很见解，有态度，有思考。但是仔细去回想一下，就会发现，其实脑子中几乎没有留下任何有价值的思维产出。在我意识到这个问题后，突然觉得有些害怕，如果一直这样下去，最后是不是就浑浑噩噩的结束了这一生。所以我开始想要探究为什么会这样，为什么会出现这种大量碎片化的思维，为什么当自己想要深入思考的时候会有无力的感觉，会不自觉得想要躲避深入的思考，为什么潜意识里总有一种焦虑的情绪，为什么又会形成一种自己有想法有思考的错觉。 在互联网还没有兴起的时代，我们接触不到太多的外界信息，所以每个人都聚焦于线下的生活，一个人独处的时候会反思自己或是思考人生而不是刷朋友圈刷新闻，与朋友聚会时大家会对一件事有更深入探讨而不是不停的变换谈资，那时候信息很少，思考的时间却很多。有人说过“那时日色很慢，车马很慢，一生只够爱一个人”，正是对慢生活的怀念。如今的社会，信息爆炸，瞬息万变。每个人都从手机中不停的吸取碎片化的信息，朋友圈，社会热点，生活娱乐，朋友问候，购物指南，每条信息，每个app都想要挤到我们的脑子里来，每个产品经理都在想尽办法占据你的思维，你的时间。 如今，当你遇到工作上的瓶颈，生活上的困扰时，马上会有大量的外界信息进入你的视野供你选择，而出于本能，你会选择逃避解决问题所需要的深度思考，转而去接收更多的外界信息来缓解自己的焦虑，你被这些看似有用的信息不断干扰，心浮气躁。往往正是这些信息成为了障碍，阻塞了你进行深度思考的通道，堵住了你解决问题的思路。 在整个网络社会和现实社会中到处充斥着各种信息，人们的注意力、关注点的被这些碎片化信息劫持，导致思维始终停留在表层，没有时间没有精力去进行更深层的思考。这就是为什么总会有一种“什么事都知道，但又好像什么都不知道的感觉”。回想过去，会发现脑子中是不是会有各种想法和观点产生，但是却总是停留在表面，而没有对一个观点进行更深入更深刻的分析，从而输出一个完整的观点论。简单的说就是，你想到的观点，能不能完整的表达出来，传递给他人。如果不能，那么这个思考其实是一个碎片化的思考，转瞬即逝，没有产生任何价值。久而久之，由于思维中长时间没有积累新的知识，于是随之而来会产生焦虑的情绪。 如果你期望通过屏蔽所有碎片信息来解决这个问题，那显然是不现实的，因为这是社会发展的趋势，就像有人拒绝使用微信使用各种互联网产品。那他最后可能是解决了碎片化的问题，但是同时他也与这个时代脱节了，随时面临着被社会淘汰的风险。既然信息爆炸带来的碎片化的是这个社会发展的必然阶段，那么我们需要思考的应该是如果在这样碎片化的环境下保持自己的深度思考能力，整合碎片信息，从而带来自己的思维产出。 由于我也是最近才意识到这个问题的严重性，因此没有经过实践验证的方法可以提供，下面是我经过思考以后会尽量去实践的一些方法。 随时记录觉得有价值的想法或无法消化的事情。记录脑中浮现的想法或无法消化的事情时，不必在乎文采，不必在乎逻辑是否合理。关键在于及时用文字记录下来，因为一旦这个想法过去，很快就会被别的信息所淹没，回头想再去找回来就会非常困难。最后能在想法出现的几分钟内就记录下来。在这几分钟内，应该毫不犹豫的写出当时的所想。然后我们可以重新审视自己的内心，在这个过程中通常会发现另一个自己。同时也可以训练在短时间内组织语言表达观点的能力。这是一个非常重要的能力。 倾听别人的事情或者阅读别人的故事，尝试提炼出重点做这件事时，不要像浏览朋友圈或一些娱乐新闻一样，过眼过耳不过脑。尝试着不要着急，慢慢的看慢慢的听，同时试着提炼出整个事情的，起因，经过，结果，各方观点等等的重点信息并用文字记录下来。一定要用文字记录下来，因为脑子中想的和真正表达出来的东西往往是两个结果。 定期对收集的信息进行整理，并思考该如何深度利用这些信息如每天或者每周进行一次信息整理，总结这段时间内，自己收集到的各种信息，如你微信中的收藏，如笔记中复制来的金句观点，如关注的热点事件等。对所有这些信息进行汇总归纳，并思考这些信息的价值，如何利用这些信息产生自己的价值。 总结反思自己前面说的随时记录自己的想法观点，记录之后还需要去重新审视自己的观点。分析这些观点的合理性，有依据的支持这些观点或是反驳这些观点。这是一个自我交流反省的过程。每周写一份自我总结，总结做的好，做的不好的事，并分析背后的原因。必须再强调，一定要用文字的方式。因为思维和文字是不同的维度。 慢下来这里我说慢下来不是指回到没有互联网时代的慢生活，而是让自己的节奏慢下来，说话慢一点，走路慢一点，思维慢一点，不要在看完一条新闻后急着去看下一条，不要在一件事情没有理清楚的时候急着想下一件。 人与人之间的沟通其实也是一个碎片化信息的交流，两个人聊天时，所表达的信息通常都是不完整的。学会深度思考，可以让你在聊天时更清晰的接收对方想要表达的观点，以及观点的意图，有意或无意的。也可以让你更简洁明了的表达自己的观点。这样的沟通就会更有效果更有效率。在这个碎片化的时代，我们应该学会无论何时何地的进行独立的，深度的思考。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"碎片化","slug":"碎片化","permalink":"https://lchml.com/tags/%E7%A2%8E%E7%89%87%E5%8C%96/"},{"name":"深度思考","slug":"深度思考","permalink":"https://lchml.com/tags/%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83/"}]},{"title":"凤凰山-玉皇山","slug":"fenghuangshan","date":"2018-03-10T16:00:00.000Z","updated":"2022-05-12T06:01:06.591Z","comments":true,"path":"life/fenghuangshan/","link":"","permalink":"https://lchml.com/life/fenghuangshan/","excerpt":"登高望远，不负好春光。网上很多攻略都说从万松书院上山，所以也没有查证就直奔万松书院。幸好买了门票准备上山的时候问了一句，工作人员告知，万松书院是封闭景区，与凤凰山有围栏隔开。上凤凰山要从停车场附近的节义亭上山。不过既然票都买了，那就进去看看吧，正好还没进去过。","text":"登高望远，不负好春光。网上很多攻略都说从万松书院上山，所以也没有查证就直奔万松书院。幸好买了门票准备上山的时候问了一句，工作人员告知，万松书院是封闭景区，与凤凰山有围栏隔开。上凤凰山要从停车场附近的节义亭上山。不过既然票都买了，那就进去看看吧，正好还没进去过。 万松书院，位于凤凰山北万松岭上 ，书院始建于唐贞元年间（785-804），名报恩寺。明弘治十一年（1498），浙江右参政周木改辟为万松书院。明代理学家王阳明曾在此讲学。清康熙帝为书院题写“浙水敷文”匾额，遂改称为敷文书院。现遗址尚存有“万世师表”四字的牌坊一座和依稀可见“至圣先师孔子像”的石碑等物。 大成殿中立有儒家五圣的雕像：孔子（至圣），颜子（复圣），曾子（宗圣），子思（述圣），孟子（亚圣）。虽然孟子在五圣中只排名第五，但是五圣的排序是与时间备份有关的，并不代表成就。孟子是仅次于孔子的一代儒家宗师，与孔子合称“孔孟”，因此后世我们常称儒家为“孔孟之道”。 另外，中国四大民间爱情神话传说之一，《梁祝》的故事也发生在万松书院，因此这里也是杭州常用的相亲大会举办地。据工作人员介绍，每周六都会有相亲会在此进行。 凤凰山在杭州市的南面。主峰海拔178米，北近西湖，南接江滨，形若飞凤，故名。隋唐在此肇建州治。五代吴越国将杭州设为国都，筑子城。南宋在凤凰山麓建造皇城（东起凤山门，西至凤凰山西麓，南起苕帚湾，北至万松岭，方圆4.5公里。大内有城门3座，南称丽正，北为和宁，东曰东华）。 玉皇山（237米），道教主流全真派圣地，地处西湖与钱塘江之间原名龙山，远望如巨龙横卧，雄姿俊法,风起云涌时，但见湖山空阔，江天浩瀚，境界壮伟高远,史称“万山之祖”。与凤凰山首尾相连,有“龙飞凤舞”的美称。是新西湖十景之一“玉皇飞云”所在地。 八卦田曾是南宋皇家籍田的遗址。籍田是古代中国以农为本的农耕文化的缩影，是古代帝皇通过神圣仪式活动对农业生产予以重视的场所。八卦田最早出现于明代记载，据&lt;西湖游览志&gt;记载：“南山胜迹中有宋藉田，在天龙寺下，中阜规圆，环以沟塍，作八卦状，俗称九宫八卦田，至今不紊”。 从书院出来往前走一点点就是节义亭，沿着台阶开始上山。这条路线总体没什么难度，空气好，阳光明媚，又带有历史文化，是休闲登山的不错选择。在山上向北可以望见西湖，向南可以望见钱塘江。所谓“内看西子，外眺钱江”。玉皇山与凤凰山首位相连，沿着山路可以直接从凤凰山到达玉皇山。路上还会经过“老玉皇宫”，是一处道观。观中提供10元一万的素面，许多登山饿了的游客会在此吃碗面，简单的咸菜面，味道还行吧。在门口往下可以直接下山到八卦田，往上可以去紫来洞。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"玉皇山","slug":"玉皇山","permalink":"https://lchml.com/tags/%E7%8E%89%E7%9A%87%E5%B1%B1/"},{"name":"凤凰山","slug":"凤凰山","permalink":"https://lchml.com/tags/%E5%87%A4%E5%87%B0%E5%B1%B1/"},{"name":"八卦田","slug":"八卦田","permalink":"https://lchml.com/tags/%E5%85%AB%E5%8D%A6%E7%94%B0/"},{"name":"万松书院","slug":"万松书院","permalink":"https://lchml.com/tags/%E4%B8%87%E6%9D%BE%E4%B9%A6%E9%99%A2/"}]},{"title":"理想照进现实 —— Thailand（下）","slug":"thailand2","date":"2018-02-11T16:00:00.000Z","updated":"2022-05-12T06:10:42.385Z","comments":true,"path":"life/thailand2/","link":"","permalink":"https://lchml.com/life/thailand2/","excerpt":"迟迟无法动笔写下曼谷和清迈的见闻，是因为对曼谷和清迈真的印象一般，似乎总结下来也就几句话，真的凑不成文，自然而言的要写出一篇虎头蛇尾的游记来。","text":"迟迟无法动笔写下曼谷和清迈的见闻，是因为对曼谷和清迈真的印象一般，似乎总结下来也就几句话，真的凑不成文，自然而言的要写出一篇虎头蛇尾的游记来。 先说曼谷，似乎还没来到曼谷我就已经在各大驴友网上吸收了一波游记炸弹，给我留下根深蒂固的刻板印象——来曼谷就是来购物的，没有其他。由于我们俩都是那种进了商场就晕的穷光蛋，所以在曼谷就安排了1天的行程，主要是打算去见识下世界最大购物中心的风采，顺便看看有什么要买的。从芭提雅到曼谷是飞猪上叫的拼车服务，同行的是两男两女，其中女生是香港人。高速走了不到两小时，进了曼谷市区却堵了一个多小时，真是名副其实的堵城。 人的心理真是神奇的东西。我想可能是因为我还未出发就把曼谷的优先级放低了，后来发现自己订的酒店也是三个城市下来最差的一个，行程也是最烂的一部分。酒店位置不错，从酒店二楼可直接进入地铁站。泰国的地铁价格不低，乘坐舒适度和国内的相差不多，不买交通卡的话基本上2站路就要5块钱人民币。然而我们发现除了地铁我们根本没有更便捷经济的出行方式。三轮嘟嘟车到处宰客，从水门市场到皇权免税店也就2公里左右的路程，要加100株，事实上也是因为近年来游客多了当地人就开始宰客了。要提醒游客的是，如果你要从清迈等城市离境，曼谷的皇权免税店并不能购买商品并为你寄送到机场。如果你来泰国是为了买买买，真的建议你从曼谷离境，因为清迈的免税店相对规模小且价格高。 泰国的BTS也不是严格意义上的地铁，算轻轨吧，开在高架上。出站后直接无缝连接到各大商场，简直置身在买买买的大世界中，根本不用为小雨没打伞发愁。下图是从地铁出站口往两侧看到的商场一角。 好吧，我发现曼谷的照片已经over了。就文字描述下吧。在曼谷的一天，主要时间都花在商场和比价上了。我本不是个对买买买很有天赋的人，但据说这里的内衣和牛仔服简直是白菜价，无论是身边的同事还是参考的游记，甚至有详细的购买攻略。然而，当我撸起袖子准备大干一场的时候，却发现并不是这样，而此时就算是知道并不划算不买一些回去真觉得对不起自己这一趟了。我深刻怀疑这些买买买攻略都是卖家的水军。实地考察发现，至少是1月份这个时节，曼谷各大商场各大内衣品牌和牛仔品牌并么有大的折扣，和网购比起来可能价格都没有优势。但是，有句老话叫做：来都来了！ 所以我还是焦头烂额的拼命完成了这次曼谷之行的使命，然后顺利坐上了去往清迈的鸟航。 都说清迈是个休闲旅游的好地方，游记也都是各种推荐，然而自己真的去过才觉得也就那样吧。说说总体印象吧。首先，清迈气候适宜，在泰国的凉季偏凉，雨天穿短袖还会让人禁不住哆嗦。我想也许夏天来刚刚好吧。清迈是个小城，中心是古城，四面都有古城墙遗迹，出了古城区就是现代城市了。吃喝玩乐都在四面古城墙的周围，比如宁曼路、周末夜市和各种佛教寺庙。其次，清迈遍地是寺庙，50万人口的小城居然有大大小小的300多座寺庙，这些寺庙根据建造年代和宗教流派的不同而有着各种各样的建筑风格和特色，其中最大数帕辛寺和契迪龙寺。如果你是个虔诚的朝圣者，那么清迈真的是你该来的地方。另外，清迈属于泰北，说起泰餐其实和曼谷差别很大，我无法说的头头是道但个人还是偏爱南部的味道一些，以至于到后来我们非常想找一家中餐厅坐下来。 对清迈的好印象出自某人订的酒店，是我喜欢的风格，白天有泳池休闲时光，夜晚有晚风穿过长廊，开放式的格局让人心情大好，从曼谷的腐朽气息中解脱出来。酒店的早餐很棒，但次于芭提雅那家。 到了清迈发现，这个小城真的没什么好玩的，能玩的地方都在古城内，如果你不是户外运动的爱好者，也不喜欢发呆的话就只能去古城街道上吸尾气或者被某宝上各种一日游牵着鼻子走了。清迈似乎是个适合户外运动的地方，除了有很多老外来玩，各种商家也是批量定制了很多户外一日游项目。如果要去的话，一大早从古城拼车或包车前往百余公里外的场地，在那边排队游玩看人海2小时，然后再舟车劳顿往回跑，一天就过去了。想想真不是我想要的样子。因为我的三天主要是花在了古城游。第一日睡到自然醒后坐嘟嘟车加步行逛了古城的部分道路，发现光靠双腿根本不行。其中，主要是参观了契迪龙寺和其他一些不知名的寺庙，清迈的寺庙真的很多，可见佛教意义在泰国人心目中的地位。契迪龙寺算是仅次于帕辛寺的寺庙，也是建设得最华丽的一座，对外开放但收取门票，寺内有一颗巨大的不知道品种的树给我的印象较深。进入寺庙不允许穿着过于暴露，入寺前可以租借特定的服装。 除了契迪龙寺，还有很多寺庙，回来后甚至都记不清分别是哪一座了。以下照片出自各大不知名寺庙，有的游客不多，安安静静，僧侣们做着手头的功课，一派静谧。有的游客络绎不绝，人声嘈杂，我们进去后马上就出来了。还有的里面有部门佛殿不允许女子进入只有男子可以进入，不知出于什么道理。 寺庙都建在沿街的位置，出了庙门就是马路，小师傅们也是自由出入寺庙，仿佛寺庙就跟学校一般。还别说，契迪龙寺隔壁就是一个小学，有部分小僧侣出入于学校和寺庙之间。 在经过一天双腿的苦旅后，我们选择了租借自行车逛古城。租车很方便，价格也不高，但是在泰国似乎自行车是很不实际的一种交通工具，原因有二：道路未设置自行车道，需要和摩托车汽车抢车道很危险；其次是马路上四处横飞的摩托车时刻排放着熏天的尾气让人一刻都不想逗留。所以第二日虽然不再苦了双腿却把尾气吸了个饱，并且遗憾的是也未进入清迈大学看看这座清迈最好的高校。去美南河边走一遭，据说邓丽君去世时所在的美萍酒店就在附近。去清迈当地人每天都要去的菜市场晃荡一圈。偶遇一个俄罗斯旅行团，对我手中的竹节饭很是感兴趣，我只是笑笑，不好意思告诉他们这东西并不美味。问一问花市的价格，相对国内没有优势。至于泰餐，在经过两天的冬阴功后实在是吃不下了，开始寻找中餐。找到了一家有土豆丝和臊子面的西北餐馆，感觉已经很幸福了。 到了第三日已经迫不及待想要回国了，提上行李再一次走上清迈的街道，气候很舒爽，还是一样的尾气一样的街道，沿途花20株喝下一整个椰子水吃下一整个小菠萝。在街边的小酒馆喝一杯苏打水来一份冬阴功盖饭，有一对看似情侣的白人老外和亚洲美女在谈论台湾上海，似乎是评价旅行后的感受。该走了，清迈。下一次，我还想去芭提雅！","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"泰国","slug":"泰国","permalink":"https://lchml.com/tags/%E6%B3%B0%E5%9B%BD/"},{"name":"清迈","slug":"清迈","permalink":"https://lchml.com/tags/%E6%B8%85%E8%BF%88/"},{"name":"曼谷","slug":"曼谷","permalink":"https://lchml.com/tags/%E6%9B%BC%E8%B0%B7/"}]},{"title":"芭提雅，你的不夜城 —— Thailand（上）","slug":"thailand","date":"2018-02-07T16:00:00.000Z","updated":"2022-05-12T06:10:34.958Z","comments":true,"path":"life/thailand/","link":"","permalink":"https://lchml.com/life/thailand/","excerpt":"虽然更远的巴厘岛也去了，但去过泰国好像没到过东南亚一般，所以我们就规划了这次泰国旅行。","text":"虽然更远的巴厘岛也去了，但去过泰国好像没到过东南亚一般，所以我们就规划了这次泰国旅行。 行程安排是我家哥哥做的，每次都是他辛苦规划，才让我们有机会一起走的更远。其实我不爱流水账式的记录一次旅行，更喜欢简单记录下自己旅途中印象深刻的人和事，所以下文只能是个旅行的梗概，但也许某些小细节能带给你触动。 机票：杭州直飞曼谷 ThaiLion Air曼谷飞清迈 NokAir清迈直飞杭州 AirAsia 汽车：曼谷到清迈 淘宝定的12座商务车，包车清迈到曼谷 飞猪定的12座商务车，拼车 初到曼谷，是凌晨3点多，我们顺利坐上了去往芭提雅的车，途经7号和3号公路，在夜色中奔向目的地。 芭提雅（Pattaya），是中南半岛南端的泰国一处著名海景度假胜地。芭提雅属于泰国春武里府（Chon Buri)，距离曼谷东南方154公里，沿泰国7号高速公路驾车车程为1小时20分。规划中的曼谷机场至芭提雅高铁轻轨线预计在2018年建成，届时两地车程将缩短为20分钟。芭提雅是一个小渔村，由于越战期间美国大兵为了寻欢作乐，在此修建起了度假中心，才成就了今天的芭提雅。这就解释了为什么这里各色酒吧很多。小城很小，一共就三条平行的大道，其中的海滨大道是沿海而建的， 是最早建成也是芭提雅最漂亮的大道。 然后是芭提雅2路，有很多的露天酒吧，如今刚建成的芭提雅3路基本还没有形成气候。主要交通工具是双条车。运行范围也只在核心景区这一带，即招即停类似公交。 2个多小时的车程从曼谷到了芭提雅，这个海滨小镇，清晨酒店不能入住只能到处转转，觉得白天的芭提雅简直和任何一个国内的小城都没有太多区别，更多的是前一夜的烧烤小摊夜市留下的痕迹，30多度的天气道路上还散发着些许食物残渣的腥臭味。建筑设施、城市道路的建设妥妥的东南亚感，有点让人难以接受。 风土人情我们入住了紧邻希尔顿的一家四星酒店（上图中的Page 10）。酒店交通便利，无论是到海边还是去酒吧夜市都很方便，最难得的是无论外边多喧闹，你总是可以在这家酒店里找到一丝宁静。入住的几乎是清一色的白人，酒店无论是布置还是早餐也都西方化，但是让人觉得非常惬意。 整个泰国便利店，小摊小贩和夜市遍地，芭提雅也是一样。唯一不同的是芭提雅遍地是白人，他们有些长久定居有些来这里小住一月半月，他们来这里消费娱乐尽情释放自己，在这里美元以1:35的比例兑换泰铢是绝对的低消费休闲场所，这里有夜生活，有酒吧夜店，有廉价的泰式按摩，更有阳光海滩和海鲜，简直是放飞自我的乐园。 来芭提雅至少要待够一整天，有白天有黑夜。白天是普普通通的小镇，街头随处可见的白人老头和往来的双条车，人们穿在短裤拖鞋，有美味的泰国菜馆，菠萝饭、咖喱蟹、大象啤酒，海鲜很便宜也很新鲜。夜幕降临，到处是五颜六色的小彩灯，夜市摆起来，烧烤吃起来，啤酒吧嗨起来，AGOGO也鲜活起来。老外们走进一家家agogo寻觅理想的猎物，看中了可以带走，看不中就只在店内消费一下。街头出现神奇的搭配，被笑称大白鸭配乌骨鸡。长长的街道两边是密集的massage和tattoo店，这是一个已经被老外深度开发的地方。 这是一个光怪陆离的国度，和我们的生活大相径庭，时时刻刻提醒你这真的是一场旅行。 上图是芭提雅二路街景，是主要交通道路，和它平行的芭提雅海滩路（下图），类似杭州的南山路，滨海，是游客最多的地方，也是去往码头的必经之路。 说起泰国，人们往往认为是一个到处都是人妖的国度。而事实上人妖并不是你想见就能见，而是非常受保护的。由于泰国政府规定不允许在诸如曼谷这样的大城市公开表演人妖秀，因此也只有在芭提雅才能看到正规华美的正宗人妖秀了。 芭提雅有正规的人妖秀，也有偏色情的秀，街头有很多景点售票处就放出大大的广告，可以直接买票。我们欣赏了最大的蒂芙尼人妖秀。可以说票价绝对是值了，因为部分台柱几位人妖真的是很美，无论是身材比例还是面向，都能让女人艳羡。所以不断地有游客和人妖合照，不过小费近年来也是水涨船高让人却步。每天晚上artists会有三场表演，每场结束会有一刻钟时间合影，这也是他们创收的机会。据说人妖生命都不长久，往往是和公司签下终生合同，当他们无法登台表演以后公司需要对他的一辈子负责。这真的是一份艰辛而艰难的工作。 格兰岛芭提雅的海其实不够吸引人，可能因为离岸太近，人太多，因此海水不显干净颜色也很一般。离芭提雅最近的格兰岛，只需要乘坐轮渡即可到达，每班每人30泰铢。同行的是很多白人，印象深刻的是一个三口之家，妈妈是标准的美剧里的女主脸，孩子是典型的洋娃娃，让我不由得偷拍了几张。轮渡到达处的Sang Wan Beach是中国人聚集地，也是各种水上项目的场所，人多嘈杂，我们选择了坐双条车深入岛内的其他海滩。 三口之家一路径直去了格兰岛最深远的一处海滩Nual Beach，而我们在最大的Samae Beach下了车。事实证明我们的选择是正确的，这是格兰岛最开阔也是最干净的一处海滩。从景区的管理来看，泰国人还是比较善良和易于管理的，并没有漫天要价。这点也让我对芭提雅留下了好印象。 据说日光浴是未来白领最奢侈的礼物，所以这一刻感觉自己很富有，有木有？ By Motorbike在芭提雅的最后一天，在每天的massage、夜市和海鲜之后，我们决定走出核心区去看一看巴东巴南地区的景色。由于公共交通不太便利，打车又实在太贵，所以贫穷发散了我们的想象力。我们选择租用摩托车一天。摩托车是当地最普遍的交通工具，外形酷似我们的电瓶车但是烧油。汽油比国内要便宜，但租用摩托车需要国际驾照，好在酒店的bellboy帮我们协调了一下顺利租到了车，大约是300泰铢一天。就这样我们骑着摩托在芭提雅和附近的城市狂飙了100多公里，沿途看到很多白人也在骑行，看到了很多不一样的风景。不得不说，空气真的很好，还顺路参观了四方水上市场和七珍佛山。即使是深入农村，最多的也还是佛教寺庙。寺庙旁的湖中养了好多鲶鱼，还有很多鸽子，小摊小贩会贩卖一些劣质的面包供来祭拜的人喂鱼和鸽子。似乎在泰国，鲶鱼和鸽子在佛教有一定的寓意。这里的鸽子和在日本京都寺庙前看的到鸽子是同一种。 这一趟的结论就是：芭提雅除了景区灯红酒绿，其他真的是完完全全的第三世界。 小插曲：出发泰国当天打了顺风车去往萧山机场，接单的是位飞机检修工程师。在我们看来这是个稀有且神奇的行业，每周工作20小时，休息的时间远远大于工作时间，简直是我们这种加班狗梦寐以求的职业。但据他描述，由于经常夜班因此休息时间也多用来调整和恢复了，所以并没有我们艳羡的那么好。我们一路聊得很尽兴，他还和我们介绍了一些航空公司的情况和这个领域内的就业情况。感觉打开了新天地，职业很多，世界很大。也许旅行的意义就在于此，去认识不同的人，听他们聊自己的生活工作，去不同的地方感受不一样的文化，为自己找一个出口感受生命存在的意义。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"泰国","slug":"泰国","permalink":"https://lchml.com/tags/%E6%B3%B0%E5%9B%BD/"},{"name":"芭提雅","slug":"芭提雅","permalink":"https://lchml.com/tags/%E8%8A%AD%E6%8F%90%E9%9B%85/"}]},{"title":"Webcat文档","slug":"webcat-doc","date":"2017-11-23T12:00:00.000Z","updated":"2022-05-12T06:11:15.560Z","comments":true,"path":"technology/webcat-doc/","link":"","permalink":"https://lchml.com/technology/webcat-doc/","excerpt":"Webcat是一个基于netty的简单、高性能服务端框架，目前提供http和websocket两种协议的快速开发模式。webcat采用spring进行对象管理，因此工程需要依赖spring框架，Github地址。","text":"Webcat是一个基于netty的简单、高性能服务端框架，目前提供http和websocket两种协议的快速开发模式。webcat采用spring进行对象管理，因此工程需要依赖spring框架，Github地址。 下载源代码后，可以直接运行WebcatServerTest启动http和websocket服务，然后通过pytest文件夹中的两个python脚本对服务进行测试。 HTTP Server 使用在spring的配置中,加上对webcat的package扫描: 1&lt;context:component-scan base-package=&quot;com.lchml.webcat&quot;/&gt; 设置端口并启动: 12345public static void main(String[] args) throws WebcatStartException &#123; HttpServer httpServer = context.getBean(WebcatHttpServer.class); httpServer.setPort(8080); httpServer.start();&#125; 添加自己的controller: 1&lt;context:component-scan base-package=&quot;com.lchml.test&quot;/&gt; 123456789101112131415161718@HttpController(path = &quot;/test&quot;)public class TestController &#123; @HttpRequestMapping(path = &quot;/hello&quot;, consumes = &#123;&quot;text/plain&quot;&#125;) public String testHello() &#123; return &quot;hello webcat&quot;; &#125; @HttpRequestMapping(path = &quot;/bodytest&quot;, method = &#123;ReqMethod.POST&#125;) public String testBody(@ReqBody String body) &#123; return &quot;hello webcat &quot; + body; &#125; @HttpRequestMapping(path = &quot;/redirect&quot;, method = &#123;ReqMethod.GET&#125;) public void testRedirect(FullHttpResponse response) &#123; ResponseUtil.redirect(response, &quot;http://lchml.com&quot;); &#125;&#125; logEnable，默认会打开所有websocket请求的日志。 logResponse，默认日志中不会输入response内容。 defaultProduce，默认返回content-type为application&#x2F;json;charset&#x3D;utf-8。 12345&lt;bean class=&quot;com.lchml.webcat.config.WebcatHttpConf&quot; id=&quot;webcatConf&quot;&gt; &lt;property name=&quot;logEnable&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;logResponse&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;defaultProduce&quot; value=&quot;application/json;charset=utf-8&quot;/&gt;&lt;/bean&gt; Websocket Server 使用在spring的配置中,加上对webcat的package扫描: 1&lt;context:component-scan base-package=&quot;com.lchml.webcat&quot;/&gt; 设置端口，设置连接初始化和断开的监听回调并启动: 1234567891011121314151617public static void main(String[] args) throws WebcatStartException &#123; WebcatWsServer wsServer = context.getBean(WebcatWsServer.class); wsServer.setPort(8081); wsServer.setChannelConnectListener(new ChannelConnectListener() &#123; @Override public void connect(ChannelInfo channelInfo) &#123; channelInfo.addAttr(&quot;connectTime&quot;, System.currentTimeMillis()); System.out.println(channelInfo.getClientIp() + &quot; connect&quot;); &#125; &#125;); wsServer.setChannelDisconnectListener(new ChannelDisconnectListener() &#123; @Override public void disconnect(ChannelInfo channelInfo) &#123; System.out.println(channelInfo.getClientIp() + &quot; disconnect&quot;); &#125; &#125;); wsServer.start();&#125; 添加自己的controller: 1&lt;context:component-scan base-package=&quot;com.lchml.test&quot;/&gt; 12345678@WsController(path = &quot;/test&quot;)public class TestWsController &#123; @WsRequestMapping(path = &quot;/hello&quot;) public Object testHello(String name, WsContext ctx) &#123; return &quot;hello webcat &quot; + name + &quot; from &quot; + ctx.getCi().getClientIp(); &#125;&#125; heartbeat，默认心跳为15s，超过15s没有收到客户端心跳则视为连接断开。 useProxy，默认没有使用代理，则直接使用RemoteAddress作为客户端ip，如果设置为true，会从路由信息中获取真实客户端ip地址。 wsPath，默认path为&#x2F;webcat，可以自行修改。 logEnable，默认会打开所有websocket请求的日志。 logResponse，默认日志中不会输入response内容。 123456&lt;bean class=&quot;com.lchml.webcat.config.WebcatWsConf&quot; id=&quot;webcatConf&quot;&gt; &lt;property name=&quot;heartbeat&quot; value=&quot;15&quot;/&gt; &lt;property name=&quot;useProxy&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;logResponse&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;logEnable&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt; websocket模式，采用json格式做协议交互，格式如下： 123456&#123; &quot;path&quot;: &quot;/test/hello&quot;, // 请求的path，对应controller中的path &quot;mid&quot;: 1, // 请求的序号，用于对应请求和回包 &quot;version&quot;: 0, // 版本号，可不用 &quot;params&quot;: &#123;&quot;name&quot;: &quot;holyshit&quot;&#125; // 业务的参数&#125; 所有的请求最后都会被组装为WsContext对象： 12345678910111213public class WsContext &#123; private String path; private ChannelInfo ci; private int mid; private int version; private Channel channel; private Map&lt;String, Object&gt; params;&#125; 其中，ChannelInfo中会包含请求方的客户端ip，并且可以在ChannelConnectListener中自定义其他属性，params默认会根据Controller中方法定义映射到对应的参数上。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"},{"name":"Webcat","slug":"Webcat","permalink":"https://lchml.com/tags/Webcat/"},{"name":"HTTP","slug":"HTTP","permalink":"https://lchml.com/tags/HTTP/"},{"name":"websocket","slug":"websocket","permalink":"https://lchml.com/tags/websocket/"}]},{"title":"java虚拟机 - 并发","slug":"jvm3","date":"2017-11-18T03:07:00.000Z","updated":"2022-05-12T06:07:01.835Z","comments":true,"path":"technology/jvm3/","link":"","permalink":"https://lchml.com/technology/jvm3/","excerpt":"由于当今计算机的发展现状，计算机的存储设备（内存、磁盘）与CPU的运算速度有好几个数量级的差距。","text":"由于当今计算机的发展现状，计算机的存储设备（内存、磁盘）与CPU的运算速度有好几个数量级的差距。 因为计算机不可能仅靠寄存器来完成所有运算任务，为了更加高效的利用运算能力，现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：把运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。除了增加了高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化。 Java内存模型不同架构的物理机可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，它与硬件的内存模型有很大的相似之处。Java内存模型规定，所有变量都存储在主内存中（类似操作系统的住内存），每条线程还有自己的工作内存（类似于高速缓存）。与处理器的乱序优化类似，Java虚拟机的即时编译中也有类似的指令重排序优化。这里所讲的主内存、工作内存与前面所说的java堆，栈，方法区等是不同维度的内存划分，两者之间并没有关系。 Java内存模型中定义了8中操作来完成内存间的交互操作：lock、unlock、read、load、use、assign、store、write。如果要把一个变量从主内存复制到工作内存，那就要顺序的执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序的执行store和write操作。Java内存模型只要求上诉两个操作必须是按顺序执行的，而没有保证是连续执行的。因此在read和load之间、store和write之间是可能插入其他指令的。 关键字wolatile是Java虚拟机提供的最轻量级的同步机制。当一个变量定义为volatile以后，它将具备两种特性： 第一是保证次变量对所有线程的可见性 第二是禁止指令重排序优化 这里可见性是指当一个线程修改了这个变量的值，新值对于其他线程是可以立即得知的。要注意一点，volatile的线程可见性并不能保证volatile变量的并发运算是安全的。由于Java里的运算并非原子操作，因此volatile变量的运算在并发下一样是不安全的。 并发问题实质上就是，java内存模型在并发过程中如何处理原子性、可见性和有序性的问题。 Java线程线程的实现主要有三种方式：使用内核线程实现、使用用户线程实现、使用用户线程加轻量级进程混合实现。内核线程直接由操作系统内核通过操纵调度器进行调度，程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（LWP），轻量级进程与内核线程之间是1:1的关系。用户线程与进程是N:1的关系。用户线程加轻量级进程混合实现是N:M的关系。 在Windows和Linux平台上，Java都是使用一对一的线程模型实现的，一条java线程就映射到一条轻量级进程中。java的线程调度采用抢占式线程调度。Java语言定义了线程的5中状态：新建、运行、等待（无限期等待、有限期等待）、阻塞、结束。 线程安全定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。 对于java中各种操作共享的数据可以分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容、线程对立。 实现线程安全的方法，大致可以分为以下几类： 互斥同步。这是最常见的并发安全手段，在Java中可以通过synchronize、ReentrantLock来实现。ReentrantLock相比synchronize主要增加了以下功能：等待可中断、可实现公平锁，以及锁可以绑定多个条件。 非阻塞同步。互斥同步会因为线程阻塞和唤醒带来性能问题，因此互斥同步也称为阻塞同步，也就是悲观锁。而非阻塞同步则是采用了乐观锁的方式。通俗的说，就是先进行并发操作，如果没有其他线程竞争就直接成功。、如果共享数据有竞争，产生了冲突，那就再采取补偿措施（通常是不断的重试，直到成功为止），这种并发策略的实现不需要把线程挂起，因此成为非阻塞同步。其中典型的例子就是AtomicInteger类的incrementAndGet操作，它的实现非常简单，JDK源码如下： 123456789public final int incrementAndGet() &#123; for(;;) &#123; int current = get(); int next = current + 1; if (compareAndSet(current, next)) &#123; return next; &#125; &#125;&#125; 其中compareAndSet操作是从JDK1.5之后通过sum.misc.Unsafe类才支持的CAS指令。 无同步方案。如果一个方法本来就不涉及共享数据，那就不需要同步措施。主要分为两类：可重入代码和线程本地存储。如java中的ThreadLocal对象。 在JDK1.5到1.6的版本中，一个重要的改进就是高效并发。HotSpot虚拟机团队花费了大量的精力去实现各种锁的优化技术，如自旋锁、自适应自旋、锁消除、锁粗化、轻量级锁和偏向锁等。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://lchml.com/tags/JVM/"}]},{"title":"java虚拟机 - Class","slug":"jvm2","date":"2017-11-15T03:07:00.000Z","updated":"2022-05-12T06:00:07.504Z","comments":true,"path":"technology/jvm2/","link":"","permalink":"https://lchml.com/technology/jvm2/","excerpt":"相信大家都听过一句话：“计算机只认识0和1”，因此我们写的程序要经过编译器翻译成0和1构成的二进制格式才能有计算机执行。而随着计算机的发展，特别是大量建立在虚拟机上的程序语言出现，将程序编译成二进制已经不是唯一的选择，越来越多的语言选择了与操作系统无关、平台中立的格式作为编译后的存储格式。","text":"相信大家都听过一句话：“计算机只认识0和1”，因此我们写的程序要经过编译器翻译成0和1构成的二进制格式才能有计算机执行。而随着计算机的发展，特别是大量建立在虚拟机上的程序语言出现，将程序编译成二进制已经不是唯一的选择，越来越多的语言选择了与操作系统无关、平台中立的格式作为编译后的存储格式。 在1997年第一版Java虚拟机规范发布时就描述了：未来，我们会对Java虚拟机进行扩展，以便更好的支持其他语言在jvm上运行。如今，除了Java以外已经发展出了一大批可以在jvm上运行的语言，如Clojure、Groovy、JRuby、Jython、Scala等。而jvm实现语言无关性的基础就是虚拟机和字节码存储格式。Java虚拟机不与任何语言绑定，它只与“Class文件”这种特定的二进制文件格式有关。Class文件中包含了Java虚拟机指令集和符号表以及其他辅助信息。Java虚拟机不关系Class文件的来源，因此任何语言只要编译成符合Java虚拟机的规范的Class文件，都可以在jvm上运行。 Class文件格式每一个Class文件都对应着唯一一个类或接口的定义信息，但反过来，类或接口并不一定都得定义在Class文件中，也可以通过类加载器直接生产。Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格的按照顺序紧凑排列，没有任何分隔符，使得文件几乎没有空隙存在。jvm规范规定，Class文件采用类似C语言结构体的伪结构体来存储数据，这种伪结构体中只有两种数据类型：无符号数和表。u1，u2，u4，u8分别代表一个字节，2个字节，4个字节和8个字节的无符号数。表由多个无符号数或其他表作为数据项构成，所有表都已_info结尾。 所有Class文件的头4个字节称为“魔数”——0xCAFEBABE（咖啡宝贝），紧接着的第5个和第6个字节是此版本号，第7个第8个字节是主版本号。高版本的jdk可以兼容以前版本的Class文件，但不能运行以后版本的。 紧接着主版本号之后的是常量池入口，常量池之后紧接着的两个字节是访问标志（access_flag），用于识别一些类或接口的访问信息，包括：这个Class是类还是接口（ACC_INTERFACE），是否定义为public（ACC_PUBLIC），是否定义为abstract（ACC_ABSTRACT），是否声明为final（ACC_FINAL），是否是一个注解（ACC_ANNOTATION）等。在访问标志之后的是类索引、父类索引和接口索引集合。再接着的是字段表集合，方法表集合，属性表集合。 Class加载一个类在虚拟机中的生命周期包括以下7个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）。其中验证、准备、解析3个阶段统称为连接（Linking）。注意：这些过程会按部就班的”开始“，但完成过程会相互穿插。 加载加载过程主要完成3见识： 1、通过一个类的全限定名来获取定义此类的二进制字节流。 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 由于虚拟机规范中并没有规定二进制字节流一定要从Class文件中获取，因此虚拟机的实现中可以以各种方式来获取，比如运行时计算生成。这就是我们常用的动态代理技术的原理。 验证验证阶段包括4个检验：文件格式验证，元数据验证，字节码验证，符号引用验证。 准备准备阶段是正式为类变量分配内存，并设置类变量初始值的阶段。这些类变量使用的内存都将在方法区中进行分配。注意，这里说的初始值”通常情况“下是指数据类型的零值，而不是程序中赋予的初始值。如一个类变量定义为: 1public static int value = 100; 那么value在准备阶段过后，它的初始值是0，而不是100，等到下面的初始化过程时才会将value赋值为100。如果它被final修饰，那么编译时会变成一个常量，在准备阶段就赋值为100。 解析解析阶段包括4个方面：类或接口的解析，字段解析，类方法解析，接口方法解析。 初始化初始化是类加载阶段的最后一步，java虚拟机规范规定了有且只有以下5中情况必须立即对类进行”初始化“（加载、验证、准备需要在此之前开始）： 1、遇到new、getstatic、putstatic或invokestatic这4个字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的常见java代码是：使用new关键字实例化对象、读取或者设置一个类的静态字段（除了被final修饰的，被final修饰的会在编译期把结果放入常量池）、以及调用一个类的静态方法。 2、使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 3、当初始化一个类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 4、当虚拟机启动时，用户需要指定一个要执行的主类（main class），虚拟机会先初始化这个类。 5、当使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 只且只有这5中情况的类引用会触发初始化，称为主动引用。除此之外的所有类引用都不会触发初始化，称为被动引用。 类加载器类加载器是Java语言的一项创新，他也是Java语言流行的重要原因之一，它已经成为Java技术体系中的一块重要基石。类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类和这个类本身一同确立其在Java虚拟机中的唯一性。也就是说，要比较两个类是否”相等“，只有在两个类是同一个类加载器加载的提前下才有意义。这里的相等包括了：equals、isAssignableFrom、isInstance、instanceof等操作。 双亲委派模型从Java虚拟机的角度，只有两种类加载器，一种是启动类加载器（Bootstrap ClassLoader），这是由C++实现的，是虚拟机的一部分，另一种就是其他类加载器，由java语言实现，独立于虚拟机外部，且全部都继承自java.lang.ClassLoader。 从Java开发人员的角度，可以分为：启动类加载器，扩展类加载器，应用程序类加载器，自定义类加载器。他们以双亲委派模型进行工作：双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有加载请求都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成加载请求（它的搜索范围内没有找到所需要的类）时，子加载器才会尝试自己去加载。双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），例如Object类，它被放在rt.jar中，因此无论哪个类加载器要加载这个类，最后都会委托给最顶端的启动类加载器进行加载，因此Object不管在任何类加载器环境中都是同一个类，相反如果没有使用双亲委派模型，那么Object可能变成很多不同的类，从而导致程序混乱。 双亲委派模型逆向，当基础类需要调用回用户的代码时，怎么办？比如JNDI、JDBC、JCE等服务，为此java设计团队引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过Thread.setContextClassLoader()进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器以后，就可以实现父类加载器委托子类加载器去完成类加载的动作，也就是实现了双亲委派模型的逆向操作。 最后还有一种不符合双亲委派模型的类加载方式，为了实现代码热替换，模块热部署而产生的OSGi，它自定义了类加载实现机制。每个程序模块（OSGi中的Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同它的类加载器一起换掉以实现代码的热替换。 Java方法调用Class文件在编译过程中没有传统编译的连接步骤，因此一切方法的调用在Class文件中存储的都只是符号引用，而不是方法实际运行时内存布局中的入口地址。这个特性给Java带来了强大的动态扩展能力，但是也使得Java的方法调用变得复杂，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。 所有方法调用中的目标方法在Class文件中都是一个常量池的符号引用，在类加载的解析阶段，会将其中一部分符号引用转换为直接引用。而这种转换的前提是：方法在程序真正运行之前就有一个可以确定的调用版本，并且这个方法的调用版本在运行期是不可变的。也就是说，调用目标在编译器进行编译的时候就已经确定下来。在Java语言中符合这个要求的方法，主要包括“静态方法”和“私有方法”两大类。与只对应的是，在Java虚拟机中提供了5条方法调用的字节码指令： invokestatic：调用静态方法 invokespecial：调用实例构造方法，私有方法和父类方法 invokevirtual：调用所有虚方法 invokeinterface：调用接口方法，会在运行时在确定一个实现此接口的对象 invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法 只要能被invokestatic和invokespecial指令调用的方法，都是可以在解析阶段确定唯一的调用版本的方法，符合这个条件的有：静态方法、私有方法、实例构造器、父类方法四种。他们在类加载阶段就会把符号引用转换为直接引用。这些方法称为非虚方法，其他方法称为虚方法（final方法除外）。这种方法调用称为解析调用（Resolution）。 除了解析调用，还有一种分派调用（Dispatch），分派调用可以分为静态分派和动态分派两种。先来看一个静态分派的例子： 1234567891011121314151617181920212223242526 public class Test &#123; static abstract class Human &#123;&#125; static class Man extends Human &#123;&#125; static class Woman extends Human &#123;&#125; public void sayHello(Human human) &#123; System.out.println(&quot;Hello human!&quot;); &#125; public void sayHello(Man man) &#123; System.out.println(&quot;Hello man!&quot;); &#125; public void sayHello(Woman woman) &#123; System.out.println(&quot;Hello lady!&quot;); &#125; public static void main() &#123; Human man = new Man(); Human woman = new Woman(); Test t = new Test(); t.sayHello(man); t.sayHello(woman); &#125; &#125;&#125; 代码的运行结果是： 12hello human!hello human! 首先我们来明确两个重要的概念，在如下代码中： 1Human man = new Man(); Human称为变量的静态类型（Static Type），或者称为外观类型，后面的Man则称为变量的实际类型（Actual Type），静态类型是在编译器可知的，不会被改变。而实际类型变化的结果在运行期才可确定，编译器编译时并不知道一个对象的实际类型是什么。因此上面的代码中，编译器在编译器就根据变量的静态类型选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main方法里的两条invokevirtual指令参数中。所有依赖静态类型来定位方法执行版本的分配就称为静态分派。静态分配的典型的应用就是重载（Overload）。 与静态分派对应的还有一种动态分配，它和多态的另一个重要体现——重写（Override）有着密切的关系。这里就不举例说明了，只说明其实现原理：invokevirtual指令的多态查找过程，invokevirtual指令的运行时解析过程步骤： 1、找到操作数栈顶的第一个元素所指向的对象实际类型，记为C 2、如果在类型C中找到与常理中描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回该方法的直接引用，结束调用；如果不通过则返回java.lang.IllegalAccessError异常。 3、否则，按照继承关系从下往上一次对C的各个父类进行第2步操作。 4、如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 invokevirtual指令执行的第一步就是在运行期确定接受者的实际类型，这个过程就是java语言中方法重写的本质。我们把这种在运行期间根据实际类型确定方法执行版本的分派过程称为动态分派。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://lchml.com/tags/JVM/"}]},{"title":"java虚拟机 - 内存","slug":"jvm1","date":"2017-11-12T03:07:00.000Z","updated":"2022-05-12T06:00:10.906Z","comments":true,"path":"technology/jvm1/","link":"","permalink":"https://lchml.com/technology/jvm1/","excerpt":"最近花了一周时间把《深入Java虚拟机》这本书看完了，虽然说看之前，对jvm已经基本了解了。但是看书的过程中依然会有很多恍然大悟的时刻。很多平时使用过的功能特性，在看书的过程中才知道原来背后的原理是这样的。因此，平时通过Google我们很大程度上只是“知其然”，而要做到“知其所以然”确实还需要从最基础开始学习。","text":"最近花了一周时间把《深入Java虚拟机》这本书看完了，虽然说看之前，对jvm已经基本了解了。但是看书的过程中依然会有很多恍然大悟的时刻。很多平时使用过的功能特性，在看书的过程中才知道原来背后的原理是这样的。因此，平时通过Google我们很大程度上只是“知其然”，而要做到“知其所以然”确实还需要从最基础开始学习。 温故而知新，这里对看书过程中的一些心得做一个总结。 全书内容，分为五大部分，第一部分简单的介绍了Java已经JVM的历史，并展示了如何自己编译JDK。想要学习jvm，通过自己编译jvm和读jvm的源码，确实是最直接的办法，当然这个学习过程会比较困难和耗时。所以我只是编译了jdk，并没有去读源码。 内存组成第二部分是jvm的内存管理机制，主要包括了jvm的内存组成，内存管理（HotSpot虚拟机）。这一部分内容是java程序员面试中最经常遇到的问题，也是考验一个java程序员基本功的重要指标。首先是内存的组成，相信大部分程序员都知道java内存分为堆和栈。但这只是一个非常粗略的描述，jvm在运行过程中涉及到的内存分为以下部分：其中，蓝色部分为所有线程共享的内存，绿色部分为线程隔离内存。 直接内存，它并不是jvm内存的一部分，在java虚拟机规范中也没有定义该区域。但这也是经常会被使用的一块内存，它使用native函数库直接分配的堆外内存，不会受到jvm堆大小的限制，但是会收到本机总内存大小的限制。由于它不是jvm内存的一部分，所以GC当然也不会对它进行回收，因此这块内存需要由程序自行管理，当内存分配失败时会出现OutOfMemoryError。 程序计数器，用于存储当前线程执行字节码指令的地址，如果执行的是native方法则为空。每个线程都需要有一个独立的程序计数器，因此他是线程私有的内存。该区域没有定义任何OutOfMemoryError。 虚拟机栈，用于存储执行java方法时创建的栈帧，一个栈帧包括了局部变量，操作数栈，动态链接，方法出口等信息，每个方法的调用，就对应着一个栈帧在虚拟机栈中的入栈到出栈的过程。当执行方法请求的栈深度大于虚拟机允许的栈深度时，就会抛出StackOverflowError。 本地方法栈，与虚拟机栈一样，只是它用于执行native方法，在HotSpot虚拟机中，它与虚拟机栈合并为同一块内存。可以通过-Xss参数指定大小，同样也会抛出StackOverflowError。 堆，对是虚拟机中最大的一块内存，被所有线程共享，几乎所有对象实例都在这里分配内存（为什么说是几乎呢？由于在JIT的编译优化、逃逸分析等技术，会发生栈上分配、标量替换等，使得对象不再绝对的分配在堆内存中）。这块内存是GC管理的主要区域。从GC角度，它可以分为新生代和老年代，新生代又可以分为Eden空间，FromSurvivor和ToSurvivor空间，可以通过-XX:SurvivorRatio设置Eden与Survivor的比例，默认为8:1:1。从内存分配的角度，java堆中可能划分出多个线程私有的分配缓冲区（TLAB）（与物理机上CPU寄存器缓存内存数据同样的原理）。可以通过-Xmx，-Xms指定堆的最大和最小，通过-Xmn可以指定其中新生代的大小，新生代默认为堆大小的3&#x2F;8。该区域会发生OutOfMemoryError。 方法区，在jdk1.6之前的HotSpot虚拟机中又称为永久代，从jdk1.7开始已经放弃。它用于存储已被jvm加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。通过-XX:PermSize，-XX:MaxPermSize来指定下限和上限。这个区域在jdk8中已经被取消，其中的数据一部分被存到堆中，还一部分被存到称为Metaspace的空间中，这个区域的内存不在使用jvm内存，而是直接使用系统内存，默认可以无限扩展，直到耗尽系统内存，可以通过-XX:MaxMetaspaceSize来指定上限。会发生OutOfMemoryError。 运行时常量池，是方法区的一部分，用于存储编译期生成的各种字面量和符号引用，这部分数据将在类加载后进入方法区的运行时常量池中。由于运行时常量池的内容不一定是编译期才能产生，在运行过程中也可能将新的常理放入池中，比如String.intern()方法。会发生OutOfMemoryError。 内存管理内存管理可以分为两块内容，内存管理和内存回收。前面我们说过Java程序在创建对象的时候会把对象分配在堆中，在使用时需要通过栈上的reference数据来找到堆上的具体对象。目前对象的访问方式有两种，句柄和指针。句柄访问方式，java堆中会划分出一块内存用来作为句柄池，栈上reference中存储的就是句柄的地址。而句柄中又包含了实例数据与类信息各自的地址信息。指针访问方式，reference中存储的直接就是对象地址，对象地址中又包含了类信息的地址。目前HotSpot虚拟机使用的第二种，指针访问的方式。 GC，java虚拟机中最重要的功能之一。想要做到内存自动回收，那就需要知道一块内存什么时候可以被回收，也就是需要判断一个对象是否还活着。通常大家都知道的一种办法是：引用计数法。它有很多著名的应用案例，如FlashPlayer、Python等等都是用引用技术算法。但是，目前主流的java虚拟机里面都没有选用引用技术算法来做内存管理，主要是因为它很难解决对象之间的相互循环引用问题。在主流的jvm中都是通过可达性分析算法来判断对象是否存活。为了更灵活的描述对一个对象的引用，jdk1.2之后把引用分为了4种程度。强引用：也就是我们通常使用的引用方式，只要还存在强引用，垃圾收集器就永远不会回收掉被引用的对象。软引用：用来描述有用但非必需的对象，在系统将要发生内存溢出之前，会将软引用的对象列为回收范围之中进行第二次回收。如果这次回收之后还是没有足够的内存，才会抛出内存溢出。SoftReference弱引用：用来描述非必需的对象，弱引用的对象只能活到下一次垃圾收集之前，当垃圾收集器工作时，无论内存是否够用，弱引用都会被回收掉。WeakReference虚引用：又称为幽灵引用，无论是否存在虚引用都会被回收，虚引用的唯一意义是当这个对象被回收时会收到一个系统通知。PhantomReference GC算法：标记-清除算法：最基础的收集算法，主要缺点：标记和清除的效率不高，清除后会产生大量内存碎片。复制算法：将内存分为两块，每次只使用其中一块，当一块用完了，就将还存活的对象复制到另一块上，然后把这块空间全部清除，这样就避免了内存碎片的问题。年轻代中的Eden和Survivor就是使用该算法。这里有一个“分配担保”的机制，当一块Survivor没有足够的空间存放上一次gc留下的对象时，可以通过分配担保直接进入老年代。标记-整理算法：当对象存活率较高时，复制算法会进行很多的对象复制操作，效率比较低。同时复制算法还会浪费50%的空间。所以老年代一般不能直接采用复制算法，而是采用标记整理算法，标记过程与标记清除算法一样，但标记完后不会直接回收对象，而是让所有存活着的对象都向一端移动，然后清理掉边界以外的内存。这样就解决了内存碎片的问题。 GC策略：Serial收集器：单线程收集器，进行GC时需要Stop The World。通常用于Client模式。ParNew收集器：相当于Serial的多线程版本。通常用作Server模式下新生代的收集器。主要是因为出了Serial只有它可以和CMS配合工作。用-XX:UseParNewGC来指定。它是CMS的默认新生代收集器。Paralle Scavenge收集器：新生代收集器，与ParNew的不同之处在于，它关注的重点是吞吐量，也就是可以尽量降低垃圾收集占用CPU时间的比例。适合于在后台运算，而不需要太多交互任务的情况。使用-XX:+UseParallelGC来指定，使用-XX:MaxGCPauseMillis指定最大停顿时间，-XX:GCTimeRatio指定吞吐量大小。无法与CMS共同工作。Serial Old收集器：Serial的老年代版本，主要用于client模式下的老年代，以及在server模式下，作为CMS并发失败时的后备方案使用。Paralle Old收集器：在jdk1.6之前，Paralle Scavenge只能搭配Serial Old作为老年代收集器。从jdk1.6之后，这个吞吐量优先的收集器才能更好的发挥作用。特别是在注重吞吐量以及CPU资源敏感的场合。CMS收集器：ConcurrentMarkSweep，并发标记清除。以获得最短的回收停顿时间为目标。标记一共分为4个步骤： 初始标记（initial） 并发标记（concurrent） 重新标记（remark） 并发标记（concurrent） 其中初始标记和重新标记两个过程仍然需要Stop The World，但这两个过程的时间非常短。并发标记的过程是可以与用户线程同时工作的。它的缺点是会占用一部分用户的CPU资源导致应用进程变慢，吞吐量降低。它无法回收浮动垃圾，可能会出现Concurrent Mode Failure，这时就会降级到Serial Old收集器来对老年代进行回收。还有，因为CMS是采用标记清除算法，所以会产生大量的内存碎片，为此，CMS提供了-XX:+UseCMSCompactAtFullCollection（默认开启）来指定当需要进行FullGC时，对内存碎片进行整理。由于内存整理是无法并发进行的，所以会导致停顿时间变长。因此又提供了另一个参数-XX:CMSFullGCsBeforCompaction指定经过多少次不压缩的FullGC后接着进行一次带压缩的FullGC（默认0）。G1收集器：Garbage First，是当前最新的垃圾收集技术。在使用G1收集器，内存不在按照新生代和老年代进行收集，而是将堆划分为多个大小相等的区域（Region），新生代和老年代不再是无力隔离的了。他们都是一部分Region的集合。G1会根据各个Region中垃圾堆积的价值大小维护一个列表，优先回收价值最大的Region（所以称为Garbage First）。 常用工具jps，常用参数：-m（输出启动时传递给main class的参数）、-l（输出main class的全名）、-v（输出虚拟机启动时的jvm参数）。jstat，用法[jstat -参数 pid millis times]，常用参数：-class(监视类装载卸载数量时间等)、-gc（gc相关统计数据）、-gcutil(百分比)、-gccapacity、-gccause、-gcnew、-gcold、-gcpermcapacity等。jmap，用来dump堆内存到文件。常用参数：-dump（如，jmap -dump:file&#x3D;xxx.dmp pid）、-heap（查看当前jvm堆信息）、-histo（堆中对象的统计信息）。jstack：生成当前jvm的线程快照，常用参数：-F（正常输出没有响应时，强制输出线程堆栈）、-l（除堆栈外，额外显示关于锁的信息）、-m（如果调用了native方法，可以显示C&#x2F;C++堆栈）。还有可视化工具jconsole和VisualVM","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://lchml.com/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://lchml.com/tags/GC/"}]},{"title":"GRPC丢包之路","slug":"grpc-trap","date":"2017-06-17T16:00:00.000Z","updated":"2022-05-12T06:01:00.024Z","comments":true,"path":"technology/grpc-trap/","link":"","permalink":"https://lchml.com/technology/grpc-trap/","excerpt":"GRPC是Google开源的一个高性能、跨语言的RPC框架，基于HTTP2协议，基于protobuf-3.x，基于Netty-4.x。","text":"GRPC是Google开源的一个高性能、跨语言的RPC框架，基于HTTP2协议，基于protobuf-3.x，基于Netty-4.x。 最近开发一个公司的游戏项目，采用分布式的服务器架构，内部服务之间均采用GRPC进行通信。但是在测试过程中发现一个重大的bug，偶现丢包。 前置信息：ServerA（作为grpc的client端）通过futureStub异步调用ServerB（作为server端）。 查看日志发现，client中有调用发送请求的日志，但server端却没有任何收到请求的日志。于是怀疑server在接收请求的过程中吃掉了异常，对整个过程加上try-catch，然而并没有任何发现，于是怀疑根本没有收到请求。通过tcpdump抓包后发现确实是client没发包到网络层，由此确定了是client端问题。 怀疑是grpc的futureStub有bug，于是在finally中加入future.get()打印出调用结果。结果一天下来一直没有发现任何丢包，”完美“。懵逼了，去掉finally中的future get以后又出现丢包。这个时候，直觉判断，由于调用futue.get()会block当前线程，所以不会出现丢包，而不block就会丢包。有种接近真相的感觉。检查代码后发现client端创建stub的时候没有指定线程池，grpc会默认使用当前线程，结合偶现的表现，觉得非常像是线程在异步发送的过程中被销毁导致。 然而，指定线程池以后，依旧发现丢包。无奈之下只有开始查看grpc源码，并打印出grpc的日志。在日志中发现了如下错误： 123----------------OUTBOUND--------------------[id: 0x7dee8b32, L:/10.82.7.14:60365 - R:/10.82.7.14:9001] RST_STREAM: streamId=4025, errorCode=8------------------------------------ 看到errorCode&#x3D;8，并结合grpc源码中对io.grpc.Status的定义： 12345/** * Some resource has been exhausted, perhaps a per-user quota, or * perhaps the entire file system is out of space. */RESOURCE_EXHAUSTED(8), 推断是由于系统文件句柄资源耗尽导致，查看服务器系统文件句柄限制为65535，而进程打开的限制远不止这么多。于是找sa将文件句柄限制改为100w，然后信心满满的重启了全部服务，重新进行测试。结果很快又发现了丢包，内心崩溃！ 由于当future.get()方法阻塞线程时，就不会出现丢包，无法重现。于是想到把futureStub改为stub，在保持异步的同时，通过observer回调来观察调用结果,这次在回调的onError方法中发现了如下异常： 12345678910111213CANCELLED,io.grpc.Status.asRuntimeException(Status.java:543), io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onClose(ClientCalls.java:395), io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:426), io.grpc.internal.ClientCallImpl.access$100(ClientCallImpl.java:76), io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.close(ClientCallImpl.java:512), io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl.access$700(ClientCallImpl.java:429), io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:544), io.grpc.internal.ContextRunnable.run(ContextRunnable.java:52), io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:117), java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142), java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617), java.lang.Thread.run(Thread.java:745 终于发现原来是这个call被grpc在底层cancel掉了。查代码发现原来上面的errorCode&#x3D;8是指http2的code定义： 123456/** * Mapped to call cancellation when sent by a client. * Mapped to CANCELLED when sent by a server. * Note that servers should only use this mechanism when they need to cancel a call but the payload byte sequence is incomplete. */CANCEL(8) 知道了是由于被cancel才导致的丢包，那么就要查找为什么会被cancel，由于grpc的stub调用是通过异步的线性执行器执行io.grpc.ClientCall。所以堆栈中无法看到整个调用过程，只能通过源码来看。不管是哪种stub的调用，最后都会走到ClientCalls.startCall()方法中，然后进ClientCallImpl.start()中，在这个方法中，可以看到与cancel有关的代码： 123456789101112131415161718if (context.isCancelled()) &#123; // Context is already cancelled so no need to create a real stream, just notify the observer // of cancellation via callback on the executor stream = NoopClientStream.INSTANCE; class ClosedByContext extends ContextRunnable &#123; ClosedByContext() &#123; super(context); &#125; @Override public void runInContext() &#123; closeObserver(observer, statusFromCancelled(context), new Metadata()); &#125; &#125; callExecutor.execute(new ClosedByContext()); return;&#125; 可以看出来cancel的原因是由于context.isCancelled()的结果为true 1234567public boolean isCancelled() &#123; if (parent == null || !cascadesCancellation) &#123; return false; &#125; else &#123; return parent.isCancelled(); &#125;&#125; 可以看出，如果parent&#x3D;&#x3D;null，则不可能为true，所以必然是由于parent.isCancelled()为true导致的。由此我们基本可以猜测出来，当前的ClientCall被cancel的原因是由于它的parent context canceled导致。 回到ClientCallImpl中，可以看到this.context &#x3D; Context.current();表明每个ClientCall被创建的时候，context都会被赋值为Context.current() 1234567public static Context current() &#123; Context current = storage().current(); if (current == null) &#123; return ROOT; &#125; return current;&#125; 如果当前没有context，则用ROOT作为context 12345678/** * The logical root context which is the ultimate ancestor of all contexts. This context * is not cancellable and so will not cascade cancellation or retain listeners. * * Never assume this is the default context for new threads, because &#123;@link Storage&#125; may define * a default context that is different from ROOT. */public static final Context ROOT = new Context(null); 在注释中可以看出，ROOT是不可以被cancel的，所以可以判断，当前必然有一个grpc的context存在。 最后联想到由于业务代码中，ClientCall是在ServerA处理grpc请求的过程中执行的，那么这个Context必然是由GrpcServer处理请求的时候生成的，并赋值给了ClientCall。而由于ClientCall是线性执行器中异步执行，当真正执行ContextRunnable的时候，GrpcServer的context可能已经被cancel，导致当前ClientCall被cancel。 解决办法：可以对当前context进行fork，或者把每个call都封装为Runnable，通过Context提供的run静态方法执行。 至此，终于弄清楚了grpc丢包的原因。虽然，这个问题通过业务层代码可以避免掉，但是我觉得grpc在底层默默的把这件事做了，并且没有往上层抛出任何信息，这对开发者是非常不友好的。同时，这个cancel逻辑的处理上，我觉得也有待商榷。毕竟在GrpcServer中异步的去执行GrpcCall是一个非常普遍合理的模型。也许以后Google会改吧。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"GRPC","slug":"GRPC","permalink":"https://lchml.com/tags/GRPC/"},{"name":"java","slug":"java","permalink":"https://lchml.com/tags/java/"}]},{"title":"Jekyll迁移Hexo","slug":"jekyll-hexo","date":"2017-04-19T07:07:06.000Z","updated":"2022-05-12T06:00:14.130Z","comments":true,"path":"technology/jekyll-hexo/","link":"","permalink":"https://lchml.com/technology/jekyll-hexo/","excerpt":"拖了大半年，这次终于下定决心动手把博客jekyll迁移到Hexo。为什么要迁移，就不细说了，反正就是因为被Hexo的各种优点所吸引。整个迁移花了两天时间。下载安装hexo这些都比较简单，官方文档就够用了。主要说说踩到的坑以及建议。","text":"拖了大半年，这次终于下定决心动手把博客jekyll迁移到Hexo。为什么要迁移，就不细说了，反正就是因为被Hexo的各种优点所吸引。整个迁移花了两天时间。下载安装hexo这些都比较简单，官方文档就够用了。主要说说踩到的坑以及建议。 第一次push到github，一定要先将github上原jekyll博客的内容清空，再push新的内容。还有，由于原本的博客内容已经比较多，加上游记中有大量的图片，导致第一次往github push时，文件数量多，容量大。容易失败，最好选择在够快够稳定的网络环境中进行。 默认的主题非常一般，Hexo有大量的主题可供选择，不一样的主题还有不一样的功能，这里推荐一个简洁大方的主题：Maupassant Hexo默认没有启用RSS订阅功能，需要单独安装插件。 1$ npm install hexo-generator-feed --save 然后在根目录的_config.yml中配置： 12345678#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 Maupassant主题自带了时间线（timeline）功能，只需要在主题的_config.yml中配置好timeline，并在menu中配置对应的页面即可。 在关于页面中通过iframe内嵌了donate页面，由开源实现https://github.com/Kaiyuan/donate-page提供。 将title字体改为思源宋体的过程中发现怎么改都不生效，最后发现，原来思源宋体并不是系统自带的字体，需要通过javascript加载后才能在网页中使用。在&#x2F;themes&#x2F;maupassant&#x2F;layout&#x2F;_partial&#x2F;head.jade中添加字体加载： 123script(type=&#x27;text/javascript&#x27;, src=&#x27;https://use.typekit.net/cwj3gfk.js&#x27;)script(type=&#x27;text/javascript&#x27;). try&#123;Typekit.load(&#123; async: true &#125;);&#125;catch(e)&#123;&#125; 最后，通过对layout中的jade文件修改，可以实现大部分的个性化需求。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Hexo","slug":"Hexo","permalink":"https://lchml.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://lchml.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"三亚记事","slug":"sanya","date":"2017-04-04T16:00:00.000Z","updated":"2022-05-12T05:58:17.450Z","comments":true,"path":"life/sanya/","link":"","permalink":"https://lchml.com/life/sanya/","excerpt":"芭蕉椰树艳阳，蓝天碧海山庄","text":"芭蕉椰树艳阳，蓝天碧海山庄 现在的游记好像上来不放两张扎眼的靓图就不好意思似的，的确，你以为真的只要见过就可以常记心间吗？人的大脑善于遗忘，所以摄影才横行人间。这是继巴厘岛之后第二次热带游记。说是游记，好像也没有什么可以说的，毕竟酒店游真的只是在酒店躺了五天，好在是豪华海景房，否则真觉得对不起自己了。 这算是第一次最身不由己的出游了。说说前情概要。都说人一辈子都会遇到大大小小的坎，迈过去又是一次新的生命。所以，我这次遇到的算是个大坎，以至于身不由己放弃了小清新的台湾游和奢华的泰国海岛游，只能三亚酒店陪同事们亲子游了。天玺酒店算是亚龙湾不错的度假酒店了，地处亚龙湾核心景区，拥有私家花园和海滩。来时就听同事说三亚的海滩简直没法和东南亚比，还真的是，沙滩泛黄不够白细，不过好在我们要求不高，也觉得赏心悦目，能看到蓝色大海已经是心旷神怡了。虽然一直头疼脑热腰酸背痛，但为了表示自己是在度假，而且不辜负自带的专业摄影师，第二天早上就起来写真了。 酒店的草坪很不错，多得是拍写真的家长和孩子，等我们有了孩子也会念着多记录一份他的成长和自己的陪伴吧。 这次去三亚说好了是去学游泳的，好在还是下水了三四次。初下水怕冷畏水，在刚刚齐肩的泳池里蹦蹦跳跳就是不敢游起来，两个小时之后就发现被严重晒伤了脱皮。第二次学乖在室内泳池，多亏了有自称专业的笨笨一直耐心的教我，虽然他一直说你是我见过最笨的人了…水玩久了之后总算有点感觉，终于在最后会闭气游上几米了，也算是不虚此行啦。 酒店的私人海滩，观海的人不多，只是除了早晚，当午时分太热还不如窝在酒店海景房。尽管海真的很一般，我家摄影师还是拍出了大片风范。 来一趟三亚不能缺了海鲜，为了吃到正宗的几个同事特地去了海鲜市场，当然也是参考了游记攻略，最后算了吃嗨了，不过多多少少有被宰的嫌疑，原来海鲜吃多了反而也觉得并不怎么好吃呢。觉得旅游真的想要找到好的食物和风景还是不能参考网上传烂了的游记，还是多问问当地人。更可气的是，传说中的热带城市，在三亚居然很难找到水果店，找到的也是价格不菲，难道家家户户都自带了水果园吗?我想，可能是因为我们去的都是经典吧。不过，三亚到处都是东北菜，真正是被东北人占领了的城市，除去旅游元素，这个城市真的还比较落后，好在夜晚的气候还算怡人。 最后上些照片，希望你因为赏心悦目所以不枉读了这一篇。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"三亚","slug":"三亚","permalink":"https://lchml.com/tags/%E4%B8%89%E4%BA%9A/"}]},{"title":"家庭网络，科学上网","slug":"nas-netgear","date":"2016-11-16T16:00:00.000Z","updated":"2022-05-12T05:59:26.981Z","comments":true,"path":"technology/nas-netgear/","link":"","permalink":"https://lchml.com/technology/nas-netgear/","excerpt":"前段时间，360网盘即将关停服务的消息在网上引起了不小的风波，这已经不是第一次出现互联网免费服务突然关停了，相信也不会是最后一次，毕竟大家都是出来做企业的，没有义务一直为你提供免费的服务，当确定在这一领域没有盈利可期时，服务关停也就是必然的事了。","text":"前段时间，360网盘即将关停服务的消息在网上引起了不小的风波，这已经不是第一次出现互联网免费服务突然关停了，相信也不会是最后一次，毕竟大家都是出来做企业的，没有义务一直为你提供免费的服务，当确定在这一领域没有盈利可期时，服务关停也就是必然的事了。 这里我们不去讨论和批判所谓的互联网文化，我们说点做点更务实的事情。既然免费云存储是不可靠不安全的，那么作为个人用户，还有什么更好的数据存储选择呢？这就是我们今天要说的主角：家庭网络存储，也就是家用NAS（Network Attached Storage）。话不多说，先上家里的网络架构图。 路由从图中可以看出，路由器在整个架构中是核心的存在，科学上网（翻墙）靠它，双拨（贷款翻倍）靠它，稳定可隔离的无线网络也靠它。所以尽量买个好点的吧，这里推荐网件R7000或华硕AC68U，活动期间买，价格应该在600到1000之间。由于我们要把路由器刷成梅林系统，所有购买其他型号之前先在http://firmware.koolshare.cn这里确认一下硬件是否支持对应的系统。 刷机拿到路由器后，先按照说明书操作，进入Netgear的管理页面，默认的用户名密码写在路由器的背面。自带的系统界面如下，看起来确实比较没有档次。不过反正马上就要再见了，无所谓啦。 刷机的教程网上有很多，这里就不赘述了，推荐参照这个帖子进行刷机：R7000刷改版梅林 http://koolshare.cn/thread-49247-1-1.html刷机完成，成功联网后你会看到如下界面。 双拨什么是双拨？双拨是指通过路由器进行两次独立的上网拨号，而路由器本身会对两条线路做负责均衡，以此达到宽带翻倍的目的。要注意，现在很多电信宽带默认是在光猫上进行拨号的，我们需要把他改为路由器拨号，如果不知道账号密码，可以打10000号查询。双拨比较简单，只需要把lan1设置为拨号端口，并连到光猫上进行拨号就可以了，如果光猫只有两个网口（一个itv，一个网络）那就没法直接进行双拨，这种情况可以通过光猫后面先接交互机，然后路由器再连到交换机进行双拨。具体的教程可以参考：梅林双拨教程成功后就可以看到如下界面了。（注意，拨号用的网线最好都采用千兆网线） 科学上网上网的速度已经够快了，但是上网的姿势还有些不对，想看youtube，想查Google怎么办。这时候就必须要祭出科学上网神奇SS(Shadowsocks)了，我认为这也是梅林固件最大的有点，自带了SS客户端，在“网络工具”中可以找到。在启用SS之前，首先需要一个可用的SS服务器，网上有提供一些免费的，但大都不好用，毕竟好的服务本来就应该是收费的。这里推荐我正在用的“搬瓦工“VPS，价格实惠，速度够快，操作够方便。搬瓦工主页 https://bandwagonhost.com/在便宜的VPS主机中选择19刀每年的，使用IAMSMART571GOR优惠码再节省5%。 购买成功后进入主机管理界面，找到Shadowsocks Server，按提示开启即可，如果你觉得你没什么绝密信息的话，可以把加密方式改为rc4-md5，稍微能快点。开启SS后，记好端口密码。然后在回到路由器SS客户端界面，设置好对应的参数，这里最好选择GFWlist模式，最后开启SS开关。 好了，下面就是激动人心的时刻，去打开https://www.google.com.hk/吧。然而过一会你就会发现看youtube视频并不怎么流畅，因为还有一件事要做，通过net_speeder对网络进行加速（其实就是改了主机的TCP协议栈）。安装过程很简单，只需要执行一个sh脚本即可：net_speeder安装 http://www.jianshu.com/p/f136b30ca3ba完成后再去试试youtube吧，亲测720P毫无压力。 NAS路由器部分的工作已完成，接下来就是NAS部分了。网络上有很多关于NAS的文章，有各种牌子的硬件产商，也有人用废弃的电脑自己改装黑群晖。各种选择理由就不多说了，这里推荐使用群晖的家用NAS，家用一般是2盘位和4盘位，然后又分别分为se、j、play、+四个版本，这个每个人根据自己的情况选择就可以了，需要说明的是216中只有play以上版本才支持视频解码，只有+版本是支持docker的，根据自己的需求注意别买错了。 主机选好了，还差硬盘，硬盘没太多可说的，最普遍的肯定是西数红盘，号称专为NAS打造（贵呀）。买硬盘时需要注意自己的需求，如果两盘位想要做raid的，那么单盘最好买的大一点，因为实际使用容量只有一个盘的大小。不做raid的就随意了。4T的西数红盘现在加个在1k左右。 硬件到手后，按照说明组装好，接到路由器上（用群晖自带千兆网线）。在路由器的管理界面中找到NAS的内网地址，就可以从浏览器进入NAS了。首次进入会开始安装系统，目前已经是DSM6.0了。设置好系统以后，进入系统，这是一个简单的基于linux改造的文件系统。在控制面板的QuickConnect和外部访问中设置DDNS和对应的外网访问端口。 最后在浏览器中用域名或公网ip进行访问就可以了。如果访问不通，就检查一下路由器上的端口映射配置。NAS就安装好了，系统的许多功能特性这里就不一一介绍了，比较常有的用户系统、windows&#x2F;mac文件共享备份等等。系统中还有很多实用工具，大家可以在使用中自己摸索。比如常用的PhotoStation、VedioStation、DownloadStation等等。这里举一个比较有用的例子，在”套件中心“里找到CloudSync并安装。 安装完后打开，选择用来做同步备份的网络云盘，比如百度云。按照提示设置完成后就可以让NAS的指定文件夹和百度云的数据同步，这个功能对于不做raid的情况是非常实用的，相当于用网络云盘做重要数据的备份。也可以快速的将网络上的百度云盘资源同步到NAS中。 NAS在家庭中还有一个非常实用的功能，那就是和所有屏幕互通，在手机、pad、电视、电脑上都可以访问NAS中的数据，比如会将所有视频，家庭照片都放在上面，在其他设备上上可以随意观看。想象一下，白天看到一个想看的高清电影或美剧，只要打开NAS开始下载。晚上到家就可以在高清大屏电视上看到了，是不是很爽呢？！ 总结还有很多详细的实施步骤没有在这里一一详述，如果有问题可以联系我：&#108;&#x69;&#99;&#x68;&#x65;&#x6e;&#x67;&#x5f;&#x78;&#100;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"ShadowSocks","slug":"ShadowSocks","permalink":"https://lchml.com/tags/ShadowSocks/"},{"name":"翻墙","slug":"翻墙","permalink":"https://lchml.com/tags/%E7%BF%BB%E5%A2%99/"},{"name":"NAS","slug":"NAS","permalink":"https://lchml.com/tags/NAS/"}]},{"title":"星辰和大海","slug":"cosmic-dream","date":"2016-10-16T16:00:00.000Z","updated":"2022-05-12T06:04:43.542Z","comments":true,"path":"life/cosmic-dream/","link":"","permalink":"https://lchml.com/life/cosmic-dream/","excerpt":"今日清晨 2016-10-17 7:30 神州十一号飞船成功发射，两名宇航员进入太空。","text":"今日清晨 2016-10-17 7:30 神州十一号飞船成功发射，两名宇航员进入太空。 对于从小就有着探索太空梦想的我，这是一件激动人心的事。虽然梦想没能自己实现，但只要看到人类踏上宇宙的征程，内心总会澎湃不已。总会想起《星际迷航》中的经典台词： Space: the final frontier. These are the voyages of the starship Enterprise. Its continuing mission: to explore strange new worlds, to seek out new lifes and new civilizations, to boldly go where no one has gone before. 宇宙，人类最后的边疆。这是星舰“企业号”的航程。它继续的任务，是去探索未知的新世界，找寻新的生命和新的文明，勇敢地航向前人所未至的领域。 这是每一部《星际迷航》片头都会出现的一段话，它代表了人类对未来、未知的渴求。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"随想","slug":"随想","permalink":"https://lchml.com/tags/%E9%9A%8F%E6%83%B3/"},{"name":"科幻","slug":"科幻","permalink":"https://lchml.com/tags/%E7%A7%91%E5%B9%BB/"}]},{"title":"基于Zookeeper实现的服务注册发现平台","slug":"yxguard","date":"2016-09-14T16:00:00.000Z","updated":"2022-05-12T07:12:50.270Z","comments":true,"path":"technology/yxguard/","link":"","permalink":"https://lchml.com/technology/yxguard/","excerpt":"在调研了多个开源服务发现，或服务治理平台之后，如Eureka、Consul，dubbo等，发现由于都不能完美的适配当前已有系统。","text":"在调研了多个开源服务发现，或服务治理平台之后，如Eureka、Consul，dubbo等，发现由于都不能完美的适配当前已有系统。 原方案的缺点，单个节点独立部署，可靠性差，扩展性差。不方便维护更新，更新一台服务器时，需要先把对应的服务调用方的流量切换到其他服务器，然后对服务进行更新，更新后再把流量切回来。整个过程操作复杂、容易出错。当服务器较多时，耗时耗力。 因此我们需要一个更好的架构来解决上面的问题，首先，服务端提供方对调用方来说不应该是被写死在配置文件中的一个地址端口，而应该是提供一种抽象的服务，调用方调用这种服务。这样，在整个架构中就隐藏了物理地址的信息，抽象出服务的概念后，服务提供方和调用方的部署中就不需要关注每台服务器的具体链接情况，这些全都交由服务发现平台完成。总结一下服务发现需要完成的功能： 服务提供方可以将自己的信息注册到平台。 服务消费方可以通过平台找到可用的服务提供方。 既然存在多个服务提供方，那么我们就需要实现各个提供方的负载均衡控制。 除了以上三个基本功能外，还有许多完善功能，如：服务权重设置，服务监控报警，容错控制，提供特定转发规则的调试模式等等。 由于服务发现平台充当的是整个系统的调度者，因此服务发现本身必须是高可用的。如果自己自己实现一套实时性高而且高可用的服务是比困难的，因此我们选择Zookeeper作为服务信息的存储（注意，当服务信息的数据量超过一定阈值，zookeeper的性能会急剧下降，所以该方案的适用场景有一定限制，对于有海量服务器的情况，应另外考虑其他方案）。所有的服务提供方在准备好提供服务之后把自己的提供的服务信息写入的zookeeper中。调用方启动后，从zookeeper中读取自己需要的服务信息，并做本地缓存，然后根据一定的均衡策略调用服务。而当提供方的服务信息有变化时，zookeeper也可以实现对调用方的及时通知。如下图所示： 服务展示以及数据统计：","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"服务发现","slug":"服务发现","permalink":"https://lchml.com/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://lchml.com/tags/Zookeeper/"}]},{"title":"横店·群演的故事","slug":"hengdian","date":"2016-06-26T16:00:00.000Z","updated":"2022-05-12T06:00:54.241Z","comments":true,"path":"life/hengdian/","link":"","permalink":"https://lchml.com/life/hengdian/","excerpt":"一个人，一座城；这些人，这座城。 —— HML","text":"一个人，一座城；这些人，这座城。 —— HML 横店，作为影视城，娱乐行业并没有给横店带来更多的帮助，无论是经济上还是资源上，所以到今天它依然是一座小县城，尽管有时候明星云集，当红剧中也会时不时出现影视城中熟悉的场景，都改变不了它给人落后、单调的印象。在骄阳似火的5月，我们来到这座小城，是观光，也是来看看在这个小城生活的那一群人的生活，看看是不是真如尔冬升讲述的那样，是一群路人甲的故事。 为期两天的行程安排的是先参观秦王宫和明清宫苑，期盼能在参观过程中遇到剧组，实地感受下，有幸遇到大腕儿也不错。 秦王宫-东西长廊 明清宫苑-太和殿 秦王宫-四海归一殿前全景 明清宫苑-大明门外全景 你更爱哪个呢？秦王宫，张艺谋《英雄》拍摄地。还记得是初中某个周六的课上班主任从她宿舍办了电视音响到教室带我们欣赏英雄的艺术创作和老谋子的手法独到。现在想来，也真是一段美好的回忆。有时候，我们念诗词歌赋，不为张口经纶，若是能在身临其境之时，抒发情感也是好的。明清宫苑，素有江南紫禁城美誉，不单单是因为其格局酷似，更是各大清宫名剧拍摄点，它壮阔辽远，站在太和殿前俯瞰大地更有大好江山唯我独尊大气势。我爱秦王宫，胜过明清宫苑。论建筑，秦宫地域不广，辽土不阔，没有清宫那般远大。轮奢华，秦汉自来不会给人奢华浮夸之感。有人爱明清的用色大胆张扬，有人喜秦汉的凛然气魄。我，更爱后者，说不上特别的理由，可能这常常的复道也可以作为一个理由。置身其中，往前，若是没有这门，是看不到的尽头。往上，是压迫和森严。这才是皇宫应有的气势，我喜伟岸，不喜铺张。 秦王宫复道 明清宫苑-偏殿 初入秦王宫，凑巧遇到在前广场阙楼处拍摄“凤凰无双”的一出武戏，可惜剧组人员不让近身，无法一睹拍摄现场，真是出师不利。不过好在见缝插针还是抓到不少群演的镜头。 暴晒的天气，披着厚重的戏服，如果不是那场明星梦，如何维系这样的工作状态？群演哥哥中场休息买水喝。 假装一起入境 烈日下，派饭中 在明清宫苑遇到一位江湖艺人，靠着清宫戏中的江湖技艺耍戏卖笑求生，火中取钱口吞活蛇各种虐活都上——嘴上确实面子里子却都舍不得丢，非要强调自己也算是个半大不小的名角儿是来体验生活并不为挣钱，赏脸的观众并没有几个，可能最后给钱的并不在看在这艺上，更多的是卖的情，同情。后来想想，这位卖艺的大叔和他嘴上自我介绍的那位还并不是同一位，长得有几分相似而已，说不定也是一位龙套哥。 身份也是一场戏 原本满含希望而来，却没有在明清宫苑遇到任何剧组，只在离开的时候发现宫外亲王府幽闭之处正在拍摄某组抗战神剧，也是神不知鬼不觉，小成本到家——可见，今日抗战神剧市场已远远盖过宫廷戏，拍摄成本之小编剧脑洞之大更让其长驱直入大有侵占整个中国大陆电视剧市场势头。偷偷瞧了一眼，无奈还不让拍照。 我冲着路人甲而来，真的很想了解群演这个群体的生活状态和心理状态是怎样，于是在我们的掘地三尺之下，循着攻略找到了“演员老公会”这个组织。据说所有背负着明星梦来到横店打算大干一番的年轻人都会来这个地方报道，并且从此每日驻守在此大本营、接戏、对台本、跑龙套，期望终有一天能够遇到下一个尔冬升。 群演组织——老公会 接了戏的群演对台本 事实上，这些有着明星梦的青年们，大多非科班出身，也并不都有娇好的容颜，可能不具备任何一点走上星途的特质。但他们中大部分人执着地坚守这这个梦想，近乎偏执。我不能支持，但可以理解，不管是不是走捷径的心理还是真以为梦想可以无边无际，年轻都可一试。就像他们说的：梦想总是要有的，万一遇到尔冬升了呢。 假期结束了，我们回到自己的城市，他们又开始在他们的城市里坚持梦想。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"横店","slug":"横店","permalink":"https://lchml.com/tags/%E6%A8%AA%E5%BA%97/"}]},{"title":"临安·大明山","slug":"damingshan","date":"2016-06-18T16:00:00.000Z","updated":"2022-05-12T06:03:52.831Z","comments":true,"path":"life/damingshan/","link":"","permalink":"https://lchml.com/life/damingshan/","excerpt":"有那么一刻，感觉会就这样走到天荒地老没有尽头。 —— HML","text":"有那么一刻，感觉会就这样走到天荒地老没有尽头。 —— HML 昨天的徒步是一段可能会记得很久很久的旅程。没有记得很多风景，倒是记得很多人和事。在嬉笑怒骂中我们走入重山，攀高、远望，在雨中奔跑。其实到现在我也不清楚征服的是那座山峰，只记得是在大明山。清晨，在领队的有序安排下我们五壮士团按时乘大巴到达了大明山景区（所谓的五壮士团是我们给自己的战号，大明山五壮士是也），开始了我们的征程。先放一张“胜利大团结”镇楼吧。 “胜利大团结” 出发征途，像不像大山敞开的胸怀 所谓的旅程，据说是心的修养，不过我们也是避不开拍拍拍的旧俗——就算眼睛能带走多少美景，岁月的橡皮擦也不会放过它们吧！瞧瞧我们这一路的走走停停。大山在给予我们历练的前奏放了一支优美的华尔兹 原本以为的是一眼望不到头的石板阶，原来是几乎全程手脚并用的艰难，用句网络语，“这山真的是野到没朋友”。前半段以瀑布为里程碑结束，中途还遇到了好几支队伍，从年龄来看属于中年，他们清一色专业装备、身手矫捷，真的是活力四射。 大山内的一抹彩色 飞流直下 从早间10点半左右到正午12点，我们到达了瀑布下，顿觉心旷神怡，忽然有一种俯仰大地，吾辈看沧海的泠然之情。表现在行动上的就是各种角度自拍相互拍，此般美景只应天上有，人间能有几回闻，更何况可是跋山涉水历经艰辛才能见到的。 像绢流，像丝幕 大明山五壮士集结 “顶”天“立”地 多年以后，还能回味 本以为此处就是终点，然而并没有，事后看来，到这里只是三分之一的艰辛，后面的路更难走。此处距离下山地点仍有2个多小时，后面的山路更抖更险，甚至需要借助绳索攀爬。好在领队几个壮实的男生冲锋陷阵，女孩子们也都顺利登顶了。可有爱，这个团队。 我们走出了“一线天” 你在我身后 飞“度” 总有类似俗话说“上山容易下山难”，我想说——真是这么回事！而且不是一般难，以至于我一张照片都没记录下来，全神贯注在脚步上还是摔了3次，惨烈的是屁股和手掌。有那么一刻，我甚至觉得就要这样走下去了，天荒地老，没有尽头，走不出大山，回不到家乡。不是绝望，是山路太难走。以至于，在踩到坚实的大路的那一刻，简直可以飞起来，从来没有觉得平坦是这样的幸福。好在美景，不可辜负。 “大山的子孙呦” 远山，眉黛 你风尘仆仆，胜利的终点 终于，在天黑前到达山脚，天公算作美——临了还给我们来了一场甘霖，让这次徒步的难度系数又加了一星，成就感也饱胀了几分。中途还出了一点小插曲，队友走岔了路，领队的不离不弃最终会合，让我对这个团队的青睐也加了几分，相信他们会做得更好。我一直觉得安逸在这里会让自己感觉不到幸福，成长都会变慢。旅行的意义不仅仅是走过不一样的风景遇见不一样的人，最终还是让自己变得更好。你说对不对？","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"}]},{"title":"Eureka文档翻译（上）","slug":"netflix-eureka-glance","date":"2016-05-26T16:00:00.000Z","updated":"2022-05-12T06:07:36.372Z","comments":true,"path":"technology/netflix-eureka-glance/","link":"","permalink":"https://lchml.com/technology/netflix-eureka-glance/","excerpt":"Eureka是一个基于REST（Representational State Transfer）的服务","text":"Eureka是一个基于REST（Representational State Transfer）的服务 什么是Eureka？Eureka是一个基于REST（Representational State Transfer）的服务，主要用于AWS中实现负载均衡和中间件服务的故障转移。我们称这种服务为Eureka服务器，同时Eureka还附带了基于Java的客户端组件，可以简化与服务器的交互。Eureka客户端内置了负载均衡，用于实现基本的循环负载均衡。在Netflix，有更为复杂的基于权重的负载均衡，如流量、资源使用率、错误控制等权重区分。 什么时候需要Eureka？在AWS中，由于其固有特性，服务器会经常上下线。不同于传统基于IP和HOST的负载均衡，在AWS上，负载均衡需要更为复杂的注册和注销服务策略。由于AWS并没有提供一个中间件的负载均衡器，Eureka恰好填补了这一空白。 Eureka与AWS ELB有什么区别？AWS ELB（Elastic Load Balancer）是为暴露给用户的边缘服务器提供的网络流量的负载均衡方案。而Eureka提供了中间件负载均衡。（虽然理论上你也可以把AWS ELB用于中间件，但这会让他们都暴露在公开环境中，从而也失去了AWS的安全保护。） 同时，ELB是传统的基于代理的负载均衡解决方案，而Eureka提供的是实例、服务器、host层面的负载均衡。客户端实例能得到需要联系的服务器的所有信息，是好是坏取决于你从什么角度来看它。假如你需要的是一个基于用户会话状态的负载均衡，AWS已经有提供，而Eureka却没有提供开箱即用的方案。在Netflix，我们倾向于让服务是无状态的。这更有利于构建可扩展模型，而Eureka非常适合用于此。 Eureka负载均衡和基于代理的负载均衡的另一个重要不同在于，所有可用服务器的信息都会被缓存在客户端中，因此当应用从负载均衡掉线后具有恢复能力。通过花费很小的内存换来更好的弹性。 Eureka与Route 53有什么区别？ Route 53是一种命名服务，类似于Eureka为中间件提供的服务，但也尽是类似。作为DNS服务，也可以为非AWS提供服务。它还可以做基于延迟的AWS跨域路由。Eureka类似于一种内部DNS，它与公开的DNS服务无关。同时也是区域隔离的，它不知道其他AWS域的服务器信息，仅持有单个区域内的服务器信息。 虽然你可以通过Route 53注册你的服务器并依靠AWS安全组件来保护他们不被公开访问，但是你的中间件服务仍然暴露在公开环境中。另外，这还会有传统DNS负载均衡带来的缺陷：当服务器已经变得不可用甚至不存在时，流量还是会被路由到这些服务器上。（AWS中，服务器随时可能下线） Netflix如何使用Eureka？在Netflix，Eureka不仅仅作为中间件负载均衡的重要组件。 配合Asgard实现零宕机部署。当服务器出现问题时，可以做到新旧版本部署的无缝切换。（特别是当部署上百个实例时会需要很长的时间） 配合Cassandra运维，实现线上服务热插拔。 用于确定memcached缓存服务的节点列表。 用于传递其他各种服务的特定云数据或信息。 什么时候该用Eureka？运行在AWS，不想通过AWS ELB注册或暴露你的中间件服务。你可能在找一个简单的循环负载均衡或可定制的负载均衡方案。你不需要保持会话状态或从memcached中加载会话数据。更重要的是，如果你的架构符合基于客户端负载均衡的模型，那么Eureka是你最合适的选择。 client与Server是如何通信的？你可以选择任意的通信方式。Eureka帮你寻找你需要的服务的信息，并没有对通信协议或通信方式做任何限制。例如，你可以使用Eureka获取目标服务器的地址，同时使用thrif、http或任何一种RPC方式。 应用架构上图的架构描述了Eureka在Netflix是如何部署的，这也是Eureka的典型用法。在每个域内至少有一个Eureka集群，它只知道该域内的实例，每个分区至少有一台Eureka服务器用于处理分区内的故障。 region：域 zone：分区 服务会向Eureka注册，并每隔30s发送一次心跳。如果连续90s没有心跳，服务器就会被注销。服务的注册信息和心跳状态会被复制到Eureka集群中的每一个节点上。从任何一个节点上来的客户端都可以找到对应的服务并发起远程调用。 非Java服务和客户端对于非Java的服务，你可以选择用相应的语言来实现Eureka客户端部分，或者运行一个内嵌了Eureka客户端的独立Java程序来实现注册和心跳。Eureka客户端的所有操作接口都有对应的REST接口暴露出来，非Java客户端可以通过REST接口来查询服务注册信息。 可配置Eureka可以让你的服务集群实现节点的热插拔。可以动态调整配置，如超时时间或者线程池配置等。Eureka使用archaius作为配置中心实现，你也可以自己实现。 弹性作为AWS的服务，考虑服务弹性是必不可少的。Eureka提供客户端和服务端内建的弹性能力。 Eureka客户端被设计成可以处理当一个或多个Eureka节点宕机的情况。由于客户端会缓存所有的注册信息，因此就算所有Eureka节点全部宕机，依然可以正常工作。 Eureka服务端同样有能力应对Eureka节点宕机的情况。即使当服务端与客户端出现网络中断的情况，服务端依然可以通过内置的恢复能力防止大规模的中断。 分区部署在多个AWS区域部署Eureka是一个相当简单的任务，不同区域的Eureka集群之间并不需要彼此通信。 监控Eureka使用servo作为监控服务，实现客户端服务端信息监控，异常报警等。数据通过JMX暴露出来，并可以导出到Amazon Cloud Watch。 配置EurekaEureka的使用有两部分组成——Eureka Client和Eureka Server。采用Eureka的架构通常会包含两种应用： 应用客户端：通过Eureka Client向服务端发起请求。 应用服务端：接收客户端请求并返回。 包含了如下三个部分： Eureka Server 应用客户端用的Eureka Client 应用服务端用的Eureka Client Eureka同时支持AWS和非AWS环境。 如果是AWS的环境，你需要在java参数中增加-Deureka.datacenter=cloud，用于通知Eureka初始化特定的AWS信息。 配置Eureka Client必要条件 JDK1.8+ 可以通过以下方式获得Eureka Client（尽量使用最新版本）。 通过这个url下载Eureka Client：http://search.maven.org/#search%7Cga%7C1%7Ceureka-client 通过pom文件添加依赖获得Eureka Client： 12345&lt;dependency&gt; &lt;groupId&gt;com.netflix.eureka&lt;/groupId&gt; &lt;artifactId&gt;eureka-client&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt; 这里有详细的Client构建说明 配置配置Eureka Client最简单的方式是使用property文件。Eureka Client会默认搜索classpath中的eureka-client.properties文件，然后进一步搜索指定环境中的指定配置文件。环境通常分为test和prod两种，通过java参数-Deureka.environment来指定，如-Deureka.environment=test。因此client也会搜索 eureka-client-&#123;test,prod&#125;.properties文件。 这里有一些默认的配置文件实例。你可以把他们复制到自己的工程中并改成自己需要的。如果你想要改变文件名，你可以用java参数来指定配置文件名：-Deureka.client.props=config-name。 配置文件中必须包含如下属性： Application Name (eureka.name) Application Port (eureka.port) Virtual HostName (eureka.vipAddress) Eureka Service Urls (eureka.serviceUrls) 更多高级配置，可以参考下面的两个配置类。https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.javahttps://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java 配置Eureka Server必要条件 JDK 1.8+ Tomcat6.0+ 可以通过以下方式获得Eureka Server 通过源码编译构建得到war文件 通过这个url下载war文件：http://search.maven.org/#search%7Cga%7C1%7Ceureka-server 配置Eureka Server配置分为两部分 上面说的Eureka Client配置 Eureka Server配置 最简单的配置方式是和Eureka Client一样采用property文件配置。首先，根据上述内容配置好服务端的Eureka Client。Eureka Server自身会启动一个Eureka Client用于寻找其他Eureka Server。因此，你需要像给其他应用的Eureka Client配置一样，给Eureka Server配置好自身的Eureka Client。Eureka Server会根据这个配置来寻找其他具有一样eureka.name属性的Eureka Server。 配置好Eureka Client部分后，如果运行在AWS的，还需要配置Eureka Server部分。Eureka Server默认搜索classpath下的eureka-server.properties文件。然后进一步搜索指定环境中的指定配置文件。环境通常分为test和prod两种，通过java参数-Deureka.environment来指定，如-Deureka.environment=test。因此Eureka Server也会搜索 eureka-server-&#123;test,prod&#125;.properties文件。 配置本地开发环境当在本地开发环境中运行Eureka时，通常需要等待3分钟左右才能完全启动。这是由于Eureka Server默认行为：当搜索不到其他可用节点时会不停的重试。可以通过下面的参数配置来修改这个等待时间：eureka.numberRegistrySyncRetries=0。 配置AWS运行在AWS环境的情况下，需要更多额外的配置，参考这里。其他Server的高级可用配置参考这里 如果你是自己构建war文件，可以直接编辑eureka-server&#x2F;conf目录中的配置文件，构建过程会把配置文件放到WEB-INF&#x2F;classes目录。 如果你是下载的war文件，可以直接修改WEB-INF&#x2F;classes目录中的配置文件。 尝试运行demo，可以有助于更好的理解。 Client&#x2F;Server版本兼容性Eureka使用semantic versioning，会保持小版本的Server&#x2F;Client之间兼容（例如1.x版本的Client和Server之间协议是兼容的）。通常，Server版本大于Client版本总是安全的。 构建 安装git 获取Eureka源码 1git clone https://github.com/Netflix/eureka.git 运行下面命令构建Eureka Server 12cd eureka./gradlew clean build 得到如下结果 Eureka Server war包 (.&#x2F;eureka-server&#x2F;build&#x2F;libs&#x2F;eureka-server-XXX.war ) Eureka Client jar包(.&#x2F;eureka-client&#x2F;build&#x2F;libs&#x2F;eureka-client-XXX.jar ) 依赖包 (.&#x2F;eureka-server&#x2F;testlibs&#x2F;) (如果不适用maven类似的依赖机制，可以直接使用这些包) 关于DemoDemo程序包含了运行Eureka所需要的所有配置，构建和运行能力。 Eureka Server Application Server Application Client Demo会帮你设置一个Eureka Server的监听端口，同时设置一个处理请求的Application Server和一个发送请求的Application Client。 Application Service会注册到Eureka Server，Application client可以从Eureka Server找到它们并发送请求。Client和Server完成消息互通后优雅的退出。 关于Demo ServerDemo Server被配置成便于demo使用，而非适合正式产品使用。理解如果正确的配置Eureka Server（The server configurations to understand how to properly configure the eureka servers）。 Eureka Server配置 需要的话，在eureka-server&#x2F;conf&#x2F;目录中，修改eureka-client.properties和eureka-client-test.properties。（对于demo来说，通常不需要修改eureka-server.properties，除非你需要更多高级配置） 构建应用（同时会构建所有运行demo所需要的库） 部署war包到你的tomcat中 启动tomcat，通过http://localhost:8080/eureka查看信息。Eureka Client会在30s内注册上来并显示此处。 Application Service的Eureka Client配置 需要的话，在eureka-examples&#x2F;conf目录中，修改sample-eureka-service.properties。 Application Client的Eureka Client配置 需要的话，在eureka-examples&#x2F;conf目录中，修改sample-eureka-client.properties。 运行Demo参考Demo的readmehttps://github.com/Netflix/eureka/tree/master/eureka-examples 部署在AWS环境，实例会频繁的上线下线。这就意味着你不能通过正常的host或ip来定位Eureka Server，而Eureka Server需要识别定位那些不断变换hostname的服务，所以你要为Eureka Server提供一套标准的可识别地址。 这时候就需要AWS EC2的弹性IP（Elastic IP）了。如果你没听说过弹性地址，那么请先看这里 第一步，先为每台Eureka Server获取一个Elastic IP。你需要为集群中的每个Server获取一个Elastic IP。当你给Eureka Server配置好Elastic IP列表之后，Eureka Server会自己处理寻找没被占用的IP，并在启动时绑定该IP。 通常每个AWS域中的每个Eureka集群会有一个ASG，每个实例都使用一样的配置启动。这意味着，每个分区内必须要有一个冗余Eureka Server实例处理故障。一旦有一个实例被挂掉，ASG就会从空闲区域中启动一个新的Eureka Server实例，并从该区域内选取一个空闲Elastic IP绑定。对于正在访问Eureka Server的客户端来说，整个过程是透明的。就和正常的Eureka Client连接失败后转移到其他服务器，当服务器恢复后会自动重连一样。 根据不同的弹性需求，有两种不同的Elastic IP配置方式。在Netflix，为了做到全透明的增加新分区或新Eureka Server节点，我们采用DNS的方式来分配EIPs，做到对client和server端都可以热部署。还有个更简单的方式是配置在Eureka的配置文件中，这样做的缺点是，这些配置需要被分发到集群（大约1000个实例）中的每个实例。增加移除分区的操作肯定会变非常麻烦，因为不是给每个client下发新部署的配置。 通过配置文件配置EIPs首先需要为Eureka Server配置每个域中的所有有效分区。配置内容在eureka-client.properties(或eureka-client-test.properties，或eureka-client-prod.properties) 下面的例子中，一个us-east-1域指定了三个有效分区：us-east-1c,us-east-1d, us-east-1e。 1eureka.us-east-1.availabilityZones=us-east-1c,us-east-1d,us-east-1e 下一步为每个分区配置Eureka监听地址，一个分区内的多个Eureka Server可以用逗号隔开。 123eureka.serviceUrl.us-east-1c=http://ec2-552-627-568-165.compute-1.amazonaws.com:7001/eureka/v2/,http://ec2-368-101-182-134.compute-1.amazonaws.com:7001/eureka/v2/eureka.serviceUrl.us-east-1d=http://ec2-552-627-568-170.compute-1.amazonaws.com:7001/eureka/v2/eureka.serviceUrl.us-east-1e=http://ec2-500-179-285-592.compute-1.amazonaws.com:7001/eureka/v2/ 服务端和客户端的Eureka Client也有同样的配置。 通过DNS配置EIPs如果你需要更高的灵活性，那就需要采用DNS的配置方式。 首先为每个域配置一个DNS name用于解析可用分区列表。 由于一个DNS name只有一个CNAME，我们用TXT records作为DNS name列表。 下面是一个DNS TXT record例子，在DNS server上列出了一个分区中的有效DNS name。 12txt.us-east-1.mydomaintest.netflix.net=&quot;us-east-1c.mydomaintest.netflix.net&quot; &quot;us-east-1d.mydomaintest.netflix.net&quot; &quot;us-east-1e.mydomaintest.netflix.net&quot; 接着可以像下面一样为每个分区定义TXT record（如果一个分区有多个hostname，用逗号隔开） 1234txt.us-east-1c.mydomaintest.netflix.net=&quot;ec2-552-627-568-165.compute-1.amazonaws.com&quot; &quot;ec2-368-101-182-134.compute-1.amazonaws.com&quot;txt.us-east-1d.mydomaintest.netflix.net=&quot;ec2-552-627-568-170.compute-1.amazonaws.com&quot;txt.us-east-1e.mydomaintest.netflix.net=&quot;ec2-500-179-285-592.compute-1.amazonaws.com&quot; 最后在Eureka Server和Eureka Client的配置中增加如下配置。 1234eureka.shouldUseDns=trueeureka.eurekaServer.domainName=mydomaintest.netflix.neteureka.eurekaServer.port=7001eureka.eurekaServer.context=eureka/v2 在Netflix，我们用DNS的配置方式做到动态增加删除Eureka Server节点，并在几分钟内完成对几千个客户端的同步。 通过Service Urls设置EIPs那么，为什么想要给Server分配EIPs时需要定义URLs呢？为了保证AWS的安全机制，任意两个实例之间的通信需要通过公共的hostname。Eureka Server之间使用这些URL进行通信。每个URL中包含了有EIP（552.627.568.170）衍生的公共hostname（ec2-552-627-568-170.compute-1.amazonaws.com） Eureka server启动时会先找到一个分区推出的EIP，然后再从该分区中再找到一个空闲的EIP绑定启动。 Eureka是如果找到空闲EIP的？它通过Eureka Client找到集群中的其他实例，并查看他们绑定的IP，然后从中挑选未被绑定的IP。它优先使用同一个分区内的EIP，这样可以让该分区内的其他Eureka Client与之通信。如果Eureka Server找不到该分区内的空闲EIP，才会去尝试其他分区。如果所有的EIP都已经被占用，那么Eureka Server启动后会一直等待空闲EIP，并每个5分钟重试一次。 同样的，Eureka Client会优先寻找同一分区内的Eureka Server，找不到的情况下才去尝试其他分区。 Eureka故障切换当Eureka Client得到Eureka Server的列表后，发生故障时，会自动切换到集群中的其他节点。让我们通过下面的配置来分析这个过程是如何工作的。 1234eureka.us-east-1.availabilityZones=us-east-1c,us-east-1d,us-east-1eeureka.serviceUrl.us-east-1c=http://ec2-552-627-568-165.compute-1.amazonaws.com:7001/eureka/v2/,http://ec2-368-101-182-134.compute-1.amazonaws.com:7001/eureka/v2/eureka.serviceUrl.us-east-1d=http://ec2-552-627-568-170.compute-1.amazonaws.com:7001/eureka/v2/eureka.serviceUrl.us-east-1e=http://ec2-500-179-285-592.compute-1.amazonaws.com:7001/eureka/v2/ 我们定义了三个分区 (us-east-1c, us-east-1d and us-east1e) 每个分区只有一个EIP。 比如eureka server在us-east-1c分区http://ec2-552-627-568-165.compute-1.amazonaws.com:7001/eureka/v2/运行失败, 所有eureka clients自动切换到下一个分区http://ec2-552-627-568-170.compute-1.amazonaws.com:7001/eureka/v2/。如果还是失败，继续尝试列表中的下一个分区。 当宕机的Eureka Server重新恢复，Eureka Client会重新连接到该分区内的Eureka Server。 Eureka的AWS特定配置在AWS上，需要增加java参数-Deureka.datacenter=cloud，让Eureka Server&#x2F;Client知道针对AWS环境初始化。 Eureka Server需要运行在AWS的EC2的访问权限。两种方式：使用默认的配置，它会在EC2实例中使用InstanceProfileCredentials。或者明确在配置文件中配置好AWS的accessId和secretKey： 12eureka.awsAccessId=eureka.awsSecretKey= AWS访问策略Eureka会尝试查询ASG的相关信息，以确保实例启动时处于OUT_OF_SERVICE或UP状态，而这取决于自动伸缩组配置项中addToLoadbalancer的值。属于哪个ASG的属性由Eureka Client配置中的eureka.asgName指定。 1eureka.asgName Eureka server需要访问云端的ASG信息和IP绑定信息。因此AWS策略要配置成允许上述访问，下面是一个访问策略的例子。 12345678910111213141516171819202122&#123; &quot;Statement&quot;: [ &#123; &quot;Sid&quot;: &quot;Stmt1358974336152&quot;, &quot;Action&quot;: [ &quot;ec2:DescribeAddresses&quot;, &quot;ec2:AssociateAddress&quot;, &quot;ec2:DisassociateAddress&quot; ], &quot;Effect&quot;: &quot;Allow&quot;, &quot;Resource&quot;: &quot;*&quot; &#125;, &#123; &quot;Sid&quot;: &quot;Stmt1358974395291&quot;, &quot;Action&quot;: [ &quot;autoscaling:DescribeAutoScalingGroups&quot; ], &quot;Effect&quot;: &quot;Allow&quot;, &quot;Resource&quot;: &quot;*&quot; &#125; ]&#125; Client&#x2F;Server互通使用Eureka Server的第一步是先初始化Eureka Client。如果在AWS上，初始化方法如下： 版本1.1.153，EurekaModule类引入了governator&#x2F;guice来使用eureka-client。governated例子。 1.1.153之前的版本，可以这样初始化Eureka Client： 123DiscoveryManager.getInstance().initComponent( new CloudInstanceConfig(), new DefaultEurekaClientConfig()); 如果在其他环境运行Eureka，初始化方法如下： 123DiscoveryManager.getInstance().initComponent( new MyDataCenterInstanceConfig(), new DefaultEurekaClientConfig()); Eureka Client会自动寻找eureka-client.properties配置文件进行初始化。 关于无状态实例默认情况下，Eureka Client启动后会处于STARTING状态，这样可以让实例在正式提供服务之前进行其他的初始化工作。然后再通过下面的方法把状态改为UP，让实例正式上线提供服务。 1ApplicationInfoManager.getInstance().setInstanceStatus(InstanceStatus.UP) 应用也可以注册心跳检测的回调，用于把实例状态改为DOWN。 在Netflix，我们也会使用OUT_OF_SERVICE状态，主要用于从线上撤下实例。当新部署版本有问题时可以很容易的回滚。大多数应用会为新的版本创建新的ASG，然后把线上流量导到新的ASG。出现问题的情况下，回滚只需要把ASG中的所有实例状态改为OUT_OF_SERVICE来切断流量。 Eureka Client运行Eureka Client在AWS上会先尝试与本同一分区的Eureka Server协商所有操作，失败则尝试其他分区。 Application Client可以通过Eureka Client返回的信息实现负载均衡，如下： 12345678910111213InstanceInfo nextServerInfo = DiscoveryManager.getInstance() .getDiscoveryClient() .getNextServerFromEureka(vipAddress, false);Socket s = new Socket();int serverPort = nextServerInfo.getPort();try &#123; s.connect(new InetSocketAddress(nextServerInfo.getHostName(), serverPort));&#125; catch (IOException e) &#123; System.err.println(&quot;Could not connect to the server :&quot; + nextServerInfo.getHostName() + &quot; at port &quot; + serverPort);&#125; 如果简单的轮询负载均衡不能满足需求，你可以从这里提供的选择中封装自己的负载均衡。在AWS环境，需要实现失败重试并保持较低的超时时间，因为有一种情况是，Eureka Server可能返回了已经无效或不存在的实例。 需要注意是，为了服务器的正常的通信，Eureka Client会清理掉闲置30s以上的http连接。因为AWS不允许在一个空闲了几分钟之后的连接上传输内容。 Eureka Client与Server的交互如下： 注册Eureka Client会把实例的相关信息注册到Eureka Server。在AWS上，这些信息包含了访问URL，如[http://169.254.169.254/latest/metadata][]这样。Client会在第一次心跳时进行注册。 心跳Eureka Client需要每隔30秒发送一次心跳来更新状态，告知Eureka Server自己还活着。如果Server连续超过90s没有收到心跳，会将对应的实例从注册表中移除。尽量不要去修改心跳时间间隔，因为Server依靠心跳来确定与Client之间的通信是否有问题。 获取注册表Eureka Client从Server获取注册信息并缓存在本地，然后应该根据这些注册信息找到需要的服务。注册信息会周期性（每30s）做增量更新。由于增量信息本身会在Server缓存较长时间（大约3分钟），因此可能会返回相同的增量信息。Eureka Client会自动处理这种重复信息。 拿到增量信息后，Eureka Client会比较服务器返回的信息和实例数量的一致性，如果信息不匹配，整个注册表信息都会再重新获取一次。Eureka Server会缓存所有压缩过和非压缩的增量信息、整个注册表信息，以及每个应用的信息。信息格式支持JSON&#x2F;XML等格式。Eureka Client获得的信息是经过Apache jersey压缩的json格式。 注销Eureka Client关闭时发送一个注销请求给Eureka Server。通过从Server的注册表中移除该实例，从而有效的把实例从线上撤下。 应用关闭时应该确保调用如下方法： 1DiscoveryManager.getInstance().shutdownComponent() 时延所有从Eureka Client发起的操作需要一段时间才能反映到所有Eureka Server和其他Client。因为Eureka Server的缓存是每个一段时间刷新一次，Client也是每隔一段时间获取一次注册信息。所以同步到所有Server和Client可能需要花费2分钟。 通信协议默认情况下，Eureka使用Jersey和XStream配合json作为Server与Client之间的通信协议。你也可以选择实现自己的协议来代替。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"服务发现","slug":"服务发现","permalink":"https://lchml.com/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"},{"name":"Eureka","slug":"Eureka","permalink":"https://lchml.com/tags/Eureka/"}]},{"title":"带XML去旅行之日本（下）","slug":"travel-in-japan-3","date":"2016-05-25T16:00:00.000Z","updated":"2022-05-12T05:56:48.253Z","comments":true,"path":"life/travel-in-japan-3/","link":"","permalink":"https://lchml.com/life/travel-in-japan-3/","excerpt":"最美的风景，在眼内，在心间。 ——HML","text":"最美的风景，在眼内，在心间。 ——HML 东京看遍了大阪、奈良和京都，又回到了东京。一方面是因为行程失策，导致我们走了回头路，另一方面，确实在东京我还有很多没有来得及写。 迪士尼东京的三天我们安排了迪士尼和买买买。从来都没去过迪士尼的我们，光凭想象和如雷贯耳的大名总觉得这是一个童话的王国。之前一直因为大阪影视城和迪士尼选哪个而纠结，毕竟认为前者更刺激更适合，而后者更童话更梦幻。最后还是被一颗华丽丽的虚荣心给击败了——东京有世界上唯一的Disney sea，怎么的也得去见见世面——哈哈哈哈。 7-11购买的迪斯尼海洋入园券 很遗憾，去disney这天光顾着玩，没拍几张照片来记录。现在想来有点后悔，不过就像我题记说的那样，无论是自然风光还是人文景观，最美的，永远永远都留在你的脑海里。Tokyo Disney历来是人满为患，统计看来现在Disney Sea的人气逾旺，因此我们特意看了攻略，也实践了攻略，所以，一定意义上这一段算是攻略贴。读者收好不谢，哈。 Disney Resort Line Disney Sea 英文版地图 可以看到这张地图被我们蹂躏得有些过分了。Disney Sea 分7个主题区域，每个都用不同颜色标注出来，事实证明最里面的失落三角洲已经左下角的美国海滨比较刺激。各片区域之间有小火车和游船相连，游客可以自由乘坐。我认为最好玩的项目是惊魂古塔，没有之二，无论是里面的设计摆设还是营造的气氛，以及带给人的游玩感受都是最棒的。其次是玩具总动员项目的4D游戏，还有地心探险之旅和愤怒双神、风暴骑士。我们几乎是循着“fastpass”的脚步，奔走在路上。何为fastpass？就是you can pass faster with this card的意思。热门的景点（也就是好玩的景点）都会有这样的券。我们的策略就是先尽可能多的拿到fastpass，这样后面就不用排队了。当然fastpass是有时效和领用限制的，在你的前一张fastpass领用时会有下一张可领时间和本张使用时效标注，而且一天当中数量也是限定的，太晚就拿不到了。由于惊魂古塔太好玩，我们在最后又去领了一次fastpass，可惜时间安排到晚上9点多，等不及只能作罢。 Fastpass for magic lamp theater 似乎是运气好我们去的这日游客看起来并不很多，各个项目几乎没排队，当然也得益于我们的fastpass，到最后主会场表演时可以证明游客并不少。在连续拿了多个fastpass并顺利玩完几乎所有项目之后，我们在阿拉伯海岸吃了一顿咖喱汤饭，很美味，相对日本的物价来说乐园里的食物真的不贵，相比上海刚开业的Disney 50元一个鸡腿的物价来说，很幸福。 和高飞的合影 在Columbia号的合影 童话世界 忘了是美人鱼岛还是阿拉伯海岸 但愿没记错——失落三角洲 从地中海港湾看美国海滨 Mickey and Mickey——还是他们有魅力 整个过程，最后Disney Sea 15周年的表演最激动人心，其实来游玩的大部分是日本人。相对来说，Disney周边的价格略高，但日本人对这些很是热衷，每个人身上都会带走几只Mickey，大概对他们来说便宜也是一个原因。 银座日本是有名的买买买圣地，之前的几篇我也提到了药妆，除了药妆之外，专柜的日妆、电子产品、机器人以及大红大紫的马桶圈都是国人争相购买的热门。而所到之处无非也就是那么几个：新宿、池袋、秋叶原、银座。最著名的也就是银座了，这个超大型购物天堂。 可惜我本不是个购物狂，甚至连喜欢都算不上，所以这地方对我没有吸引力，要是有个谁求代购倒是难为我了，毕竟不擅长费心费力。不过无论是走到各大商场专柜前还是街道广场上，倒是都能听到中国话，这一刻我感受到国人强大的购买力和熟悉的“亲切感”。 日本印象七在东京常常可以看到，无论是电铁还是街道中时刻穿梭着匆忙行走的人，他们中很多带着大大的口罩，几乎遮住整张脸只剩下眼睛。当时感到奇异，回头想来这也是一种文化。就像流行的起源有的真的是出于现实的需求。日本樱花遍布全国，春季也是大量花粉症爆发的季节，因此早期的口罩是为了预防花粉症，发展到今天，最初的目的已经越来越弱了，更多的是为了遮掩一些面部的不完美，有的甚至只是追赶潮流，谁说不是呢，明星不都戴口罩吗？日本电铁等站内到处遍布化妆室，而不是洗手间。里面除了卫生间还有独立的镜子和化妆台，时刻有各个年龄段的女性站在镜前补妆。近距离观察会发现，日本女性小到背着书包穿着校服的高中生，大到花甲鬓白的老妇，各个都有着精致的妆容，都有画眉、腮红、唇膏，几乎无人佩戴眼镜，发型光亮整洁不毛糙，从去上班开始到下班一直保持这个状态，看不到一丝懈怠。中国多爱日妆，有的也是被这样的社会文化感染，但我觉得这还是一个民族的性质特征决定。他们日日拘谨，也许乐在其中，只有自己知道。 还想说几句人的一生随着社会阅历的改变总是在不断刷新自己对待世物的看法，现在记录下来，提醒我曾经年轻过、我的年少装的什么：学生时代最遗憾的事莫过于没有好好对待二学位的日语学习，单单拿了个空空的学位到头来发现书到用时方恨少，有句话叫功不唐捐，韩寒说的“懂得很多道理却依然过不好这一生”，就像我现在懂得这个道理却不能保证会在余下的时间里认真对待每一件值得认真的事。我只能说时时鞭策自己是便要的，律己是一个人最崇高的品质。 日本归来爸妈问我，都说日本发达，到底发达在哪，是路更宽还是人们工作压力更小？爸妈有着60后人对祖国发展的欣喜和幸福感。我无法跟他们说日本的发达表现在市政设施还是在社保质量。我认为一个社会的发达不在于建了几条双向8车道几座立交桥、几条盘山公路打通几座大山让大山里的人们感受到大发展。日本的街道窄、车小、工薪阶层压力大，在日本生活你感受不到每天的发展，一方面是因为社会发展到一定阶段之后产生的边际效应，多年后，你会发现我们的差距不在以上的所有，在他们的社会精英和上层建筑忍不能之忍、创不能之新。我们的男人开的是日本车、女人用的是日妆，就连马桶圈都需要去日本抢购。时间的强大就在于他永远能回答你此刻无法理解的问题。 起飞的时候，你不知道是否还会有机会再来一次","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"日本","slug":"日本","permalink":"https://lchml.com/tags/%E6%97%A5%E6%9C%AC/"}]},{"title":"带XML去旅行之日本（中）","slug":"travel-in-japan-2","date":"2016-05-17T16:00:00.000Z","updated":"2022-05-12T05:56:51.046Z","comments":true,"path":"life/travel-in-japan-2/","link":"","permalink":"https://lchml.com/life/travel-in-japan-2/","excerpt":"新干线呼啸而过——是时光机在穿梭。 ——HML","text":"新干线呼啸而过——是时光机在穿梭。 ——HML 都说关西才是旅游者的天堂，来日第四天我们才开始这一段旅程。久负盛名的新干线自然是没让我们失望（隐约觉得新干线的头有点像蜡笔小新的脸，我是肿么了）。只是差点坐错，新干线分三种，时速不同，最快的一班是不能用JR PASS的。我们花了大价钱买的最快的のぞみ只需要2个多小时就飞跃关东到达关西，带我们走入历史的痕迹。 大阪大阪，古名“难波”，是日本仅次于东京的大都市。在大阪逗留了两天，除了笨笨给我设计的美美樱花写真，大阪给我留下的是bad impression。有以下几点原因：1.樱花季大阪酒店不仅贵，而且名不副实。小到转不过身来的卫生间、前台招待相比同行不到位的服务、不舒服的床、以及各种老旧设施，导致没有美美的睡过一觉。2.除了大阪城，其他景点基调就是买买买，没落的新世界商业街、正热的道顿崛心斋桥人头攒动挤不过身的药妆店。3.四天王寺等寺庙修缮、通天塔等景点排长队，到处是商业气息。 日本印象三这里最喜欢的还是大阪城的樱花和新世界的元祖炸串。大阪地区较有名的是大阪烧和炸串，大阪烧其实类似国内看到的章鱼小丸子稍作包装修改，炸串就是鸡肉牛肉虾等食材裹上面粉油炸出来，在新世界到处可以看到吃炸串和大阪烧的小摊和门店，有点类似我们这里的垃圾街，只是更卫生更明亮。元祖炸串人气很高，店面外排长队，价格也比其他店贵不少。但是很神奇，这里的炸串真的是油而不腻，超级好吃。章鱼小丸子也吃了，和国内略不同，面粉更糊更软粘牙，但鱿鱼等用料不含糊。在新世界商业街方便是个动物园，好早就限制旅客入内了，晚上回去的时候路过，发现园内一颗大树上停着一树的白色猫头鹰，很壮观，很和谐。 和元祖串串大叔的合影 大阪城樱花写真 小学校入学典礼，妈妈和服出席 据说他的名字就叫日本狗 通天阁上鸟瞰大阪 日本印象四药妆文化，据说药妆店最早是售卖一些高性价比或者快到保质期的品牌护肤化妆品的，后日本民众已经一些外国游客发现这些商品物美价廉，因此药妆店日益受欢迎，到今天发展成巨大的商业形式。在日本随处可见药妆店，有类似松本清的大型连锁药妆，也有名气不怎么大的小店，但很多都挂着 tax free 的招牌，有两个收营台，你可以选择免税也可以选择直接买，买的不多的话不如不免税，因为大的药妆店总是有大拨中国代购客或者热衷药妆的游客在排队。我一路从东京到横滨到大阪到奈良到京都，抱着试一试的态度观察比较各类药妆店，发现大城市较小城市贵，旅游城市较非旅游城市贵，药妆店较便利店贵，大阪心斋桥很贵，不知道中国大妈们是否知道自己其实买的并不便宜，不过他们也不介意吧。另外，药妆店也售卖二类、三类药品，但普遍不如在药店买便宜。 来看看我的日剧场景客串照 奈良奈良，旧称“大和”，距离大阪约40公里，有方便的近铁可以坐，约1小时车程。奈良是个古城，多寺庙。在奈良，无论是酒店还是景点还是城市环境都给人很舒服的感觉。我们入住的super hotel 是除了富士山和式别墅屋意外提供温泉泡汤和免费早餐的酒店，也是我们住过的唯一一家配有中文服务员的酒店，算是奈良较好的酒店了。在奈良，我们留下了美好的回忆。 在奈良公园和春日大社和小鹿亲密接触 在居酒屋吃烤串 这家鸡肉烤串居酒屋是我们吃过的日本小吃中味道较好的，可惜的是我没有用照片记录下来，但如果你去奈良，真的可以体验一下，就在奈良JR站广场附近。相比于在春日社附近吃的拉面来说，美味很多。小店格调灯光暖暖的，吧台内侧是几个年轻小伙子用烤架现烤的各式烤串，最艰难的莫过于点菜，服务员小姑娘不会中文，英文也一般般，遇到不会日文英文又是一般般的我们，真是“相顾无言”了，好歹最后吃的满意，不枉此行。 在奈良的小町欣赏别致的和式庭院 触发此行的重头戏——京都 京都走到京都已经是日本行的后半部分，但也是走到这里才感受到宏达和庄严。 京都的地名不似大阪，以“町”为单位，大多以“条”为片区命名，我们住在乌丸七条，我想大概是乌丸七路的意思吧。乌丸七条别墅苑酒店是个矮矮的家庭式酒店，屋内设施都保证客人居住期间的所有需要满足，入住后不会有清洁人员来打扫，一切自便，室内洗衣机、冰箱、厨卫一应俱全，让旅行就像是回家一样。这也是我喜爱京都的原因之一，好酒店是一个城市给人的第一印象也是至关重要的印象。 日本印象五京都真的遍地寺庙和神社，这两样东西浸透了文化的味道，然而却不厚重，反倒是流着文艺的气息。日式寺院多塔，五重塔、四重塔，不华贵但也不单薄，黑色未主色调 镶白边点缀金色，是中国秦朝喜好的配色。不似唐代鲜艳夸张，反而白看不腻了。日本佛教分多派，不同派系至今仍有对立之势，时不时有学说展会等。我们住的酒店附近有东本愿寺及西本愿寺，相传就是不同派系间博弈的成果。这些寺院广场内都是石子铺设，我不清楚是否有特殊寓意，但场景广阔，给人竖然起敬之感。进入本殿必须拖鞋，内部不让拍照，但进入的人都是安安静静毕恭毕敬钱财参拜，也少人往箱子里扔钱，倒是进入寺院入口有一个为东日本大震灾捐款的箱子。寺院也有法事，遇上法事一般也是有观众席安静坐立。日本这样的寺院很多，有些并不知名。相对来说，神社就要华丽鲜艳很多，比如最著名的伏见稻荷大社，鸟居橘红灿烂给人阳光明媚的感觉。还有平野神社也是，在樱花的映衬下更是灿烂夺目。 东本愿寺 二条城下御花园内 夕阳下京都街道 伏见稻荷大社 千本鸟居 清水寺 和服集 清水寺 纪念物 日本印象六在京都的三日有记忆的吃什只记得生和牛和大阪烧了，大阪烧不值一提，唯独这生和牛记忆深刻。牛肉是小小份但看起来品质很高，要获得售卖生和牛资格不容易，在日本也就为数不多几家。这家名“弘”的烤肉店人气很旺，据说不预定根本没办法在餐点吃上，我们也是夜晚10点抱着试一试的态度去碰碰运气，没想到真的有位置。生牛拌生鸡蛋直接吃，看起来血腥了点，但味道一点不迷糊，生牛一条一条细细的，吃起来像三文鱼。吃到后来反而觉得是不可多得的美味。 生和牛 游客匆匆而过的金阁寺，太过喧闹，也就失去了意境。 不如安安静静 平野神社 北野天满宫 至此，关西之旅结束，期待迪尼斯！","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"日本","slug":"日本","permalink":"https://lchml.com/tags/%E6%97%A5%E6%9C%AC/"}]},{"title":"带XML去旅行之日本（上）","slug":"travel-in-japan-1","date":"2016-05-14T16:00:00.000Z","updated":"2022-05-12T06:10:58.822Z","comments":true,"path":"life/travel-in-japan-1/","link":"","permalink":"https://lchml.com/life/travel-in-japan-1/","excerpt":"每一个樱花树下的灵魂都应被祝福。 ——HML","text":"每一个樱花树下的灵魂都应被祝福。 ——HML 这次旅行是我们有史以来，估计也将是至此以后，最长的一次了，安排了13天，主要是因为婚假加清明足足18天。假期多了，就是这么任性，哈哈！考虑到是婚假，我们一开始心很大，把整个地球都规划了一遍，从欧洲到大洋洲，从北欧6国道澳洲新西兰，好像不出个亚洲对不起自己一样。墨迹墨迹最后就墨迹到了2月份，不得不下决定了。我和我家李笨笨考虑了各个因素，从体力到消费，又从行程缓急到喜好程度，最后居然拍板了个日本，哈！哈！哈！哈！我们果然是两只笨笨！事实证明，去日本玩全本州根本用不了这么久。 行程概要 4.4 杭州 — 浦东国际机场 （上海空港海航酒店） 4.5 成田机场 — 东京田町（ Hotel JAL City Tamachi Tokyo (东京田町日航城市酒店)）— 明治神宫 — 新宿&#x2F;新宿御苑 、歌舞伎一条街— 东京塔 4.6 田町 — 河口湖 （Mizuno Hotel (水之家酒店)） — 各种看富士山 4.7 河口湖 — 新横滨 （Lagunasuite Shinyokohama (新横滨拉古纳套房酒店)）— 拉面博物馆 、江边樱花大道 — 镰仓高校 — 附近瞎转悠或者回横滨瞎转悠 4.8 - 4.10 新横滨 — 新干线 — 大阪&#x2F;谷町四丁目 （APA Hotel Osaka-Tanimachi (大阪谷町APA酒店) — 大阪城 天守阁 — 道顿崛心斋桥 — 四天王寺 — 新世界商业街&amp;通天塔 ） 4.10 谷町四丁目 — 奈良&#x2F;新大宫 （Super Hotel Lohas JR Nara Eki ）— 奈良公园、奈良町、春日大社、奈良小街小巷等 4.11 - 4.13 新大宫 — 京都站&#x2F;（Villa Court Karasuma Nanajo - Guest House In Kyoto(京都别墅苑乌丸七条公寓) ）— 东本愿寺、西本愿寺、二条城、伏见稻荷大社（千本鸟居）、清水寺（穿和服）、金阁寺、岚山、衹园 4.14 - 4.17 京都站 — 新干线 — （三越前Smile Hotel Nihombashi Mitsukoshimae (日本桥三越前微笑酒店)） — 浅草寺、靖国神社、银座、涉谷、秋叶原 、早稻田大学 — 迪斯尼 以上是李笨笨花了好多心血和时间整理的行程，我只是在一边起哄顺便拍个版（嘿嘿，谁叫咱家大事我做主呢），我们的整体行程大概就是按照这个走的，只有些微的调整。不过李笨笨的心血一度因为大阪的酒店被我全盘否定，为此他很是伤心，事后想想不应该怪他，这也算是两个人相处磨合的过程嘛，他只能认栽。 上海事实证明，先买机票再定行程的做法是极其错误的！是极其错误的！是极其错误的！重要的事情说三遍，尤其是去日本这种国家。由于没有限定行程，在携程上抢了特价机票，东京进出，导致我们从关东到关西来回坐了两趟新干线，人均浪费800。其次机票选的是从浦东飞浦东降，也是脑残了，导致我们要提前一天到上海机场附近住一晚，真是很麻烦，浪费时间精力。两个傻帽在火车东站就开始嗨了。4号中午到浦东，由于时间还早而xml又没有去过世博园，所以李笨笨就带xml去了世博园来开开眼。逛完中国馆，去体验大上海的地下交通，不仅做了地铁还体验了磁悬浮。不知道为什么，每次做快速火车总是很开心。空港酒店我要给个8分，环境不错，关键是运气够好的话可以看到夕阳里起飞的空机。 东京5号一早，在兴奋中准时登机，起飞太阳国。大约下午2点左右抵达东京成田机场。虽然之前做过不少攻略，中文字在日本也半猜半认能知道大意，但还是对迎面扑来的地名文字懵逼了。真是给我的日文老师丢脸啊，想从机场去东京市区问了两个人终于找到了之前攻略计划坐的地铁——JR skyliner 。匆忙中把钱包拉在了问询台，要不是工作人员追上来，我这就是出师不利了。瞬间有满满的幸福感。然而，我们还是捡了一辆车上后摇晃了将近2小时才到市区，原本1小时不到的路程因为我们做错了车而拉长不少，去日本的小伙伴可要看清skyliner和特急线不是同一种，当然skyliner也要贵不少。同时，樱花季的太阳国——真的很美。还有，日本强大的轨道交通和上下班齐刷刷西装领带公文包皮鞋挤地铁的上班族。仪式感扑面而来。入住日本的第一家酒店，虽然价格是国内同类酒店的至少翻番且空间狭小，但真的是做到了麻雀虽小五脏俱全。酒店使用的都是资生堂的洗漱用具，最有心的就是智能马桶垫了。我给这个酒店打8分。歌舞伎町不值一提，唯一感受到的是7、8点这一代依然如潮水般过马路的日本上班族的夜生活刚刚开始。倒是这穿城而过的地铁挺有意思，我只在重庆看到过。 日本印象一上班族的迁徙运动。第一天到东京，尤其是住的地方田町，是个类似高新区的地方，上班族特别多，他们似乎完全依赖轨道交通，每天下班要拎包走上几百米甚至几公里如候鸟迁徙一般的黑压压一片涌向地铁站，早上上班自地铁站向四周涌出。他们无一不着洋装（日语：西装）打领带，皮鞋锃光瓦亮，男人脸上多少疲惫，女人脸上妆容依然精致，地铁内极少出声、极少交谈，尽管今年来便携电话广泛使用，仍有不少日本人在电铁内看书阅读。瞧瞧下面这皮鞋：运气好，东京塔就在酒店附近，趁着夜未深，开启了游客模式。樱花里的东京塔：东京塔瞭望台眼内的东京全景，我只能说相机永远都记录不下眼睛所能看到的一切：我这个麻豆是不是很敬业，用你的镜头充当岁月的翻录机： 和很多人一样，没来之前就一心想要循着孤独的美食家大叔的脚步去街头巷尾寻找家庭料理。找到一家很对眼的，可惜这家主人不会中文或者英文又对我们蹩脚到家的日语不感冒更加似乎有点讨厌中国人的样子，只能退而且其次，找了另一家。塞翁失马，这一家店家是个日本大叔，服务员是来自苏州在日本打工的大婶，和我们渐渐聊得热络，点了他家的刺身拼盘和清酒，他还送了我们半条多线鱼。大叔苦口婆心，让我们小心日本的中国人，真不知道作何感想。倒是一段珍贵的回忆，可惜少了合影。 第二天一早前往新宿御苑，一个适合出写真的地方。尽管有人很多，但，阳光很好，心情很美丽。出发河口湖，那座像涂了奶油被人咬掉一口的富士山，我们来了。 富士山去之前一直担心下雨看不到富士山，事实上天公还是做了一回美，小幸运。从新宿坐长途大巴前往富士山，可以坐到河口湖，从河口湖的角度可以看到全景，当然你得选一个视角较好的位置。售票机有可能已经售完，没有关系，去人工窗口服务人员会帮忙安排，只要不是运气太背，都是可以如愿的。大巴大约1个多小时就能抵达河口湖了。一路拖着行李箱，我们来到了酒店的合适小屋。这是我最喜欢的一家酒店，我给打9.5分，酒店正对富士山，温泉泡汤。远山眉黛这张图尽管美中不足，是因为温度导致樱花未满，但也正因此变得独一无二。 我觉得富士山可以出一个特辑，就叫“小幸运”，怎么样？ 富士山景区较少餐饮，多是酒店自带，以下是为数不多的日式饭厅，吃食无非是定食之类的，味道也是一般。倒是酒店自带的合式早餐，满满的用心，满足了口腹之欲的同时也是视觉的享受。 日本印象二日本的高速公路两边很少看到大片的无人山区，即使是在大片的田野间，仍有密集的住宅，人口密度很大。大多日式小屋最高2层，宽宽大大矮矮方方但是极宽敞，各家院子屋后都是盛开的樱花，不由想到我们的农村，风景却没这般好。日本车90%丰田，剩下的也是本田、尼桑分去一杯羹，极少见他国车，很少见到国内的三大车。日本车从形态上也是能小则小，一般的类似面包车的小车都做得方方正正连前面的车头都削去，方便他们在大街小巷穿梭自如又省油，我们称他们小方车。 横滨由于去往大阪需要乘坐新干线，且最近需在横滨乘坐，所以我们安排了一天在横滨，顺便去看看slum dunk。富士山的第二天早晨下着小雨，我们坐上开往横滨的大巴。横滨的酒店相对于东京来说价格相差不大，服务更周到一些，可惜只住一晚，出门就是全家，走两步又有7-11，走几百米就是新横滨站，很是便利。要打个8.5分。横滨算是东京的附属市，但更靠近海，对横滨的印象源于大学时的日语老师，他来自神奈川县横滨市。神田老师一看就看得出是个日本人，有着一头柔顺的亮发不短，但很干净。问他为用的什么洗发水，他总说“花王啊，用花王就是这样自信”。他说话慢慢的，他教我们念“よこはま”（日文：横滨市）。对他的印象止于此了。横滨的湿度很大，海风很强，以至于我们刚下地铁，就被海风吹蒙了。发现好多女士都穿着国内也流行的长款风衣，几乎是人手一件。猜测也许这才是风衣流行起来的原因，在横滨真的需要它来挡风啊。 酒店附近不知名的樱花大道，好想一直美下去。发现了小心机没有樱花是少女心 日本的拉面文化源于中国，但发扬出了自己的特色，在横滨悠哉晃去拉面博物馆也算是涨了小知识，原来日本也有那么多种类的拉面，各个县市喜好不一，也是挺有意思的。 追随年少时的热情，去看一眼樱木花道曾经战斗过的地方——我们倒了3班地铁，寒风中颤抖着来到了镰仓高校，还在那个标志性的地方摆了POSE留了年也是不枉此行了。遇到一位大哥更拼，穿着樱木的球衣寻梦来了。据说这可是游客排长队的取景点。 晚上回到横滨，休息一晚，明天将要向关西进发了！","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"日本","slug":"日本","permalink":"https://lchml.com/tags/%E6%97%A5%E6%9C%AC/"}]},{"title":"配置中心","slug":"disconf","date":"2016-04-21T16:00:00.000Z","updated":"2022-05-12T06:05:34.547Z","comments":true,"path":"technology/disconf/","link":"","permalink":"https://lchml.com/technology/disconf/","excerpt":"作为服务器开发人员，对配置文件一定不陌生，也一定曾经踩过很多配置文件的坑。","text":"作为服务器开发人员，对配置文件一定不陌生，也一定曾经踩过很多配置文件的坑。 当服务器集群数量较少，系统采用all in one的架构时，我们可以采用每台服务器单独使用本地配置的方法，配置文件跟发布包一起采用用VCS管理。但是随着服务器集群的扩展，当服务器数量变的庞大时，all in one的架构会变的笨重臃肿，带来更新发布流程复杂，雪崩风险升高等问题。这时all in one的架构就不那么适用了。我们需要考虑对系统进行改造，做微服务化的分解。这时配置文件和配置项等就不再适合使用前面的方案。而是需要一个独立的配置中心对所有微服务的配置进行控制。 目前开源世界中已经有许多成熟的配置中心实现方案，如阿里的Diamond、360的QConf、spring的Cloud Config、百度的disconf等等。其中的区别这里就不一一对比了，每个都能完成对应的任务，选择适合自己情况的即可。由于我们服务90%是基于java的，disconf的推模式比Diamond的拉模式在效率上要高一些，同时disconf也更便于做二次开发，所以选择了disconf。 实现配置中心配置中心的功能很简单，一句话概括就是：负责管理所有服务的配置。 源码编译打包首先到github上找到disconf的源码，并fork一份到自己的git仓库（这样可以便于自己调试开发），然后在用于部署配置中心的服务器上clone一份源码。目录结构如下： /Users/lc/disconf/ + disconf-src + resources + war + deploy.sh disconf-src是源码目录，resources是配置目录，包含以下四个配置文件： jdbc-mysql.properties (数据库配置) redis-config.properties (Redis配置) zoo.properties (Zookeeper配置) application.properties (应用配置） war是部署目录。deploy.sh是打包脚本，内容如下： ONLINE_CONFIG_PATH=/Users/lc/disconf/resources WAR_ROOT_PATH=/Users/lc/disconf/war export ONLINE_CONFIG_PATH export WAR_ROOT_PATH cd disconf-src/disconf-web sh deploy/deploy.sh 运行deploy.sh脚本进行编译打包，最后会在war文件夹中生成部署用的文件。 部署部署之前需要先安装依赖的软件：MySQL、Tomcat、Nginx、zookeeper、Redis（如果是线上环境使用，那么这些依赖软件的部署需要考虑高可用问题），具体安装过程这里就不说了。 数据库准备安装完mysql之后，需要对数据库进行初始化。先后执行disconf-src&#x2F;disconf-web&#x2F;sql中的sql文件： 1-init_table.sql 主要是生成tables 2-data.sql 主要是生成测试数据 20141201&#x2F;disconf.sql 升级，支持 管理员角色、用户邮箱 20141226&#x2F;disconf.sql 升级，支持 URL权限控制 20150101&#x2F;disconf.sql 增加一个测试数据 20150320&#x2F;disconf.sql 增加reloadable config的测试文件 zookeeper准备安装好zookeeper集群后，在resources目录下的zoo.properties中配置好所有的zookeeper地址，并指定路径前缀: hosts=127.0.0.1:8581 # 测试用，所以只配置了一台zookeeper zookeeper_url_prefix=/disconf redis准备redis在这里只作为账号登录缓存使用，所以没有也没关系，可以先不部署。 tomcat部署数据库准备好之后，接着部署tomcat，在server.xml文件的host节点下增加Context：&lt;Context path=&quot;&quot; docBase=&quot;/Users/lc/disconf/war&quot;/&gt;设定好tomcat端口后启动tomcat nginx部署disconf-web的部署采用了前后端完全分离的模式，所以前端页面直接通过nginx访问。在nginx中增加如下配置： upstream disconf &#123; server 127.0.0.1:8085; &#125; server &#123; listen 8081; server_name localhost; location / &#123; root /Users/lc/disconf/war/html; if ($query_string) &#123; expires max; &#125; &#125; location ~ ^/(api|export) &#123; proxy_pass_header Server; proxy_set_header Host $http_host; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_pass http://disconf; &#125; &#125; 启动上述过程完成后，访问nginx的监听地址即可进入disconf的管理页面。 应用部署完disconf-web，接下来我们需要在自己的服务中集成disconf-clent实现配置管理。disconf-client分为注解式注入和xml配置文件注入两种方式，并且两种方式都支持配置文件和配置项的管理。通过disconf-spring-boot-web可以感受简单的使用示例，只需要修改配置文件disconf.properties中的conf_server_host为上面部署的nginx地址然后运行，成功获取到配置中心的配置后，在disconf-web上对应的配置实例列表可以看到。 由于是系统的改造过程，所以并不适合采用demo中的直接在JavaBean的get方法上注解每个配置项的方法。为了适应原有系统的逻辑，我们需要的是配置文件的统一管理，同时又能让配置及时生效。因此结合disconf的特性和原有系统的特性，选择用基于注解的配置类和回调类实现配置文件的管理。首先在pom文件中增加disconf-client的依赖，然后在工程中增加WebApiConfig和WebApiConfigCallback两个类： @Service @DisconfFile(filename = &quot;web-api.xml&quot;) public class WebApiConfig &#123; &#125; @DisconfUpdateService(classes = &#123; WebApiConfig.class&#125;, confFileKeys = &#123;&quot;testJson.json&quot;&#125;) public class WebApiConfigCallback implements IDisconfUpdate &#123; public void reload() throws Exception &#123; System.out.println(&quot;config update callback, do reload here&quot;); // 回调重载配置 &#125; &#125; 对于基于springmvc的web工程，由于disconf必须在最先启动，所以在web.xml的最前面增加如下配置： &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:disconf.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 同时在classpath下增加disconf.properties和disconf.xml两个配置文件。具体配置这里就不贴了，看demo就知道了。最后启动应用时（别忘了在log4j的配置中增加com.baidu的log）就可以看到应用会先从配置中心下载web-api.xml文件到classpath，然后开始初始化进程。接着我们来测试回调的使用，在disconf页面上找到对应的配置文件web-api.xml，修改它的内容就可以看到所有使用该配置的服务触发了回调方法。 上面的使用都是基于spring的应用，如果原工程是非spring的怎么办呢？很简单，手动载入disconf即可。在main方法的最前面调用如下方法： // 初始化disconf private static void contextInitialized() &#123; String[] fn = new String[] &#123;&quot;disconf.xml&quot;&#125;; new ClassPathXmlApplicationContext(fn); &#125; 总结配置中心的部署实现相对比较简单，但是它是微服务化过程中不可缺少的一部分。在实践过程中我们需要考虑怎么使用配置中心才能最合理的适配原有的系统，哪些配置文件和配置项适合用或应该用配置中心管理，disconf的功能能否满足系统的需求，是否需要做二次开发等等，这些问题都应该充分考虑到。同时在学习使用disconf的过程中，可以想想有哪些优秀的架构设计可以学习借鉴。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"disconf","slug":"disconf","permalink":"https://lchml.com/tags/disconf/"},{"name":"服务发现","slug":"服务发现","permalink":"https://lchml.com/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"}]},{"title":"Netty源码分析·贰","slug":"netty2","date":"2016-01-19T16:00:00.000Z","updated":"2022-05-12T06:07:58.708Z","comments":true,"path":"technology/netty2/","link":"","permalink":"https://lchml.com/technology/netty2/","excerpt":"接上文","text":"接上文 上文我们分析了initAndRegister的过程，现在接着分析tag2的doBind0过程: 1234567891011121314151617private static void doBind0( final ChannelFuture regFuture, final Channel channel, final SocketAddress localAddress, final ChannelPromise promise) &#123; // This method is invoked before channelRegistered() is triggered. Give user handlers a chance to set up // the pipeline in its channelRegistered() implementation. channel.eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; if (regFuture.isSuccess()) &#123; channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE); &#125; else &#123; promise.setFailure(regFuture.cause()); &#125; &#125; &#125;);&#125; channel.bind(localAddress, promise)内部执行了如下代码： 1234567public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123; return pipeline.bind(localAddress, promise); &#125;public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123; return tail.bind(localAddress, promise);&#125; ChannelPipeline在上文中我们还留有pipeline.fireChannelRegistered()没有分析。接下来就介绍ChannelPipeline这个重要的类。DefaultChannelPipeline是ChannelPipeline的默认实现类，内部维护了final AbstractChannelHandlerContext head和final AbstractChannelHandlerContext tail两个指针，分别指向链表的头尾。而AbstractChannelHandlerContext本身是一个双向链表结构，volatile AbstractChannelHandlerContext next和volatile AbstractChannelHandlerContext prev分别为每个节点的双向指针。DefaultChannelHandlerContext是AbstractChannelHandlerContext的默认实现，其中包含一个ChannelHandler属性。这就是一个典型的Intercepting Filter模式。好了，现在我们回头再看一次ServerBootstrap.init()方法。它对NioServerSocketChannel的ChannelPipeline执行了两次addLast()操作： 123456789101112ChannelPipeline p = channel.pipeline();if (handler() != null) &#123; p.addLast(handler());&#125;p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123; @Override public void initChannel(Channel ch) throws Exception &#123; ch.pipeline().addLast(new ServerBootstrapAcceptor( currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)); &#125;&#125;); 第一次添加的是ServerBootstrap的handler，第二次添加的是匿名类ChannelInitializer的实现。所以此时负责监听的NioServerSocketChannel的职责链如下：HEAD-&gt;AbstractServerBootstrap$handler-&gt;ServerBootstrap$1-&gt;TAIL。 现在我们再来看pipeline.fireChannelRegistered()方法，它依次执行了下面的方法： 123456789101112131415161718192021222324252627282930313233343536373839public ChannelPipeline fireChannelRegistered() &#123; head.fireChannelRegistered(); return this;&#125;public ChannelHandlerContext fireChannelRegistered() &#123; AbstractChannelHandlerContext next = findContextInbound(); next.invoker().invokeChannelRegistered(next); return this;&#125;private AbstractChannelHandlerContext findContextInbound() &#123; AbstractChannelHandlerContext ctx = this; do &#123; ctx = ctx.next; &#125; while ((ctx.skipFlags &amp; MASKGROUP_INBOUND) == MASKGROUP_INBOUND); return ctx;&#125;public void invokeChannelRegistered(final ChannelHandlerContext ctx) &#123; if (executor.inEventLoop()) &#123; invokeChannelRegisteredNow(ctx); &#125; else &#123; executor.execute(new OneTimeTask() &#123; @Override public void run() &#123; invokeChannelRegisteredNow(ctx); &#125; &#125;); &#125;&#125;public static void invokeChannelRegisteredNow(ChannelHandlerContext ctx) &#123; try &#123; ctx.handler().channelRegistered(ctx); &#125; catch (Throwable t) &#123; notifyHandlerException(ctx, t); &#125;&#125; 我们知道handler链是HEAD-&gt;AbstractServerBootstrap$handler-&gt;ServerBootstrap$1-&gt;TAIL。findContextInbound()方法返回的next就是ServerBootstrap$handler，找到的第一个没有被注解为Skip的handler返回。这里Skip注解了的方法表示职责链中碰到该方法时跳过。在构造方法中会通过skipFlags()方法初始化skipFlags。 1234567891011121314static int skipFlags(ChannelHandler handler) &#123; WeakHashMap&lt;Class&lt;?&gt;, Integer&gt; cache = skipFlagsCache.get(); Class&lt;? extends ChannelHandler&gt; handlerType = handler.getClass(); int flagsVal; Integer flags = cache.get(handlerType); if (flags != null) &#123; flagsVal = flags; &#125; else &#123; flagsVal = skipFlags0(handlerType); cache.put(handlerType, Integer.valueOf(flagsVal)); &#125; return flagsVal;&#125; 在EchoServer对应的职责链变成HEAD-&gt;LoggingHandler-&gt;ServerBootstrap$1-&gt;TAIL，所以找到的第一个handler是LoggingHandler，执行如下方法： 1234public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123; log(Event.REGISTERED); ctx.fireChannelRegistered();&#125; 记录日志之后，该方法会继续调用ctx.fireChannelRegistered()，所以重复上面的过程，找到职责链中的下一个handler为匿名类ServerBootstrap$1。由于匿名类继承于ChannelInitializer，所以执行ChannelInitializer.channelRegistered()方法： 12345678910111213141516171819public final void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123; ChannelPipeline pipeline = ctx.pipeline(); boolean success = false; try &#123; initChannel((C) ctx.channel()); pipeline.remove(this); ctx.fireChannelRegistered(); success = true; &#125; catch (Throwable t) &#123; logger.warn(&quot;Failed to initialize a channel. Closing: &quot; + ctx.channel(), t); &#125; finally &#123; if (pipeline.context(this) != null) &#123; pipeline.remove(this); &#125; if (!success) &#123; ctx.close(); &#125; &#125;&#125; 方法中回调了ServerBootstrap$1中的initChannel()方法： 1234public void initChannel(Channel ch) throws Exception &#123; ch.pipeline().addLast(new ServerBootstrapAcceptor( currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));&#125; 该方法中把ServerBootstrapAcceptor添加到pipeline中，所以此时职责链变成了HEAD-&gt;LoggingHandler-&gt;ServerBootstrap$1-&gt;ServerBootstrapAcceptor-&gt;TAIL。接着pipeline.remove(this)语句把自己从pipeline中删掉了，所以职责链变成HEAD-&gt;LoggingHandler-&gt;ServerBootstrapAcceptor-&gt;TAIL。接着继续往下找，找到TAIL这个handler，并执行对应的channelRegistered方法。至此pipeline.fireChannelRegistered()方法完成。 doBind分析完pipeline，我们再来看pipeline.bind(localAddress, promise)方法，它最终调用了tail.bind(localAddress, promise)方法，注意是tail不是head，bind操作在职责链中是反向进行的。 123456789101112131415161718192021222324252627282930313233343536public ChannelFuture bind(final SocketAddress localAddress, final ChannelPromise promise) &#123; AbstractChannelHandlerContext next = findContextOutbound(); next.invoker().invokeBind(next, localAddress, promise); return promise;&#125;public void invokeBind( final ChannelHandlerContext ctx, final SocketAddress localAddress, final ChannelPromise promise) &#123; if (localAddress == null) &#123; throw new NullPointerException(&quot;localAddress&quot;); &#125; if (!validatePromise(ctx, promise, false)) &#123; // promise cancelled return; &#125; if (executor.inEventLoop()) &#123; invokeBindNow(ctx, localAddress, promise); &#125; else &#123; safeExecuteOutbound(new OneTimeTask() &#123; @Override public void run() &#123; invokeBindNow(ctx, localAddress, promise); &#125; &#125;, promise); &#125;&#125;public static void invokeBindNow( final ChannelHandlerContext ctx, final SocketAddress localAddress, final ChannelPromise promise) &#123; try &#123; ctx.handler().bind(ctx, localAddress, promise); &#125; catch (Throwable t) &#123; notifyOutboundHandlerException(t, promise); &#125;&#125; 根据上面的分析，EchoServer的职责链完成register之后是这样的：HEAD-&gt;LoggingHandler-&gt;ServerBootstrapAcceptor-&gt;TAIL。从TAIL向前，执行每个handler的bind方法。实际最后只执行了head中的bind方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void bind( ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception &#123; unsafe.bind(localAddress, promise);&#125;public final void bind(final SocketAddress localAddress, final ChannelPromise promise) &#123; if (!promise.setUncancellable() || !ensureOpen(promise)) &#123; return; &#125; // See: https://github.com/netty/netty/issues/576 if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp; localAddress instanceof InetSocketAddress &amp;&amp; !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp; !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.isRoot()) &#123; // Warn a user about the fact that a non-root user can&#x27;t receive a // broadcast packet on *nix if the socket is bound on non-wildcard address. logger.warn( &quot;A non-root user can&#x27;t receive a broadcast packet if the socket &quot; + &quot;is not bound to a wildcard address; binding to a non-wildcard &quot; + &quot;address (&quot; + localAddress + &quot;) anyway as requested.&quot;); &#125; boolean wasActive = isActive(); try &#123; doBind(localAddress); &#125; catch (Throwable t) &#123; safeSetFailure(promise, t); closeIfClosed(); return; &#125; if (!wasActive &amp;&amp; isActive()) &#123; invokeLater(new OneTimeTask() &#123; @Override public void run() &#123; pipeline.fireChannelActive(); &#125; &#125;); &#125; safeSetSuccess(promise);&#125; 其中真正执行bind操作的在doBind方法中： 123protected void doBind(SocketAddress localAddress) throws Exception &#123; javaChannel().socket().bind(localAddress, config.getBacklog());&#125; 绑定端口后执行invokeLater方法： 123456789101112131415161718private void invokeLater(Runnable task) &#123; try &#123; // This method is used by outbound operation implementations to trigger an inbound event later. // They do not trigger an inbound event immediately because an outbound operation might have been // triggered by another inbound event handler method. If fired immediately, the call stack // will look like this for example: // // handlerA.inboundBufferUpdated() - (1) an inbound handler method closes a connection. // -&gt; handlerA.ctx.close() // -&gt; channel.unsafe.close() // -&gt; handlerA.channelInactive() - (2) another inbound handler method called while in (1) yet // // which means the execution of two inbound handler methods of the same handler overlap undesirably. eventLoop().unwrap().execute(task); &#125; catch (RejectedExecutionException e) &#123; logger.warn(&quot;Can&#x27;t invoke task later as EventLoop rejected it&quot;, e); &#125;&#125; 该方法只是把task加入到EventLoopGroup的队列中，并不会马上执行，需要等到safeSetSuccess(promise)执行完后的下个循环才会执行。 123456789101112131415161718192021222324252627282930313233343536373839protected final void safeSetSuccess(ChannelPromise promise) &#123; if (!(promise instanceof VoidChannelPromise) &amp;&amp; !promise.trySuccess()) &#123; logger.warn(&quot;Failed to mark a promise as success because it is done already: &#123;&#125;&quot;, promise); &#125;&#125;public boolean trySuccess() &#123; return trySuccess(null);&#125;public boolean trySuccess(V result) &#123; if (setSuccess0(result)) &#123; notifyListeners(); return true; &#125; return false;&#125;private boolean setSuccess0(V result) &#123; if (isDone()) &#123; return false; &#125; synchronized (this) &#123; // Allow only once. if (isDone()) &#123; return false; &#125; if (result == null) &#123; this.result = SUCCESS; &#125; else &#123; this.result = result; &#125; if (hasWaiters()) &#123; notifyAll(); &#125; &#125; return true;&#125; safeSetSuccess把状态设为成功以后，执行notifyListeners()方法，由于此时listeners为null，所以直接返回。 12345678910111213private void notifyListeners() &#123; // This method doesn&#x27;t need synchronization because: // 1) This method is always called after synchronized (this) block. // Hence any listener list modification happens-before this method. // 2) This method is called only when &#x27;done&#x27; is true. Once &#x27;done&#x27; // becomes true, the listener list is never modified - see add/removeListener() Object listeners = this.listeners; if (listeners == null) &#123; return; &#125; // 省略&#125; 设置成功状态后，开始执行上面invokeLater中的task，也就是pipeline.fireChannelActive()： 123456789public ChannelPipeline fireChannelActive() &#123; head.fireChannelActive(); // 执行每个handler的channelActive if (channel.config().isAutoRead()) &#123; channel.read(); &#125; return this;&#125; 由于channel.config().isAutoRead()默认返回true，所以执行channel.read()。 1234public Channel read() &#123; pipeline.read(); return this;&#125; 同样的，pipeline从后往前执行每个handler的read()方法，最后执行到head.read() 12345678910111213141516171819202122232425262728293031323334353637383940public void read(ChannelHandlerContext ctx) &#123; unsafe.beginRead();&#125;public final void beginRead() &#123; if (!isActive()) &#123; return; &#125; try &#123; doBeginRead(); &#125; catch (final Exception e) &#123; invokeLater(new OneTimeTask() &#123; @Override public void run() &#123; pipeline.fireExceptionCaught(e); &#125; &#125;); close(voidPromise()); &#125;&#125;protected void doBeginRead() throws Exception &#123; // Channel.read() or ChannelHandlerContext.read() was called if (inputShutdown) &#123; return; &#125; final SelectionKey selectionKey = this.selectionKey; if (!selectionKey.isValid()) &#123; return; &#125; readPending = true; final int interestOps = selectionKey.interestOps(); if ((interestOps &amp; readInterestOp) == 0) &#123; selectionKey.interestOps(interestOps | readInterestOp); &#125;&#125; 在NioServerSocketChannel初始化时，我们指定了readInterestOp为SelectionKey.OP_ACCEPT，也就是16。最后执行selectionKey.interestOps(interestOps | readInterestOp)，等同于selectionKey.interestOps(SelectionKey.OP_ACCEPT)，也就是向selector注册了accept事件的监听。至此bind操作完成，接着来看下一步sync()。 12345public Promise&lt;V&gt; sync() throws InterruptedException &#123; await(); rethrowIfFailed(); return this;&#125; 由于setSafeSuccess中已经吧状态设置为成功，所以await()方法会直接返回。到此ChannelFuture f = b.bind(PORT).sync()完成。最后一步f.channel().closeFuture().sync()，而由于closeFuture这个属性的执行结果一直没有赋值，所以一直处于wait状态。至此，主线程处于wait状态，并通过子线程无限循环，来完成客户端请求。 小结 通过channel()方法设置不同类型的Socket。通过childHandler()设置SocketChannel的职责链。 bind()不同于JavaSocket的bind，主要完成initAndRegister()和doBind0()过程。 initAndRegister中主要可以分为三个步骤：createChannel(), init(channel), channel.unsafe().register()。 doBind0主要完成javaChannel().register(eventLoop().selector, 0, this)功能，并触发channelActive()事件，设置selectionKey.interestOps(SelectionKey.OP_ACCEPT)。 待续","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"netty","slug":"netty","permalink":"https://lchml.com/tags/netty/"},{"name":"TCP","slug":"TCP","permalink":"https://lchml.com/tags/TCP/"}]},{"title":"Netty源码分析·壹","slug":"netty1","date":"2016-01-06T16:00:00.000Z","updated":"2022-05-12T05:59:05.867Z","comments":true,"path":"technology/netty1/","link":"","permalink":"https://lchml.com/technology/netty1/","excerpt":"Netty是一个高性能、异步事件驱动的NIO框架。作为当前最流行的NIO框架，Netty在大数据分布式计算、游戏行业、通信行业等都获得了广泛应用，一些著名开源组件也是基于Netty的NIO框架构建。本文对Netty的NIO封装源码略作分析，知其然知其所以然。","text":"Netty是一个高性能、异步事件驱动的NIO框架。作为当前最流行的NIO框架，Netty在大数据分布式计算、游戏行业、通信行业等都获得了广泛应用，一些著名开源组件也是基于Netty的NIO框架构建。本文对Netty的NIO封装源码略作分析，知其然知其所以然。 背景知识在JDK1.4之前，java的所有socket通信都只能采用同步阻塞模式，也就是BIO。这种一个请求一个应答的通信模型简化了上层应用的开发，但却有严重的性能问题。首先我们来看一下BIO的服务端通信模型：通常由一个独立的Acceptor线程负责监听客户端连接，当收到客户端连接后，产生一个新的线程来处理该客户端的请求，处理完成后返回应答，最后销毁线程。这就是典型的一个请求一个应答模型。这里缺点很明显，频繁的线程创建销毁会销耗大量系统资源，同时当并发请求量很大的时候，线程数量急剧上升，性能急剧下降，最后可能发生宕机。 为了解决这些问题，后来对一连接一线程的模型进行了优化，改为线程池加任务队列模型。收到一个客户端请求时，先将请求放入任务队列，由线程池中的空闲线程从队列中取出任务并处理。这又被称为伪异步通信模型。它能解决BIO的问题，但还是无法从根本上解决问题，由于IO的读写操作会被阻塞，当并发量增加时，会导致任务队列中的任务不断堆积，客户端请求的响应时间变长，最终导致内存溢出或者拒绝新任务。 IO模型Unix网络编程中把IO模型分为五类： 1、阻塞IO：最常用得IO模型，默认情况下所有文件操作都是阻塞的。以socket为例，当我们调用recvfrom接收来自socket的数据时，该方法会一直阻塞，直到数据报达到且被拷贝到应用进程的缓冲区或者发生错误。 2、非阻塞IO：调用recvfrom时，如果该缓冲区没有数据的话，就会直接返回EWOULDBLOCK错误，而不会阻塞等待。一般会对非阻塞IO进行轮询检查状态，看内核是不是有数据进来。 3、IO复用：Linux提供了select&#x2F;poll，进程通过提交多个文件描述符（fd）给select或pull系统调用，阻塞在select，由select帮我们侦听提交的fd是否就绪。但是select&#x2F;poll是顺序扫描fd的，支持的fd数量有限。因此linux还提供了epoll系统调用，epoll是基于事件驱动方式，而不是顺序扫描。当有fd准备就绪时，会立即回调函数callback。 4、信号驱动IO：开启socket信号驱动IO功能，并通过系统调用signaction执行一个信号处理函数。 5、异步IO：告知内核启动某个操作，并让内核在整个操作完成后通知我们。 关于linux上IO网了编程的只是，推荐一本书Unix网络编程，其中有详细的介绍。 从JDK1.4开始，Java提供了一套专门的类库来支持非阻塞的IO操作，java.nio包中这套接口是新提供的IO接口，因此叫New IO，这就是它被称为Java NIO的原因。 NIO是基于事件驱动思想来实现的，采用Reactor模式，主要解决BIO模型中一个服务端无法同时并发处理大量客户端连接的问题。NIO基于Selector轮询，当socket有数据可读、可写、连接、请求接入等事件时，操作系统会触发Selector返回准备就绪的SelectorKey集合。通过SelectableChannel进行读写操作。由于JDK的Selector底层是基于epoll实现的，所以不受2048连接数限制，理论上可以同时处理操作系统最大文件句柄个数的连接。 目前业界主流的NIO框架有两个：Netty和Mina。两个框架出自同一人之手，其中渊源大家有兴趣可以再网上看看。 Netty服务端相比于BIO，NIO的开发要复杂的多，因此开发出稳定高性能的异步通信框架一直是个难题。Netty为了对开发者屏蔽NIO通信的底层细节，对底层NIO网络通信做了封装，使开发者只需关注自己的业务实现，降低开发工作量和开发难度。 获取源码从GitHub上获取源码：git clone https://github.com/netty/netty.git。netty是用maven构建的，所以直接通过maven导入IDE即可。 EchoServer例子首先我们来看example模块中的EchoServer，这是一个典型的Netty服务端应用。我们来分析服务启动的过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 public final class EchoServer &#123; static final boolean SSL = System.getProperty(&quot;ssl&quot;) != null; static final int PORT = Integer.parseInt(System.getProperty(&quot;port&quot;, &quot;8007&quot;)); public static void main(String[] args) throws Exception &#123; // Configure SSL. final SslContext sslCtx; if (SSL) &#123; SelfSignedCertificate ssc = new SelfSignedCertificate(); sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build(); &#125; else &#123; sslCtx = null; &#125; // Configure the server. //bossGroup线程池用来接受客户端的连接请求 EventLoopGroup bossGroup = new NioEventLoopGroup(1); //workerGroup线程池用来处理boss线程池里面的连接的数据 EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) //AbstractBootstrap.option()用来设置ServerSocket的参数，AbstractBootstrap.childOption()用来设置Socket的参数。 .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) //ChannelInitializer是一个特殊的handler，用来初始化ChannelPipeline里面的handler链。 //这个特殊的ChannelInitializer在加入到pipeline后，在initChannel调用结束后,自身会被remove掉，从而完成初始化的效果。 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc())); &#125; //p.addLast(new LoggingHandler(LogLevel.INFO)); p.addLast(new EchoServerHandler()); &#125; &#125;); // Start the server. ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync(); &#125; finally &#123; // Shut down all event loops to terminate all threads. bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; NioEventLoopGroup首先创建两个NioEventLoopGroup，当调用NioEventLoopGroup构造方法时，首先调用其父类MultithreadEventLoopGroup构造方法，父类获得默认的线程总数，其默认值是Runtime.getRuntime().availableProcessors()*2。 12345678static &#123; DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt( &quot;io.netty.eventLoopThreads&quot;, Runtime.getRuntime().availableProcessors() * 2)); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;, DEFAULT_EVENT_LOOP_THREADS); &#125;&#125; 接着调用自身构造器： 12345678910111213141516public NioEventLoopGroup() &#123;this(0);&#125;public NioEventLoopGroup(int nThreads, Executor executor) &#123; this(nThreads, executor, SelectorProvider.provider());&#125;public NioEventLoopGroup(int nThreads) &#123; this(nThreads, (Executor) null);&#125;public NioEventLoopGroup(int nThreads, ThreadFactory threadFactory) &#123; this(nThreads, threadFactory, SelectorProvider.provider());&#125;public NioEventLoopGroup( int nThreads, ThreadFactory threadFactory, final SelectorProvider selectorProvider) &#123; super(nThreads, threadFactory, selectorProvider);&#125; 继续调用父类构造器 123protected MultithreadEventLoopGroup(int nEventLoops, Executor executor, Object... args) &#123; super(nEventLoops == 0 ? DEFAULT_EVENT_LOOP_THREADS : nEventLoops, executor, args);&#125; 改构造器继续调用父类构造器 123protected MultithreadEventExecutorGroup(int nEventExecutors, Executor executor, Object... args) &#123; this(nEventExecutors, executor, false, args);&#125; 初始化上面的构造过程主要完成：1、设置默认DefaultThreadFactory线程工厂，设置线程池名称和线程名称。2、初始化children数组，然后通过NioEventLoopGroup.newChild()完成child属性设置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private MultithreadEventExecutorGroup(int nEventExecutors, Executor executor, boolean shutdownExecutor, Object... args) &#123; if (nEventExecutors &lt;= 0) &#123; throw new IllegalArgumentException( String.format(&quot;nEventExecutors: %d (expected: &gt; 0)&quot;, nEventExecutors)); &#125; if (executor == null) &#123; executor = newDefaultExecutorService(nEventExecutors); shutdownExecutor = true; &#125; children = new EventExecutor[nEventExecutors]; if (isPowerOfTwo(children.length)) &#123; chooser = new PowerOfTwoEventExecutorChooser(); &#125; else &#123; chooser = new GenericEventExecutorChooser(); &#125; for (int i = 0; i &lt; nEventExecutors; i ++) &#123; boolean success = false; try &#123; children[i] = newChild(executor, args); success = true; &#125; catch (Exception e) &#123; // TODO: Think about if this is a good exception type throw new IllegalStateException(&quot;failed to create a child event loop&quot;, e); &#125; finally &#123; if (!success) &#123; for (int j = 0; j &lt; i; j ++) &#123; children[j].shutdownGracefully(); &#125; for (int j = 0; j &lt; i; j ++) &#123; EventExecutor e = children[j]; try &#123; while (!e.isTerminated()) &#123; e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS); &#125; &#125; catch (InterruptedException interrupted) &#123; // Let the caller handle the interruption. Thread.currentThread().interrupt(); break; &#125; &#125; &#125; &#125; &#125; final boolean shutdownExecutor0 = shutdownExecutor; final Executor executor0 = executor; final FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() &#123; @Override public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123; if (terminatedChildren.incrementAndGet() == children.length) &#123; terminationFuture.setSuccess(null); if (shutdownExecutor0) &#123; // This cast is correct because shutdownExecutor0 is only try if // executor0 is of type ExecutorService. ((ExecutorService) executor0).shutdown(); &#125; &#125; &#125; &#125;; for (EventExecutor e: children) &#123; e.terminationFuture().addListener(terminationListener); &#125; Set&lt;EventExecutor&gt; childrenSet = new LinkedHashSet&lt;EventExecutor&gt;(children.length); Collections.addAll(childrenSet, children); readonlyChildren = Collections.unmodifiableSet(childrenSet);&#125; 在newChild方法中，主要完成NioEventLoop实例构建。然后调用openSelector方法创建selector对象。其中进行了一个优化，设置了sun.nio.ch.SelectorImpl的selectedKeys和publicSelectedKeys属性。根据NioEventLoop.run()方法内部直接调用 processSelectedKeysOptimized(selectedKeys.flip())，并且没有直接使用selector.selectedKeys()。最后循环完成children数组的初始化children[i] = newChild(executor, args);，进而完成NioEventLoopGroup对象初始化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Overrideprotected EventLoop newChild(Executor executor, Object... args) throws Exception &#123; return new NioEventLoop(this, executor, (SelectorProvider) args[0]);&#125;NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider) &#123; super(parent, executor, false); if (selectorProvider == null) &#123; throw new NullPointerException(&quot;selectorProvider&quot;); &#125; provider = selectorProvider; selector = openSelector();&#125;private Selector openSelector() &#123; final Selector selector; //初始化Selector对象 try &#123; selector = provider.openSelector(); &#125; catch (IOException e) &#123; throw new ChannelException(&quot;failed to open a new selector&quot;, e); &#125; if (DISABLE_KEYSET_OPTIMIZATION) &#123; return selector; &#125; try &#123; SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet(); //初始化SelectedSelectionKeySet //进行了一个优化，设置了sun.nio.ch.SelectorImpl的selectedKeys和publicSelectedKeys属性。 //根据NioEventLoop.run()方法内部直接调用 processSelectedKeysOptimized(selectedKeys.flip()); Class&lt;?&gt; selectorImplClass = Class.forName(&quot;sun.nio.ch.SelectorImpl&quot;, false, PlatformDependent.getSystemClassLoader()); // Ensure the current selector implementation is what we can instrument. if (!selectorImplClass.isAssignableFrom(selector.getClass())) &#123; return selector; &#125; Field selectedKeysField = selectorImplClass.getDeclaredField(&quot;selectedKeys&quot;); Field publicSelectedKeysField = selectorImplClass.getDeclaredField(&quot;publicSelectedKeys&quot;); selectedKeysField.setAccessible(true); publicSelectedKeysField.setAccessible(true); selectedKeysField.set(selector, selectedKeySet); publicSelectedKeysField.set(selector, selectedKeySet); selectedKeys = selectedKeySet; logger.trace(&quot;Instrumented an optimized java.util.Set into: &#123;&#125;&quot;, selector); &#125; catch (Throwable t) &#123; selectedKeys = null; logger.trace(&quot;Failed to instrument an optimized java.util.Set into: &#123;&#125;&quot;, selector, t); &#125; return selector;&#125; ServerBootstrapServerBootstrap是服务端socket的启动辅助类，构造函数： 12345678910111213public ServerBootstrap() &#123; &#125;private ServerBootstrap(ServerBootstrap bootstrap) &#123; super(bootstrap); childGroup = bootstrap.childGroup; childHandler = bootstrap.childHandler; synchronized (bootstrap.childOptions) &#123; childOptions.putAll(bootstrap.childOptions); &#125; synchronized (bootstrap.childAttrs) &#123; childAttrs.putAll(bootstrap.childAttrs); &#125;&#125; 设置EventLoopGroup只有一个无参构造函数，和一个拷贝构造函数。由于它需要的构造参数太多，因此选择用builder模式构造（《EffectiveJava》中有说：遇到多个构造器参数时应考虑使用构建器）。通过group方法设置两个NioEventLoopGroup，group属性是bossGroup，childGroup属性是workerGroup。 1234567891011public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) &#123; super.group(parentGroup); if (childGroup == null) &#123; throw new NullPointerException(&quot;childGroup&quot;); &#125; if (this.childGroup != null) &#123; throw new IllegalStateException(&quot;childGroup set already&quot;); &#125; this.childGroup = childGroup; return this;&#125; 设置Channel设置完EventLoopGroup，接着设置Channel： 123456public B channel(Class&lt;? extends C&gt; channelClass) &#123; if (channelClass == null) &#123; throw new NullPointerException(&quot;channelClass&quot;); &#125; return channelFactory(new ReflectiveChannelFactory&lt;C&gt;(channelClass));&#125; ReflectiveChannelFactory是根据channelClass反射来创建Channel实例的工厂类，它只有一个方法： 1234567public T newChannel() &#123; try &#123; return clazz.newInstance(); &#125; catch (Throwable t) &#123; throw new ChannelException(&quot;Unable to create Channel from class &quot; + clazz, t); &#125;&#125; 服务端需要的channelClass是NioServerSocketChannel.class。设置完ChannelFactory，我们需要设置Channel的一些属性： 123456789101112131415public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value) &#123; if (childOption == null) &#123; throw new NullPointerException(&quot;childOption&quot;); &#125; if (value == null) &#123; synchronized (childOptions) &#123; childOptions.remove(childOption); &#125; &#125; else &#123; synchronized (childOptions) &#123; childOptions.put(childOption, value); &#125; &#125; return this;&#125; 设置ChannelOptionChannelOption中包括了TCP_NODELAY、SO_KEEPALIVE、SO_BACKLOG等重要的TCP参数，参数具体作用这里就不讲了。设置完Channel之后，我们接着为ServerBootstrap和其父类AbstractServerBootstrap指定Handler，其中ServerBootstrap的handler是NioServerSocketChannel对应的ChannelPipeline的Handler，所有连接该接听端口的客户端请求都会执行它；AbstractServerBootstrap的handler是客户端新接入的SocketChannel对应的ChannelPipeline对应的Handler，它是一个工厂类，为每个新接入的客户端都创建一个新的Handler。 123456789101112131415public ServerBootstrap childHandler(ChannelHandler childHandler) &#123; if (childHandler == null) &#123; throw new NullPointerException(&quot;childHandler&quot;); &#125; this.childHandler = childHandler; return this;&#125;public B handler(ChannelHandler handler) &#123; if (handler == null) &#123; throw new NullPointerException(&quot;handler&quot;); &#125; this.handler = handler; return (B) this;&#125; 启动服务最后一步绑定端口，启动服务。b.bind(PORT)方法调用的是下面的doBind方法，完成Channel的初始化和端口绑定，其中有两个重要方法：initAndRegister()和doBind0()。 123456789101112131415161718192021222324252627282930313233343536private ChannelFuture doBind(final SocketAddress localAddress) &#123; //重要方法1，tag1 final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) &#123; return regFuture; &#125; if (regFuture.isDone()) &#123; // At this point we know that the registration was complete and successful. ChannelPromise promise = channel.newPromise(); //重要方法2，tag2 doBind0(regFuture, channel, localAddress, promise); return promise; &#125; else &#123; // Registration future is almost always fulfilled already, but just in case it&#x27;s not. final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel); regFuture.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; Throwable cause = future.cause(); if (cause != null) &#123; // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an // IllegalStateException once we try to access the EventLoop of the Channel. promise.setFailure(cause); &#125; else &#123; // Registration was successful, so set the correct executor to use. // See https://github.com/netty/netty/issues/2586 promise.executor = channel.eventLoop(); &#125; doBind0(regFuture, channel, localAddress, promise); &#125; &#125;); return promise; &#125;&#125; 首先我们来看initAndRegister方法，它完成了Channel实例创建，实例化和注册channel到selector上。 1234567891011121314151617181920212223final ChannelFuture initAndRegister() &#123; final Channel channel = channelFactory().newChannel(); //创建Channel实例，tag1.1 try &#123; //初始化channel，tag1.2 init(channel); &#125; catch (Throwable t) &#123; channel.unsafe().closeForcibly(); // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t); &#125; //把channel注册到selector上，tag1.3 ChannelFuture regFuture = group().register(channel); if (regFuture.cause() != null) &#123; if (channel.isRegistered()) &#123; channel.close(); &#125; else &#123; channel.unsafe().closeForcibly(); &#125; &#125; return regFuture;&#125; newChannel方法通过反射调用NioServerSocketChannel构造方法，里面首先会调用newSocket方法来创建java的ServerSocketChannel 1234567891011121314private static ServerSocketChannel newSocket(SelectorProvider provider) &#123; try &#123; /** * Use the &#123;@link SelectorProvider&#125; to open &#123;@link SocketChannel&#125; and so remove condition in * &#123;@link SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise. * * See &lt;a href=&quot;See https://github.com/netty/netty/issues/2308&quot;&gt;#2308&lt;/a&gt;. */ return provider.openServerSocketChannel(); &#125; catch (IOException e) &#123; throw new ChannelException( &quot;Failed to open a server socket.&quot;, e); &#125;&#125; 接着继续调用父类AbstractNioChannel的构造方法： 12345678910111213141516171819protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) &#123; super(parent); this.ch = ch; this.readInterestOp = readInterestOp; try &#123; ch.configureBlocking(false); &#125; catch (IOException e) &#123; try &#123; ch.close(); &#125; catch (IOException e2) &#123; if (logger.isWarnEnabled()) &#123; logger.warn( &quot;Failed to close a partially initialized socket.&quot;, e2); &#125; &#125; throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e); &#125;&#125; 通过ch.configureBlocking(false)将channel设置为非阻塞。并在其父类AbstractChannel构造方法中初始化了unsafe和pipeline属性： 123456protected AbstractChannel(Channel parent) &#123; this.parent = parent; id = DefaultChannelId.newInstance(); unsafe = newUnsafe(); pipeline = new DefaultChannelPipeline(this);&#125; 其中DefaultChannelPipeline构造方法中设置了HeadHandler和TailHandler，相当于初始化了Handler的处理链。这也是两个比较重要的类。 123456789101112DefaultChannelPipeline(AbstractChannel channel) &#123; if (channel == null) &#123; throw new NullPointerException(&quot;channel&quot;); &#125; this.channel = channel; tail = new TailContext(this); head = new HeadContext(this); head.next = tail; tail.prev = head;&#125; 至此，终于完成了tag1.1的channelFactory().newChannel()方法，完成channel实例的构建。接下来看tag1.2的ServerBootstrap.init()方法： 12345678910111213141516171819202122232425262728293031323334353637383940@Overridevoid init(Channel channel) throws Exception &#123; final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options(); synchronized (options) &#123; channel.config().setOptions(options); &#125; final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs(); synchronized (attrs) &#123; for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123; @SuppressWarnings(&quot;unchecked&quot;) AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey(); channel.attr(key).set(e.getValue()); &#125; &#125; ChannelPipeline p = channel.pipeline(); if (handler() != null) &#123; p.addLast(handler()); &#125; final EventLoopGroup currentChildGroup = childGroup; final ChannelHandler currentChildHandler = childHandler; final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions; final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs; synchronized (childOptions) &#123; currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size())); &#125; synchronized (childAttrs) &#123; currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size())); &#125; p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123; @Override public void initChannel(Channel ch) throws Exception &#123; ch.pipeline().addLast(new ServerBootstrapAcceptor( currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)); &#125; &#125;);&#125; 里面主要设置了parentChannel和childChannel的options和attrs。并将客户端设置的参数覆盖到默认设置中。最后把通过childHandler(new ChannelInitializer&lt;SocketChannel&gt;())方法设置的handler加入到pipeline中。注：其实addLast方法并不是把handler正的放到pipeline的最后，而是放到tail的前一个节点上。 至此tag1.2完成。开始执行tag1.3，group().register(channel)。跟踪方法进去可以看到最终执行的是AbstractChannel.register()方法，其中重点是register0(ChannelPromise promise)方法： 12345678910111213141516171819202122232425262728private void register0(ChannelPromise promise) &#123; try &#123; // check if the channel is still open as it could be closed in the mean time when the register // call was outside of the eventLoop if (!promise.setUncancellable() || !ensureOpen(promise)) &#123; return; &#125; boolean firstRegistration = neverRegistered; //重要代码1 doRegister(); neverRegistered = false; registered = true; eventLoop.acceptNewTasks(); safeSetSuccess(promise); // 重要代码2 pipeline.fireChannelRegistered(); // Only fire a channelActive if the channel has never been registered. This prevents firing // multiple channel actives if the channel is deregistered and re-registered. if (firstRegistration &amp;&amp; isActive()) &#123; pipeline.fireChannelActive(); &#125; &#125; catch (Throwable t) &#123; // Close the channel directly to avoid FD leak. closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); &#125; &#125; AbstractNioChannel中的doRegister方法核心功能就是把javaChannel注册到selector上。pipeline.fireChannelRegistered()方法负责触发注册事件通知，下文会详细再介绍该方法。 123456789101112131415161718192021@Overrideprotected void doRegister() throws Exception &#123; boolean selected = false; for (;;) &#123; try &#123; selectionKey = javaChannel().register(((NioEventLoop) eventLoop().unwrap()).selector, 0, this); return; &#125; catch (CancelledKeyException e) &#123; if (!selected) &#123; // Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be // cached and not removed because no Select.select(..) operation was called yet. ((NioEventLoop) eventLoop().unwrap()).selectNow(); selected = true; &#125; else &#123; // We forced a select operation on the selector before but the SelectionKey is still cached // for whatever reason. JDK bug ? throw e; &#125; &#125; &#125;&#125; 至此tag1的initAndRegister完成。 待续","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"netty","slug":"netty","permalink":"https://lchml.com/tags/netty/"},{"name":"TCP","slug":"TCP","permalink":"https://lchml.com/tags/TCP/"}]},{"title":"svn迁移git","slug":"svn-to-git","date":"2015-12-22T16:00:00.000Z","updated":"2022-05-12T06:10:25.472Z","comments":true,"path":"technology/svn-to-git/","link":"","permalink":"https://lchml.com/technology/svn-to-git/","excerpt":"svn迁移git，如果只是代码迁移很简单，只需要把代码copy一份提交到git就完事了。","text":"svn迁移git，如果只是代码迁移很简单，只需要把代码copy一份提交到git就完事了。 但是大型工程中，svn的提交记录也是一份很重要的资料，所以迁移时需要带上svn log。 迁移步骤 新建一个临时文件夹tmp_dir，用来存储需要迁移的代码。mkdir tmp_dir cd tmp_dir 把文件夹初始化为git目录，并绑定svn地址。git svn init SVN://URL 拉取代码和svn log，历史记录越多，时间越长。可以指定从某个开始拉取。git svn fetch git svn fetch -r 10000:HEAD 上面的init加fetch命令可以合并为一个命令。git svn clone SVN://URL -sr 10000:HEAD tmp_dir 在git上建立对应的仓库，并关联该git仓库。git remote add origin git@github.com:xxxx/your-reop.git（如果要修改关联，把add改为set-url即可。） 提交代码。git push -u origin master 完成后在git上就可以看到对应的代码，和commit记录了。 删除本地tmp_dir，重新从git上clone一份刚提交的代码，开始新的工作。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"svn","slug":"svn","permalink":"https://lchml.com/tags/svn/"},{"name":"Git","slug":"Git","permalink":"https://lchml.com/tags/Git/"}]},{"title":"Movie Hell诞生之路","slug":"moviehell","date":"2015-12-17T16:00:00.000Z","updated":"2022-05-12T05:59:32.281Z","comments":true,"path":"technology/moviehell/","link":"","permalink":"https://lchml.com/technology/moviehell/","excerpt":"平时电影看的比较多（记得当时学校内网睿思上的电影都快被我看光了），所以觉得应该为这个兴趣做点什么。","text":"平时电影看的比较多（记得当时学校内网睿思上的电影都快被我看光了），所以觉得应该为这个兴趣做点什么。 首先归纳一下过程中涉及到的相关知识点：linux(ubuntu), mysql, spring, mybatis, webmagic(爬虫), js&#x2F;html&#x2F;css&#x2F;jsp, nginx。大概就这么多吧，另外就是还有一些域名绑定之类的操作。 服务器选择要搭建一个网站，首先你需要一台有公网地址的服务器，这里有很多云计算厂商可以选择，调研下来比较推荐的有这些，国内有阿里云、网易蜂巢。国外的有aws、digitalocean。个人对于PaaS类的服务不太喜欢，用起来太不自由，所以抛弃了原先申请到的免费新浪sae平台。最后选的是网易蜂巢，基于docker的全ssd容器。 数据源既然是电影网站，所以首先考虑的就是数据来源问题，如今网上的电影资源几乎是应有尽有。第一步随意找一个自己常用的网站作为数据来源就可以了，等爬虫算法逐渐完善以后可以改为从多个网站爬取数据源。所以接下来是爬虫的使用，说到爬虫，第一时间想到的是python的Scrapy，java世界里也有许多成熟的爬虫框架，这里我们选用了WebMagic。爬虫的使用非常简单，只需爬取所需得网页，解析出自己想要的数据就可以了。 数据存储数据源解决以后，那么接下来就是数据的存储问题。在关系型数据库方面，免费为第一目标的情况下，mysql是不二之选。当网站访问量较大时，我们需要对热点数据做内存缓存，所以还需要一个NoSql来支持，在我们的电影网站中，Redis是不错的选择，可以支持一些复杂的数据结构存储。ubuntu(Debian)上安装mysql命令：apt-get install mysql-server mysql-client，安装过程中安提示设置好密码即可。用ps aux|grep mysql查看mysql进程是否已经存在，如果没有可以用service start mysql来启动。成功以后用mysql -u root -p便可以进入mysql了。接着安装Redis，根据官网文档只需要几个命令就可以编译安装完成了。 1234$ wget http://download.redis.io/releases/redis-3.0.5.tar.gz$ tar xzf redis-3.0.5.tar.gz$ cd redis-3.0.5$ make 可以通过redis.conf来修改一些配置，最后src/redis-server启动服务即可。java操作mysql的Dao框架有很多，这里选用熟悉的Mybatis，Redis只需要使用官方提供的Jedis即可。 代码架构解决上述问题后，基本就可以进行编码了。代码逻辑很简单，主要就是以下几个功能：代码包含的模块主要有：controller接收http请求并处理；aop拦截指定的请求，主要负责日志打印、ip过滤、以及后续可以作为用户验证等功能；service和dao主要负责数据的增删改查处理；task则是作为定时任务存在，主要用于爬取源数据。 网站部署代码编译打包完成后，接下来就是部署上线了。选择tomcat做servlet容器，从官网下载一个即可。可以在startup.sh中设置相关的jvm参数：tomcat的应用部署，war部署或者class文件部署都可以，最后在server.xml中设置相应的参数。tomcat启动后，通过指定的端口应该已经可以访问了，但是作为线上部署，tomcat前面还应该有一个nginx作为请求代理，以便于服务控制。 ubuntu上安装nginx命令：apt-get install nginx，安装完成后在&#x2F;etc&#x2F;nginx&#x2F;sites-enable&#x2F;default中增加自己的代理配置，最后启动命令：/etc/init.d/nginx start。这时网站应该可以就通过ip访问到了。 是不是还觉得缺了点什么呢？是的，缺了域名！如果你的网站是个ip地址，那么我想没几个人能记住你的这个网站。域名从哪里来呢？从ICANN来。它俗称互联网名称与数字地址分配机构，但是你不能找他直接注册域名。注册域名这件事情由市场上的各家域名服务提供商提供，比如国内比较大的是万网，国外有著名的GoDaddy，这些都是可以注册你自己域名的地方。有一点要注意，如果你的域名注册商和ip都是在国内（大陆），那么就会比较麻烦，因为你的网站会需要备案。所以建议，ip和域名注册，至少有一项选择在国外。在GoDaddy注册了moviehell.net后，配置域名DNS如下：等godaddy的全球节点同步完配置，就可以用域名访问网站了。如果你希望当用户输入moviehell.net时自动加上www前缀，可以在nginx中增加如下配置： 1234server &#123; server_name moviehell.net; rewrite ^/(.*) http://www.moviehell.net/$1 permanent;&#125; 至此，一个简单的网站算是搭建完成了。当然作为一个在公网上服务的服务器，最好应该关闭用不到的端口，关闭icmp协议等等。配合iptables等工具做好管理。后续还有许多事情可以做，如增加数据来源，爬虫与web服务拆分，分布式部署，服务监控等等。 项目源码github地址","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://lchml.com/tags/%E7%94%B5%E5%BD%B1/"},{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"moviehell","slug":"moviehell","permalink":"https://lchml.com/tags/moviehell/"}]},{"title":"少有人走的路","slug":"self-discipline","date":"2015-12-15T16:00:00.000Z","updated":"2022-05-12T05:58:08.450Z","comments":true,"path":"life/self-discipline/","link":"","permalink":"https://lchml.com/life/self-discipline/","excerpt":"《少有人走的路》 是一位心理学家写的关于如何走上心智成熟之路的书。","text":"《少有人走的路》 是一位心理学家写的关于如何走上心智成熟之路的书。 引言The road less traveled，并不是所有人的心智都是成熟的，从不成熟到成熟是人生要走的一段路，相信阅读本书或本文是走向成熟的重要路程，建议每一个人都阅读下这本书，能够帮助你促进心智成熟。 我自己总是在想，为什么明白很多的道理，却仍然做不明智的事情，为什么知道很多做事的技巧，却仍然做事情不是那么高效。明知道做事不要切换，却一会看看旺旺，一会听听音乐。最近朋友也和我说明明知道要努力，却还是喜欢玩。这些问题的答案就是缺乏自律。带着问题重看此书又有新的收获。 学会自律人生是一个面对问题并解决问题的过程 。问题能启发我们的智慧和激发我们的勇气，为解决问题而付出的努力，能使心智不断成熟。面对问题和解决问题，能让我们得到最好的学习。问题不会自动消失，即使现在不解决，以后也的解决。而自律是解决人生问题的首要工具。 所谓自律就是以积极而主动的态度，去解决人生的问题 。自律包括四个方面，推迟满足感，承担责任，尊重事实，保持平衡。人因懒惰而不去解决问题，因为懒惰是天性，所以才需要通过自律来自我管理。 如何做到自律呢？有爱。自律的源动力是爱，我们爱某样东西就会乐于为他付出时间。因爱炒股而每天去学习，因爱读书而每天看，因爱孩子而把更多时间花在他身上，这自然就形成一种自律。 自律之一学会推迟满足感。人们都喜欢先做自己喜欢和感兴趣的事，而这会导致很多重要的事情无法完成。而推迟满足感意味着不贪图暂时的安逸，重新设定痛苦和快乐的次序，首先面对问题，然后解决并享受更大的快乐。因为不先解决问题，它不会自然消失，而时刻伴随着你，让你一直感受到痛苦。 自律之二承担责任。不能及时解决人生的难题，它们会像山一样始终横在我们眼前，如果问题拖延越久就难以应付，如果逃避，则会引来更多的问题。问题一旦出现就应该立刻解决，不然会思绪混乱，寝食不安。所有的问题只要愿意花时间就必定能解决。责任感出现问题的人总会说我不可能，我做不到。人人都有逃避责任的倾向，因为承担责任，会带来痛苦，而我们却又想极力避免这种痛苦。我们试图把责任推给别人，意味着我们只能附属于他，意味着我们甘愿放弃成长的机会，放弃成为一个自由的人。承担自己责任，自己对自己负责，会让自己引以为荣的。 自律之三尊重事实。逃避现实的痛苦和不幸，是人类的天性，只有通过自律，才能逐渐克服现实的痛苦。我们必须淡化暂时的不适应，因为这是成长的必经之路。当你不舒服的时候，应该恭喜你，因为这正是你成长的时候。当你安逸的时候，就是你停止成长的时候，温水煮青蛙，安逸但结果却悲剧。尊重事实，意味着我们通过与外界的接触，来认识世界改变自己对世界的认识。人之为人，在于我们能通过反思改变本性，尝试去做不符合本性的事，如结婚。 心理治理能使心智成熟，而心理治疗就是鼓励说真话的游戏。以开放的心态，积极的努力不断修订人生观，方能使心灵获得成长。 自律之四学会舍和取。放弃人生的某样东西，一定会带来痛苦，但失去平衡，远比放弃更为痛苦。如和孩子下棋你必须放弃求胜欲望，得到好父亲的欲望。人生必须学会兼容并包，既肯定自我，以保持稳定，又要放弃自我，以释放空间，接纳新的想法和观念。自律是一个自我完善的过程。 自律的源动力是爱，接下来我们再谈一下爱。 懂得爱爱与不爱很显著的区别之一，在于当事人的意识思维和潜意识思维的目标是否一致（这句话让我明白什么是真正的爱）。如果不一致，就不是真正的爱。父母常说我是为你好，才要求你这么做，但孩子却不以为然，这时父母总是把问题归为是孩子不理解父母或不懂事。而真正的爱，应首先让孩子意识到这样做是好的，然后让他主动去做这件事。爱是需要耐心的。 真正的爱，不是单纯的给予，还包括适当的拒绝。即时的赞美，得体的批评，恰当的评论，必要的鼓励，温柔的安慰，有效的敦促。而这些行为，不仅需要用心，更需要用脑。爱最重要的体现形式是关注 。而体现关注最重要的方式是倾听 。用心倾听 是一种爱的行为，＂非爱＂的本质就是懒惰。 真正的爱不是恋爱，因为恋爱不是理性意识的选择，它只是一种稍纵即逝的感觉。真正的爱不是依赖性，不是用来填补内心的空虚。爱的唯一目标，是促进心智的成熟。该拒绝时一味给予，不是仁慈，而是伤害。照顾有能力照顾自己的人，只会让他产生更大的依赖，这是对爱的滥用，爱太多不如不爱。 真正的爱在于始终如一的行动，这远远大于转瞬既逝的感觉，真正的爱不是挂在口头，而是依靠实际行动来证明。爱是行动，是一种客观存在，不是头脑的主观主义。真正的爱，来自双方心灵的意愿，而不是打着爱的幌子做她不愿意做的事，来满足自己的需要。 爱的唯一目的是帮助她心智成熟 。所以让她做一件事之前需思考是否能够帮助她心智成熟。爱需要和懒惰和恐惧较量。爱意味着自我完善，所以需要勇气来克服畏缩心理。 真正具有爱的人，会承认对方与众不同，是完全独立的个体，懂得尊重对方。绝不会随意批评别人或与对方发生冲突，他们竭力避免给对方造成傲慢的印象。与爱的人发生冲突，多半是自以为在见识和道德上高人一筹。那么他们懂得谦逊，自我反省。纵观历史，刘备就是一个真正具有爱的领导者。 拥有科学思维的人，能够对一切现象提出质疑。 最后，希望本文能帮你走向心智成熟之路。 转载自并发编程网——少有人走的路","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"转载","slug":"转载","permalink":"https://lchml.com/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"水墨黄山","slug":"huangshan","date":"2015-12-13T16:00:00.000Z","updated":"2022-05-12T06:00:43.600Z","comments":true,"path":"life/huangshan/","link":"","permalink":"https://lchml.com/life/huangshan/","excerpt":"五岳归来不看山，黄山归来不看岳。","text":"五岳归来不看山，黄山归来不看岳。 时间2015.12.12，又是凌晨4点起床，楼下买了过夜的肯德基汉堡，直奔公司与另外三位同事会合。5点多一点从公司出发，陈老师一路飙车，8点赶到黄山市，与大部队（徒游户外）会合。然后坐小巴经过半个多小时，达到汤口镇，也就是黄山脚下。领队统一买好车票门票，坐景区大巴抵达第一站云谷寺。 接着就开始漫长的登山，由于当天雾气较大，所以一路都是雾蒙蒙，没什么可看。经过两个多小时，终于抵达第一站白鹅岭，把行李放到酒店白鹅山庄。刚到酒店，天气突变，雾气散去。第一次领略到了黄山云海奇观！稍作休整（也就是吃了一碗泡面）后，继续出发，前往下一站狮子峰，途经始信峰、石猴观海等一路美景。到下午5点左右，突然天气开始变化，雾气重新上来，本来去排云亭看日出的行程取消，改为去丹霞峰。后来经验证，排云亭比丹霞峰更值得一去，没有看到日落略有遗憾。丹霞峰下来6点左右已经开始天黑，一路摸黑走回酒店，大约7点多重新回到白鹅山庄，吃了酒店的快餐（50一份）。住的是山下铺的大通铺，所以晚上比较吵闹。 第二天早上由于还在下雨，所以没有日出可看，睡到8点起床。大家洗漱完毕吃过早饭后，再次出发。由于下雨，所以一路几乎就是闷头走，走过光明的，莲花峰，到达玉屏峰，看到了小时候每个人家里都会挂在墙上的迎客松。由于天气实在太差，所以没有景色可言，直接从玉屏索道下山。回到汤口镇上是12点多，大家在附近吃了徽菜，可能是景区附近的原因吧，味道一般。最后坐小巴到黄山市，自驾回到杭州。 虽然大部分时间天气不好，但也领略到了黄山云海的奇观！其实前山的风景应该会更好，下次有机会再去吧。四个字总结：不虚此行。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"黄山","slug":"黄山","permalink":"https://lchml.com/tags/%E9%BB%84%E5%B1%B1/"}]},{"title":"巴厘——香港","slug":"bali","date":"2015-11-29T16:00:00.000Z","updated":"2022-05-12T06:02:02.383Z","comments":true,"path":"life/bali/","link":"","permalink":"https://lchml.com/life/bali/","excerpt":"碧海蓝天，异国风情；购物天堂，东方之珠 —— HML","text":"碧海蓝天，异国风情；购物天堂，东方之珠 —— HML 时间：2015.11.20凌晨四点起床出发。6点多达到机场，飞往香港转机。 9点多抵达香港，在机场等着转机，香港国际机场果然够大。吃了点东西，12点继续飞往巴厘岛。在巴厘岛机场入境的时候，要给签证官小费，10块人民币就行了（在巴厘岛，要随时注意给小费）。巴厘岛机场不允许拍照，否则会被罚款的。顺利入境，经过高速收费站（印度尼西亚是靠左行驶的）。抵达撒努尔天堂酒店酒店已是七八点。坐了一天飞机，吃点东西就抓紧休息了。 第二天一大早，吃完酒店自助餐（很不错），当地向导带着我们去了南湾，南湾有各种水上游乐项目，但是价钱略贵（后面会有便宜的），所以不建议玩。 中午去了一家中式餐厅AKAME吃饭，还算吃的习惯吧。吃完饭直接出发去情人崖。真的很美！不过在情人崖有许多猴子会抓人抢东西，所以要稍加小心。 逛完情人崖，由于时间还充裕，向导带着大家去了金兔子咖啡工厂，说真的，那边的咖啡味道确实不错，喜欢喝咖啡的可以考虑买一些。紧接着去金巴兰海滩看日落，第一次看到海上落日，真是美爆了！美中不足的是那里的烧烤晚餐简直不能吃，只能晚上回酒店再自己觅食了。吃完晚饭就回酒店了，由于巴厘岛比较落后，因此没有什么夜景可言，晚上就老实在酒店待着吧。 第三天时间依旧充裕，早上起来在酒店游泳池泡泡，然后吃早饭。差不多11点出发去海神庙，由于距离较远，一直到中午一点才抵达。午饭在海神庙附近的一家自助餐厅吃饭，虽然吃的依旧很烂，但是环境却挺有意思。吃完饭走去海神庙，依旧是很美很美！ 海神庙范围不大，2个小时左右足够走完看完了，接着继续去乌布皇宫，附近有乌布市场，这应该算是所有景点里最没意思的了。皇宫本身不大，而且有一大部分区域还有人居住，所以可以看的也就只有一点点。稍微转悠一下，就直接出发去吃晚餐，号称当地著名特色脏鸭餐，还是跟之前一样，味道不怎么样，环境倒是很不错。吃完直接回酒店。 第四天自由行时间，在淘宝上订了蓝梦岛一日游的行程，吃过早饭有当地向导来接车，直接到码头，反正巴厘岛真是到处都很美，连个码头都这么美！从码头坐快艇，大约一个小时抵达蓝梦岛。行程中包含了浮潜、海底漫步、香蕉船三个水上项目，还是很好玩的。然后就是上岸吃饭。蓝梦岛这个名字名副其实，蓝色梦幻之岛，美美美！在岛上还有一个当地乡村游项目，其实就是坐着小破车在岛上转悠一圈，看看岛上环境，也挺不错。行程结束，坐快艇回程，下午4点左右回到酒店，晚餐自理，一天下来已经很累，所以直接在附近的肯德基吃了。晚上在酒店休息。 第五天，下午飞往香港，早上自由活动时间，大家都在酒店游泳池泡着，躺着晒晒太阳，惬意度过。中午出发去机场，在机场附近随便找个饭店都是无敌海景，吃完逛了一下，就去候机了。抵达香港已经是凌晨1点多，五个小时的飞机实在太累，直奔香港如心海景酒店，睡下已经是3点多了。 第六天早上8点左右起床（只睡了5个小时左右），香港地方很小，坐地铁一会就到了尖沙咀，出来就是著名的维多利亚港和星光大道，可惜星光大道施工封闭了。香港这个地方，除了买买买，剩下的就是满脑子港剧和TVB的画面了，什么铜锣湾扛把子啦，旺角卡门啦，西九龙重案组啦等等。哦，还有吃的东西也还不错。去了香港理工大学找同学，去了中环苹果店（人太多，没进去），去了旺角，红磡等等。逛到下午五六点，到酒店集合，出发回杭州！凌晨1点左右抵达萧山机场（第二天还要上班）。。。 时间匆忙，就记了个流水账吧，很多巴厘岛有意思的的异国风土人情都没来的及写。总结一下：巴厘岛值得一去，香港除了去买买买，别的就算了吧。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"巴厘岛","slug":"巴厘岛","permalink":"https://lchml.com/tags/%E5%B7%B4%E5%8E%98%E5%B2%9B/"},{"name":"香港","slug":"香港","permalink":"https://lchml.com/tags/%E9%A6%99%E6%B8%AF/"},{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"}]},{"title":"近期小结","slug":"summary1","date":"2015-10-19T16:00:00.000Z","updated":"2022-05-12T06:10:17.777Z","comments":true,"path":"technology/summary1/","link":"","permalink":"https://lchml.com/technology/summary1/","excerpt":"最近一个月面试了不少人（一个也没招到）。发现大部分应聘者都有一个问题：基本功不扎实，给人一种培训班出来的感觉。","text":"最近一个月面试了不少人（一个也没招到）。发现大部分应聘者都有一个问题：基本功不扎实，给人一种培训班出来的感觉。 其中一个工作了9年的开发，居然不知道jvm的gc参数。离开tomcat就不知道怎么开发的大有人在。还有一种人是不求甚解，虽然用过不少开源框架、工具，但问起里面的原理几乎都不清楚，仅限于使用而已。还有就是基础还可以但却沟通不顺的，总是答非所问。例如问他做的某个项目中有什么技术难点，结果他说了10分钟的业务流程。同时，通过应聘者来检查自己是否存在一样的问题，这是一个很好的自我提高方法。 学习guava源码。guava之强大，完全可以作为java开发中的基础工具包。base包中的工具可以让代码变得更优雅，如Joiner，Splitter等可以很方便的进行字符串拼接、分割操作。collect包是对jdk集合的扩展，如对Map&lt;String, List&lt;String&gt;&gt;这种复合集合的包装，可以让代码变更直观简洁。每个包都有对应的强大功能。推荐文档：英文、中文。看源码最大的收获是学习很多非常优秀的编程思想，经常自问：同样得功能，我能不能实现的这么优雅。 学习fastjson源码。json现在应该是项目开发中必不可少得数据类型了，json的工具包有很多，Json-lib、Gson、Jackson、fastjson是使用的最多的四个json工具包。使用习惯上，个人觉得fastjson是最顺手的（不知道是不是因为是中国人写的缘故）。Json-lib的性能相对较差，其他三个各有争论，网上也能找到很多相关的测试对比数据。json库的主要功能就是序列化和反序列化，所以性能的优化都在这两点上。一篇不错的分析文章 学习过程中发现，上面两个项目的源码都大量使用，或者借鉴了jdk的源码实现，如guava中cache的实现是基于ConcurrentHashMap的扩展，fastjson中的序列化实现采用了类似StringBuiler的实现方法。有时间的时候确实应该去学习一下jdk的源码，这样才能称得上是java开发。甚至更进一步，学习jvm的c++源码。 学习编写python的web框架。人生苦短，我用python。python就像一把瑞士军刀，在任何地方都能派上用场，非常适合作为开发人员的第二语言。语言设计本身有很多先进的思想在里面，完全可以再java开发中借鉴。如自己包装with方法来达到python中的with关键字功能，可以方便进行文件操作。推荐一个很好的python学习网站","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"随想","slug":"随想","permalink":"https://lchml.com/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"BloomFilter","slug":"bloomfilter","date":"2015-09-11T16:00:00.000Z","updated":"2022-05-12T06:04:36.717Z","comments":true,"path":"technology/bloomfilter/","link":"","permalink":"https://lchml.com/technology/bloomfilter/","excerpt":"Bloom Filter是由Bloom在1970年提出的一种多哈希函数映射的快速查找算法。通常应用在一些需要快速判断某个元素是否属于集合，但是并不严格要求100%正确的场合。","text":"Bloom Filter是由Bloom在1970年提出的一种多哈希函数映射的快速查找算法。通常应用在一些需要快速判断某个元素是否属于集合，但是并不严格要求100%正确的场合。 简介Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。 原理初始状态下面我们来看Bloom Filter是如何用位素组来表示集合的。初始状态下，Bloom Filter是一个包含m位的位数组Bit Vector，每一位都是0。 添加元素往数组中添加一个元素x时，用k个独立的、均匀分布的哈希函数 $$h_1(),h_2(), \\cdots h_k()$$ 对元素x进行哈希，假设得到k个结果如下 $$h_1(x)&#x3D;8,h_2(x)&#x3D;11, \\cdots h_k(x)&#x3D;3$$ 则把位数组上对应的位置为1，这样就把元素x映射到位数组中的k个二进制位了。（当某个位被重复置为1时，以第一次置1为准） 检查元素是否存在当需要判断元素y是否属于这个集合时，同样用上面的k个哈希函数对y进行哈希，得到结果 $$h_1(y),h_2(y), \\cdots h_k(y)$$ 然后检查位数组中对应的位是否为1，若其中任何一位不为1，则表示不存在。若全部为1，怎表示“可能”存在，这里之所以是“可能”是因为若一个元素对应的Bit全为1，实际上是不能100%的肯定该字符串被Bloom Filter记录过的，因为有可能该字符串的所有位都刚好是被其他字符串所对应。这种将该字符串划分错的情况就称为false positive。 注意：Bloom Filter中的元素是不能被删除的，因为如果把该元素对应的位置为0，会影响集合中的其他元素。针对删除功能有一个简单的改进，即Counting Bloom Filter。 错误率估计由于存在false positive，因此我们需要选择合适得数组大小及哈希函数个数，来使得我们的Bloom Filter的错误率尽可能的低。这里我们省去负责的数学公式推导过程，直接给出结论： m&amp;emsp;&amp;emsp;Bit Vector位数 n&amp;emsp;&amp;emsp;元素数量 k&amp;emsp;&amp;emsp;哈希函数个数 f&amp;emsp;&amp;emsp;False Positive比率（错判率） 以上参数满足下面的公式： $$(1-(1-\\frac{1}{m})^{kn})^k \\approx (1-e^{\\frac{-kn}{m}})^k$$ 当给定m和n时，能够使f最小化的k值为： $$ \\frac{m}{n}ln(2) \\approx 0.7\\frac{m}{n} $$ 此时f的值为： $$(\\frac{1}{2})^k \\approx 0.6185^\\frac{m}{n} $$ 根据以上公式，对于任意给定的f，可以得到： $$n &#x3D; m\\frac{ln(0.6185)}{ln(f)} $$ 同时k的值为： $$k &#x3D; -\\frac{ln(f)}{ln(2)} $$ 其中k必须为整数，最后可以得到实际f值为： $$f &#x3D; (1 - e^{-\\frac{kn}{m}})^k $$ 以上三个公式是Bloom Filter的关键公式。 实际应用Bloom Filter在很多地方都有实现，如redis，python，guava等。这次是一个线上项目需求，不需要长久运行，数据量大概千万级别，最后决定选择guava来实现。在其源码中有一个类叫BloomFilter，可以看出BloomFilter的使用非常简单，create接口如下： 123public static &lt;T&gt; BloomFilter&lt;T&gt; create(Funnel&lt;? super T&gt; funnel, long expectedInsertions, double fpp) &#123; return create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);&#125; 第一个参数funnel，在Funnels类中已经选择自己需要的实例（你可以简单的理解为类型过滤器）。如元素是long型时就选择Funnels.longFunnel() 12345678910111213141516public static Funnel&lt;Long&gt; longFunnel() &#123; return LongFunnel.INSTANCE;&#125;private enum LongFunnel implements Funnel&lt;Long&gt; &#123; INSTANCE; public void funnel(Long from, PrimitiveSink into) &#123; into.putLong(from); &#125; @Override public String toString() &#123; return &quot;Funnels.longFunnel()&quot;; &#125;&#125; 第二个参数表示元素的数量，第三个参数表示设定的错误率。创建BloomFilter之后简单的使用put()方法插入元素，使用mightContain()方法查询元素是否存在。 注：经过测试，1000万的long型数据，大约需要300m不到的内存。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"BloomFilter","slug":"BloomFilter","permalink":"https://lchml.com/tags/BloomFilter/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lchml.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Twemproxy(nutcracker)容易误解的参数","slug":"nutcracker","date":"2015-08-26T16:00:00.000Z","updated":"2022-05-12T05:58:52.097Z","comments":true,"path":"technology/nutcracker/","link":"","permalink":"https://lchml.com/technology/nutcracker/","excerpt":"Twitter，世界最大的Redis集群之一部署在Twitter用于为用户提供时间轴数据。Twitter Open Source部门提供了Twemproxy(nutracker)。","text":"Twitter，世界最大的Redis集群之一部署在Twitter用于为用户提供时间轴数据。Twitter Open Source部门提供了Twemproxy(nutracker)。 Twemproxy是一个快速的单线程代理程序，支持Memcached ASCII协议和更新的Redis协议：它全部用C写成，使用Apache 2.0 License授权。项目在Linux上可以工作，而在OSX上无法编译，因为它依赖了epoll API.Twemproxy 通过引入一个代理层，可以将其后端的多台 Redis 或 Memcached 实例进行统一管理与分配，使应用程序只需要在 Twemproxy 上进行操作，而不用关心后面具体有多少个真实的 Redis 或 Memcached 存储。 由于数据量大，以及考虑到redis的集群和高可用等需求，在项目中采用nutcracker作为redis和memcache的前端proxy。nutcracker的配置文件相当简洁，只有10来个参数。下面是一个典型的配置 12345678910111213redis-for-test: listen: 0.0.0.0:11212 #表示监听的IP和端口 redis: true #true表示作为redis代理，false表示作为memcache代理 hash: fnv1a_64 #指定具体的hash函数 distribution: ketama #具体的hash算法 timeout: 400 #超时时间（毫秒） auto_eject_hosts: true #是否在结点无法响应的时候临时摘除结点 server_retry_timeout: 30000 #重试的时间（毫秒） server_failure_limit: 2 #结点故障多少次就算摘除掉 preconnect: true #在进程启动的时候，是否需要预连接到所有的server，默认值false servers: #下面表示所有的Redis节点（IP:端口号:权重） - 127.0.0.1:6379:1 test-1 - 127.0.0.1:6380:1 test-2 巧合的事情发生了，前端时间由于机房故障，后端的redis节点中有两台机器挂掉了。理论上这时nutcracker应该会发挥左右。然而实际情况是报警报疯了。难道nutcracker的高可用是随便骗骗人的？应该不至于吧。接下来我在测试机上做了如下测试： 开两个redis节点，端口分别为6379和6380。开一个nutcracker，配置如上。然后写一个python脚本来做数据写入，脚本代码： 12345678910111213141516# coding: utf-8import redisimport timeif __name__ == &#x27;__main__&#x27;: r = redis.Redis(host=&#x27;10.240.129.196&#x27;, port=22221) for i in range(0, 10000000): try: if r.set(&#x27;key&#x27; + str(i), &#x27;value&#x27; + str(i)): print &#x27;set key:&#x27;, i, &#x27;success&#x27; else: print &#x27;*** set key:&#x27;, i, &#x27;failed ***&#x27; time.sleep(0.5) except Exception as e: print &#x27;except:&#x27;, e.message 每隔0.5s写入一个KV。同时监控nutcracker日志（启动nutcracker时可以用-o来指定日志文件）。正常运行一会后，kill掉6379的redis节点，这是会发现脚本返回Connection refused错误，接着正常写入，过了会又会出现Connection refused，每隔一会就会出现两次。nutcracker的日志如下： 123456789101112[Thu Aug 27 16:57:31 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused[Thu Aug 27 16:57:31 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused[Thu Aug 27 16:58:01 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused[Thu Aug 27 16:58:01 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused[Thu Aug 27 16:58:32 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused[Thu Aug 27 16:58:32 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused[Thu Aug 27 16:59:02 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused[Thu Aug 27 16:59:02 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused[Thu Aug 27 16:59:32 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused[Thu Aug 27 16:59:32 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused[Thu Aug 27 17:00:02 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused[Thu Aug 27 17:00:02 2015] nc_core.c:207 close s 7 &#x27;127.0.0.1:6379&#x27; on event 001D eof 0 done 0 rb 0 sb 0: Connection refused 仔细观察发现，每大约间隔30s就会出现两次链接失败。对比我们nutcracker的配置，是不是有点明白了？原来是对nutcracker的配置有误解。上面的参数中server_retry_timeout和server_failure_limit是指“每次”失败后的下一次重试时间和重试次数。也就是说，当后端有一个redis节点挂了，nutcracker马上发现以后，回去重试。重试两次（server_failure_limit）失败以后就等30秒（server_retry_timeout）再重试，这个过程一直维持。而每次重试都是用真实得数据包发过去，失败后，数据也就丢失了。所以这个配置下每个失败的节点每隔30s就会有两次数据丢失。 nutcracker的这个做法是为了当挂掉的节点又重新爬起来时能恢复，但是不太明白为何它要用真实的数据去做重连尝试，而不是由nutcracker自己发一个心跳包到失败节点做测试，这样起码不会产生数据丢失的问题。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"redis","slug":"redis","permalink":"https://lchml.com/tags/redis/"},{"name":"nutcracker","slug":"nutcracker","permalink":"https://lchml.com/tags/nutcracker/"}]},{"title":"巴蜀五日，风光旖旎","slug":"bashu","date":"2015-08-02T16:00:00.000Z","updated":"2022-05-12T06:01:58.376Z","comments":true,"path":"life/bashu/","link":"","permalink":"https://lchml.com/life/bashu/","excerpt":"当我踏上这片土地，就知道来对了地方。从蜀中到巴南，我走过了一个世界。 ——HML","text":"当我踏上这片土地，就知道来对了地方。从蜀中到巴南，我走过了一个世界。 ——HML 这次巴蜀之旅谈不上是一次说走就走的旅行，但也算是率性而为了，从决定出发到预定机票酒店也就是以分钟来计。真正踏上旅程是在一周后，正值清明。其实我本身不太能也不是很爱吃辣，无奈家中有一只爱吃辣的笨笨，也慢慢习惯了吃辣，当然了，成都重庆正是辣味王国，所以我们来啦——巴蜀天府！ 4.3一大早4:30起来，怕打不到车提前约了uber司机，5:30就顺利坐上了车前往萧山机场。6点多久顺利抵达机场，一分钱没花，Uber棒棒哒，忍不住要为它打下广告！7:40的航班一切都在计划中！飞机准点起飞准点降落，一转眼就从细雨绵绵的杭州到了阳光灿烂的成都。从双流机场出来后直奔快铁（机场交通很便利，有地铁、大巴，也有火车），被告知要去春熙路还需要转车挺麻烦，最后还是选择了机场大巴，往天府广场春熙路一带要坐2号线。我们选择了宜必思酒店，离地铁近，相对来说环境也不错。 放下行李就直奔吃的而去，已经快2点了也是时候填肚子了。酒店楼下就有一家婆婆串串，看上去比较本土，无奈笨笨倾心于另一家看上去更热闹更好吃的。两个人到店做下，老板就上了锅底和菜单，点的是鸳鸯，噼里啪啦点完菜，菜上来发现怎么没有串串，一问才知道串串是要自助拿的，我们吃的算是火锅了，悲剧！上菜的美女说点菜是不能退的，那就只能先吃着了（话说成都的姑娘真的是挺水灵的，脸不胖但是有肉，皮肤也很有水分的样子）。上了慕名已久的冰粉，刚好赶上老板娘自家吃饭，蹭了他们一碗粉丝——辣但好吃——应该是正宗的川味儿！吃完午饭，附近就是春熙路开始逛街，因为是工作日所以人不是很多。和众多的商业街一样，春熙路也是大大小小的商户，可能范围更大一点，从小商品市场级别的到国际大牌LV都有，但没什么意思，大概逛了下就结束了。不过，成都的熊猫元素还真是丰富，随处可见，包括这只IFS上的大熊猫。从春熙路坐地铁很快就到了武侯祠，旁边是锦里。貌似这算是成都的“景点套餐”，被三国文化浸染的蜀地自然是少不了诸葛亮的历史记忆。如果你了解三国，听闻过诸葛亮亦或者只是知道出师表，武侯祠都是你尽情追忆历史的好地方。建议还是租用一个导游仪，至少可以带走一段历史。锦里就在旁边，是一条商业风格的窄巷子，成都的景点有一点好：就是绿树茵茵。在春天来真的是没错的。前半段是一些小玩意儿纪念品，也没什么特别的，后半段据说更多的是小吃，人比较多也就没去挤了。接着我们前往宽窄巷子，这一天算是赶场子了。进巷子前路过肥肠粉经不住诱惑的笨笨要了一碗红油肥肠，我要了一碗豆花，虽说是景区味道倒也不错，不知道是因为饿了还是因为确实好吃。走进巷子，可以发现无论是锦里还是宽窄巷子人都远远多于武侯祠，可见现代游客对历史的热情已经远输于对商业的认可了。勉强找了几个人少的角度。白天走得比较累，夜生活就打算在附近找找吃的了。惊喜的发现酒店附近就有小吃城，来几张重口味的，据说这都是为勇士准备的，瞧这小样应该知道味道怎样了。可惜的是慕名而去的小谭豆花早早关门了，就是这么任性！不过成都的食物真心便宜，一大碗冒菜的价格也就是十几块钱，还是荤素搭配的，至于那副脑–子，就当给笨笨吃啥补啥了。 第二天一早要赶往都江堰。有必要晒晒有名的宜宾燃面，点的是重庆小面和酸菜粉丝，味道很不错，精神抖擞！都江堰由鱼嘴、飞沙堰和宝瓶口三部分组成，这里面是古人治水的宝贵财富暂且不说，单单是整个水利工程的原理了解下来就是叹为观止了。这是我比较推荐的一个景点。要记得让导游或者讲解仪带你走入那个文化的世界，否则你会错过很多东西。景区的右侧是南桥，算是宝瓶口的下游，岷江的水就是从这里远远流去，风景独好。还有值得一提的是那座安澜索桥，又名夫妻桥，是清代何先德夫妇建造，也是寓意着情人夫妻间的誓死情谊。走的时候还是很忐忑的，估计没有心情你侬我侬。拜水都江堰，问道青城山。都江堰给我的印象不错，接下来是前往道家青城。无奈在都江堰待的比较久，下午2点才抵达青城山。主峰老霄顶海拔1260米，青城山的前山是景区，有上清宫和老君阁，都是道家的代表建筑，我们前往前山。从景点到入口还有很长一段距离，可以坐观光车也可以走路。我们尝试着走路，没有让我们失望的是这一路的青翠，空气很清新，也很明朗，这种感觉没有办法用相机记录。开始上山，时间比较晚了，爬上去是不可能了，加之第一天走的有点久，只能索道上山。青城索道不是从山脚下开始的，而是需要爬上去一点，绕过月城湖。可惜的是，旱水期月城湖已经消殆了往日的清丽，并不可人。索道上山，停下来的时候还没有登顶，不知为什么一样的累，爬到上清宫已是完全不行了，可惜了无缘老君阁。下山依然是索道，下山的路总是比上山容易，顺利赶上了回成都的车。这一天下来整个人都软了，但也是累并快乐着。不知道为什么，我总感觉上青山的某个角度和孙悟空拜道的去景点很相似。从青城山回到了成都的老车站——成都北站。北站在2环的位置，离我们住的地方比较远。查了一下，发现乘坐鼎鼎大名的154公交车顺路能回酒店。关键不在于顺不顺路，在于这是一趟特别的公车——沿路是各种吃吃吃！另外，不得不说这真是一辆人性的公车，长着老爷车的皮囊，内部还是很美丽大方舒适的嘛！冲着明婷饭店（苍蝇馆子）去的，结果一路都是好吃的，好几次想下车奔其他的美食而去，还好坚持住了。到曹家巷站下车，就被路边的王记特色锅盔吸引了，正在犹豫要不要吃，怕一会吃不动，老板吆喝着：最后一个，牛肉的，要打烊了！身后另外两个妹子逼近，果断拿下了，他们只有干瞪眼的份了——哈哈，咬一口！还去了久仰大名的明婷饭店，菜品和菜量都是良心啊，两人要是点五个菜包你吃不完，葱油腰花和酸梅汁不错。 清明节，也是在成都的最后一天。安排了去熊猫基地。一大早又去吃了宜宾泡面和肥肠粉，味道棒棒嗒。基地有点远，需要倒车，坐着公交10点就到了，人很多。大熊猫真是蠢萌蠢萌的，好懒，连吃竹子都是躺着吃，吃完一根马上接着下一根，据说他们一天能吃掉40公斤竹子，真是大胃王，这吃法基地的自产竹子根本不够吃，需要去别处买。另外，基地育有各个年龄周期的大熊猫，还有小熊猫和孔雀，遗憾的是没看到熊猫产房。 看完熊猫坐车返回，又路过王记锅盔，忍不住又下来买了，吃完走路回酒店。回到酒店简直累趴了，在成都的几天步行太多，老腰快不行了😁。下午约了王维去电子科大参观。不得不说这真是个气派的土豪学校，小维同学带我们吃了学校的小吃，又吃了地道的成都火锅，辣得很嗨。 成都篇之后马上赶往重庆。重庆之旅是2天。现在想来对重庆的印象比对成都要深刻。可能是由于重庆高低错落的山城印象太鲜明，地铁也都演变成了轻轨。也可能是美食太多，让人流连。我们住在全季酒店，设施很不错，价格也不贵，真是难得。首先吃到的是鼎鼎大名的酸辣粉，无论是用料还是酸辣都是毫不手软，货真价实，笨笨超级喜欢吃，我有点扛不住。 接下来是时候好好看看山城重庆了。我们原则了坐地铁去坐过江索道。重庆整个雾蒙蒙的，似乎停下来坐着看看风景就好了，很宁静。过江之后是重庆的老城区，本想好好走一走，无奈重庆的地形也是醉了，眼看着目的地在头顶上却上不去，硬是要迂回很远才可以。绕道从桥上走回对岸，不过江滨这条南滨路还真的和南山路有几分相似。景区都有神似之处。走了好多路，冲着朝天门去了！天空下着蒙蒙雨，沿路随处可见老百姓随地支起架子，铺张硬纸板打牌，可怜重庆人爱玩。豁出去半条命到了朝天门居然遇到施工被拦起来了。可惜了了。只能坐着公交继续往前。空气很凉爽，我们到了洪崖洞，走得好累，坐下来喝杯茶，坐了好久，夜景很美，只是吹得有点冷😂。到重庆的两天很凉爽，空气里水汽很足，心情很好，仿佛时间过的很快。玩了四天了，最后一天打算悠哉一点不赶路了。第二天睡到很晚起来，远的景点来不及了，由于我们俩都很喜欢重庆的轻轨，觉得重庆是一个很神奇的城市，所以打算坐着轻轨好好看看这个城市。我们一路倒了几条地铁线，从巴中到巴南，领略了山城浩荡风华。临近中午觉得应该去吃一次地道的火锅，找到一家胖子烂火锅，地道的重庆火锅啊，现在想起来也是口水直流。怪事前没做好功课，点的菜还不够到位，吃法也搞错了。鸭肠煮老了，酥肉没有煮着吃。好在土豆和西红柿还是绝美。好像当地人都吃油碟，和我们家里吃的很不一样，那个油碟我吃不下去呀！晚上的飞机很快就到杭州了，这一路留下的不仅仅是回忆。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"成都","slug":"成都","permalink":"https://lchml.com/tags/%E6%88%90%E9%83%BD/"},{"name":"重庆","slug":"重庆","permalink":"https://lchml.com/tags/%E9%87%8D%E5%BA%86/"}]},{"title":"Guava源码阅读","slug":"guava","date":"2015-07-10T16:00:00.000Z","updated":"2022-05-12T06:00:57.233Z","comments":true,"path":"technology/guava/","link":"","permalink":"https://lchml.com/technology/guava/","excerpt":"Guava是Google开源出来的Java常用工具集库，包括集合，缓存，并发，字符串，I&#x2F;O操作等在Java开发过程中经常需要去实现的工具类。","text":"Guava是Google开源出来的Java常用工具集库，包括集合，缓存，并发，字符串，I&#x2F;O操作等在Java开发过程中经常需要去实现的工具类。 如Joiner、Splitter、Strings、CharMathcer等工具类，其中有许多令人眼前一亮的代码。如Strings.repeat方法里，为了尽可能提升效率采用了native方法System.arrayCopy。如Splitter中，匿名类的灵活使用。如Joiner.appendTo中优雅的解决最后一个分隔符问题。如Splitter.separatorStart中神奇的continue用法。 Guava还有一个很重要的功能——GuavaCache，平时开发过程中，一般后台会用数据库作为数据存储。稍大的系统中，为了减少db查询耗费的时间，会在前面加一层NoSql作为缓存。但是随着系统规模的增加，缓存的查询压力会越来越大。本地缓存（或者称为热点缓存）这时候可以有效的缓解缓存的压力，特别当某些数据查询十分频繁但修改较少的时候。 例如，一个官方账号的info数据，几乎每个用户都会用到，很少会有改动。如果按正常得缓存流程，那么每个用户取info时，都会触发一次缓存查询，这会产生很高的tps，如果在每个服务器拿到缓存数据后，存到本地内存中，并设定一个有效期，例如一分钟。那么在一分钟内都不会再去缓存中查询这个数据，相当于直接把tps降到了一分钟一次。当然，这回导致数据更新有一分钟得延迟，多以如果对数据实时性要求非常高的，不适合使用。 使用示例首先我们来看一下使用的示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import com.chinatelecom.yiliao.device.cache.hotspot.AbstractCacheLoader;import com.google.common.cache.CacheBuilder;import com.google.common.cache.LoadingCache;import com.google.common.cache.RemovalListener;import com.google.common.cache.RemovalNotification;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Date;import java.util.concurrent.TimeUnit;/** * Created by lc on 15/7/17. */public class GuavaCacheTest &#123; private static final Logger logger = LoggerFactory.getLogger(GuavaCacheTest.class); private static LoadingCache&lt;String, String&gt; localCache = CacheBuilder .newBuilder() .maximumSize(10) .refreshAfterWrite(1, TimeUnit.SECONDS) .recordStats() .removalListener(new RemovalListener&lt;Object, Object&gt;() &#123; @Override public void onRemoval( RemovalNotification&lt;Object, Object&gt; notification) &#123; logger.warn( &quot;Remove a map entry which key is &#123;&#125;,value is &#123;&#125;,cause is &#123;&#125;.&quot;, notification.getKey(), notification.getValue(), notification.getCause().name()); &#125; &#125;) .build(new AbstractCacheLoader&lt;String, String&gt;() &#123; @Override public String load(String key) throws Exception &#123; logger.debug(&quot;load local cache key: &#123;&#125;&quot;, key); return key + new Date(); &#125; &#125;); public static void main(String[] args) throws Exception &#123; for (int i=0; i&lt;5; i++) &#123; Thread.sleep(900); String valueLoader = localCache.get(&quot;key&quot;); logger.info(&quot;Loader Cache &gt;&gt;&gt; key is &#123;&#125;, value is &#123;&#125;&quot;, &quot;key&quot;, valueLoader); logger.info(&quot;Loader Cache &gt;&gt;&gt; stat miss:&#123;&#125;, stat hit:&#123;&#125;&quot;, localCache.stats().missRate(), localCache.stats().hitRate()); &#125; &#125;&#125; 上述代码，简单的介绍了一种GuavaCache的常用方式。在GuavaCache对外提供的方法中， recordStats和removalListener是两个很有趣的接口，可以很好的帮我们完成统计功能和Entry移除引起的监听触发功能。 Builder模式设计模式中的Builder模式 在Guava中很多地方得到的使用。Builder模式是将一个复杂对象的构造与其对应配置属性表示的分离，也就是可以使用基本相同的构造过程去创建不同的具体对象。例如在web接口中的返回对象就常用这种模式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;/** * Created by lc on 15/4/23. */public class ResponseEntry &#123; private int code; private String msg; private Object obj; @Deprecated public ResponseEntry(int code) &#123; this.code = code; &#125; @Deprecated public ResponseEntry(int code, String msg) &#123; this.msg = msg; this.code = code; &#125; private ResponseEntry() &#123; &#125; public int getCode() &#123; return code; &#125; public ResponseEntry setCode(int code) &#123; this.code = code; return this; &#125; public String getMsg() &#123; return msg; &#125; public ResponseEntry setMsg(String msg) &#123; this.msg = msg; return this; &#125; public Object getObj() &#123; return obj; &#125; public ResponseEntry setObj(Object obj) &#123; this.obj = obj; return this; &#125; public static ResponseEntry buildler() &#123; return new ResponseEntry(); &#125; public static ResponseEntry buildler(int code) &#123; return new ResponseEntry(code); &#125; @Override public String toString() &#123; return JSON.toJSONString(this); &#125;&#125; Tips：在Effective Java第二版中，Josh Bloch在第二章中就提到使用Builder模式处理需要很多参数的构造函数。他不仅展示了Builder的使用，也描述了相这种方法相对使用带很多参数的构造函数带来的好处。 对象引用在说GuavaCache之前，首先需要了解一下java中的引用。java在1.2版本之前对象只有两种引用方式：被引用和没有被引用。但是这种方式对GC来说效果并不好，因此在1.2之后的版本中，java对引用的概念进行了扩展，一共有四种引用方式： 强引用（Strong Reference）：强引用在程序代码中随处可见，十分普遍。比如：Object object = new Object()，这类引用只要还存在，垃圾收集器就永远不会回收掉这类引用的对象。 软引用（Soft Reference）：软引用用来描述一些虽然有用但是并不是必须的对象。对于软引用关联的对象，在系统将可能发生内存溢出异常之前，垃圾收集器将会把这些引用的对象进行第二次回收。只有这次垃圾回收还没有足够的内存的时候，才会抛出内存溢出异常。 弱引用（Weak Reference）：弱引用是一种比软引用强度还要弱的引用，因此这些引用的对象也是非必须的。但是，对于弱引用的对象只能生存到下一次垃圾回收发生之前。当垃圾收集工作开始后，无论当前的内存是否够用，都会把这些弱引用的对象回收掉。 虚引用（Phantom Reference）：虚引用是最弱的一种引用。一个对象是否被虚引用关联，完全不会对其生存时间构成影响，也无法通过虚引用获得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 对象可见性什么是可见性？可见性就是，当程序中一个线程修改了某个全局共享变量的值之后，其他使用该值的线程都可以获知，在随后他们读该共享变量的时候，查询的都是最新的改改修改的值。与CPU的多级缓存结构类似，Java虚拟机中内存分为两类： 主内存（Main Memory）：所有线程共享的内存区域，虚拟机内存的一部分。 工作内存（Work Memory）：线程自己操作的内存区域，线程直接无法访问对方的工作内存区域。 之所以分为两部分内存区域，原因和CPU很类似。为了线程可以快速访问操作变量，当线程全部直接操作共享内存，则会导致大量线程之间竞争等问题出现，影响效率。关于Java中工作内存和主内存之间的交互关系如下图：为了保证共享变量可见性，除了volatile之外，还有synchronized和final关键字。 synchronized：执行synchronized代码块时，在对变量执行unlock操作之前，一定会把此变量写入到主内存中。final：该关键字修饰的变量在构造函数中初始化完成之后（不考虑指针逃逸，变量初始化一半的问题），其他线程就可以看到这个final变量的值，并且由于变量不能修改，所以能确保可见性。 锁细化在Java语言中，最经典的锁细化提高多线程并发性能的案例，就是ConcurrentHashMap，其采用多个segment，每个segment对应一个锁，来分散全局锁带来的性能损失。从而，当我们put某一个entry的时候，在实现的时候，一般只需要拥有某一个segment锁就可以完成。 关于普通的HashTable结构和ConcurrentHashMap结构，从下图可以很显而易见的看出两者的区别。所以，就锁这个层面上，concurrentHashMap就会比HashTable性能好。 Guava ListenableFuture接口未完","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"},{"name":"Guava","slug":"Guava","permalink":"https://lchml.com/tags/Guava/"}]},{"title":"这才叫休息","slug":"rest","date":"2015-03-10T16:00:00.000Z","updated":"2022-05-12T06:09:31.696Z","comments":true,"path":"life/rest/","link":"","permalink":"https://lchml.com/life/rest/","excerpt":"这是网上看到的一篇关于“休息”的文章，觉得有些道理，现在很多人确实一到周末都不知道怎么办了，不知道怎么休息，怎么放松。","text":"这是网上看到的一篇关于“休息”的文章，觉得有些道理，现在很多人确实一到周末都不知道怎么办了，不知道怎么休息，怎么放松。 为什么你睡了11个小时仍然觉得疲劳？为什么你花了好几万去岛国度假并没有增加生活的热情？ 都说要去KTV，去夜店，去游乐园就能忘掉不快，更带劲地开始新的一天，但是尽心归来心里只剩空虚？ 我们真的明白休息的含义吗？我们休息对了吗？你理解的休息是什么？一个饱觉？一阵疯玩？到KTV释放后的一串饱嗝？ 休息的真正含义是什么？是恢复疲劳，放松神经，当你重新投入工作与学习时觉得又是一个精力充沛的新人。 如果你的休息方式不能带给你这些，那么，无论这些活动听起来有多轻松，看上去有多high，它都是错的。抛弃它们，来一场休息革命吧！ 一、脑力劳动者，补瞌睡对你没什么用。 你写了一天文案，主持了一天会议，当一切结束了，你感叹：太累了，这一天我要睡个好觉。我们的常识使得我们对疲劳的第一反应是“去躺会吧”。但这是一个陷阱。 睡眠的确是一种有效的休息方式，但它主要对睡眠不足或体力劳动者适用，对体力劳动者来说，“疲劳”主要是由体内产生大量酸性物质引起的，如果十分疲劳，应采取静的休息方式。 但如果你是坐办公室的，大脑皮层极度兴奋，而身体却处于低兴奋状态，对待这种疲劳，睡眠能起到的作用不大，（除非你是熬夜加班，连正常睡眠时间都达不到）因为你需要的不是通过“静止”恢复体能，而是要找个事儿把神经放松下来。这样你就可以理解为什么你周末两天不出门依旧无精打采，而只需下班后游泳半小时就神采奕奕。 二、不必停下来，只是换一个。 既然睡觉不能帮助我们休息大脑，那什么可以呢？答案不是停止活动，而是改变活动的内容。大脑皮质的一百多亿神经细胞，功能都不一样，他们以不同的方式排列组合成各不相同的联合功能区，这一区域活动，另一区域休息。 比如你星期五写了5个小时得文案，最好第二天去给你盆栽们剪枝而不是睡到太阳晒屁股。还有一点，当你无法选择由脑力劳动转入体力劳动时，不妨在脑力劳动内部转换。 三、最好的休息，是让你重燃生活的热情。 我们的疲惫主要来自对现有的一成不变的生活的厌倦。所以最好得休息项目就是那些能让我们重新找到生活和工作热情的活动。如果你干完一件事，能够幸福得感叹“明天又是新的一天”。那这件事对你来说就是最好的恢复热情，调节情绪的方法。但可惜我们缺乏对“休息”的想象力，我们能想出来的休息方式不是痴睡就是傻玩。 我们给你开了下面一些活动清单，基本思路是以“做”来解决“累”，用积极的休息取代消极的放纵。当然最适合你的方式还是要你自己探索。事实上如果你觉得打扫卫生比坐过山车更能放松，那就去吧，别管世界上其他人都在玩什么。 也许你可以： 用看两个小时让你开怀的漫画或者小说代替去KTV唱那些一成不变的口水歌。 试着放弃在周六晚上熬夜，10点入睡，然后在7点起床，去没人得街上走走，你会发现这一天可以和以往的周末有所不同。 不要再去已经去过无数次的度假村。找一条你从没去过的街道，把它走完，你会发现这个你感到腻味的城市，你其实没有完全体会到它的妙处。 旅行，而不是换个地方消遣。去一个地方，对那个地方心存好奇，对自己这趟旅程心存美意，感受自己经验范围以外的人生样貌。而不是坐了5个小时飞机，只是换个地方打麻将，换个地方玩手机，换个地方打游戏。 从这周末起开始学习一项新技艺，比如书法，乐器，运动等。每周末练习1小时以上。 去社交。不要认为它总是令人疲倦的。虽然和看书比起来，它稍有点令人紧张，但也能让你更兴奋，更有认同感。它让你在朝九晚五的机械运动中不至于失去活泼的天性。女性朋友们尤为需要走出去和朋友聚会，这些时刻你不再是满脸写着效率的中性人，而是一个裙裾飞扬的魅力焦点。 做点困难的事。心理学家发现接触神经紧张的方法，是去处理需要神经紧张才能解决的问题。所以压力特别大的时候，你可以给自己再找份工作，但不要和你的职业类似。比如去孤儿院做义工，或者去一个复杂的机械工厂从学徒做起，或者做一道非常复杂的数学题。 花时间休息，可以使你获得大量的精力、体力，使你能够保持一种愉悦的心情工作生活。当听到有人说，他工作太忙，没有时间休息，觉得这个人有些反常。 很早以前就有人说过：不会休息的人就不会工作。可我们由于功利的原因，我们早就忘了。于是我们努力，我们忙碌，于是也就害怕无聊，害怕无事可做，甚至会因为闲暇而几乎惶惶不可终日。还有一种说法叫“享受无聊”。传统的教育告诉我们“无聊”是一种消极的情绪，一个奋发向上的人绝不该有这种情绪，甚至不该有无聊得机会。背负了太多责任，所以我们活的很累，冠冕堂皇的说压力来自外界，但更多的压力是来自我们自己，因为在这个充满压力的社会里，我们没有学会给自己减压。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"随想","slug":"随想","permalink":"https://lchml.com/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"登北高峰","slug":"beigaofeng","date":"2015-03-06T16:00:00.000Z","updated":"2022-05-12T06:01:54.120Z","comments":true,"path":"life/beigaofeng/","link":"","permalink":"https://lchml.com/life/beigaofeng/","excerpt":"雾霾之下，共同呼吸。","text":"雾霾之下，共同呼吸。 北高峰海拔300多米，在杭州灵隐寺后，石磴数百级，曲折三十六湾。上有华光庙，以祀五圣。山半有马明王庙，春日祈蚕者咸往焉。峰顶浮屠七级，唐天宝中建，会昌中毁；钱武肃王修复之，宋咸淳七年复毁。 从过完年来，一直都是阴雨天气，上周日终于放晴，春游好时机。爬完回来结果就一直忙到现在也没时间，趁周末记录一下。上周末最火的事莫过于柴静的《穹顶之下》，似乎所有人一下子都觉的雾霾好恐怖，环保好重要，大有一种再不治理雾霾，马上就不能呼吸了的势头。没过几天，又开始跳出来各种各样的人，揣测柴静的各种各样的动机等等。看起来还都好像挺有理，总之在这个互联网的时代，任何事情被质疑都没什么好奇怪的。无论怎么撕逼或者谁对谁错，都要好过全世界只有一种声音。在我看来，发展要保证，环保要治理，政府要有所作为，过程要循序渐进。至于怎么实现，那就是政府公仆们该想的事了，在其位，司其职。 2015.3.1 起床，下楼，吃饭，出发，开车到浙大玉泉校区（校内停车5元&#x2F;小时），12点左右开始上山，从玉泉后面可上老和山。全程路线图：达到美女山附近时可以看见西湖全貌状元峰附近接下来很长一段起起伏伏的山路，2点多到达北高峰，可以看到有缆车上山，山上的灵顺寺——天下第一财神庙香火鼎盛。山顶人很多，逗留一会便开始下山，下山有两条路，一条通往法华寺，另一条则通往灵隐寺。下山途中的灵隐寺外墙。达到山脚下，风景不错，是不是有那么一点夏尔的感觉呢。最后，坐807路公交回到玉泉，4点左右。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"北高峰","slug":"北高峰","permalink":"https://lchml.com/tags/%E5%8C%97%E9%AB%98%E5%B3%B0/"},{"name":"西湖","slug":"西湖","permalink":"https://lchml.com/tags/%E8%A5%BF%E6%B9%96/"}]},{"title":"redis高可用","slug":"redis","date":"2015-02-11T16:00:00.000Z","updated":"2022-05-12T06:09:17.898Z","comments":true,"path":"technology/redis/","link":"","permalink":"https://lchml.com/technology/redis/","excerpt":"redis容量达到90%，通过slave导入master数据，进行扩容。","text":"redis容量达到90%，通过slave导入master数据，进行扩容。 新开一个redis实例，redis.conf配置slave-read-only yes，当作为slave时开启只读模式保证数据只从主服务器写入同步到从服务器。启动redis后进入redis-cli，通过命令把当前redis设置为另一个redis的slave。 12127.0.0.1:5000&gt; slaveof 127.0.0.1 6379OK 然后用info命令查看状态： 1234567# Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:up# Memoryused_memory:90260000 看到已经是slave状态，根据use_memory判断数据同步是否完成。 新增加slave扩容，虽然可以提高空闲容量，但是master中无效的数据同样会被同步到slave中，造成存储浪费。因此要清除master中已经无效的key（先把数据同步到slave，再从slave中导出key，避免影响master的线上服务）： 1$./redis-cli -h host -p port keys &#x27;*&#x27;|grep xxx &gt; keys.dat 同样为了避免删除数据时，影响redis的线上服务，应对删除速度做限制。可以用jedis写一个java程序去跑，但是为了这么一个简单地操作，要弄一个java程序出来，有种牛刀杀鸡的感觉。这种时候就应该想到python，通过redis-py写一个简单地脚本就可以搞定了。安装redis-py： 1$sudo pip install redis 读文件中的key逐个删除，放慢速度。 1234567891011121314# !/usr/bin/env python# coding: utf-8import redisimport timeif __name__ == &#x27;__main__&#x27;: i=0 r = redis.StrictRedis(host=&#x27;127.0.0.1&#x27;, port=6379, db=0) for key in open(&#x27;/Users/lc/keys.dat&#x27;): print &#x27;delete:&#x27;, key.strip(), r.delete(key.strip()) if i % 20 == 0: time.sleep(0.01) i += 1 清楚完master的数据，然后查看slave中是否同步完成，完成后关闭slave模式，并把新的redis节点加入nutcracker配置。 12127.0.0.1:5000&gt; slaveof no oneOK","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"redis","slug":"redis","permalink":"https://lchml.com/tags/redis/"}]},{"title":"新版国行kindle paperwhite2开箱","slug":"kindle","date":"2015-01-26T16:00:00.000Z","updated":"2022-05-12T06:07:16.371Z","comments":true,"path":"life/kindle/","link":"","permalink":"https://lchml.com/life/kindle/","excerpt":"第一次看到同事的kindle时，确实被电子墨水惊艳到了.","text":"第一次看到同事的kindle时，确实被电子墨水惊艳到了. 真的已经极其贴近纸质阅读的体验（翻页技术还有待提高，虽然现在翻10次左右才会又一次全刷也可以接受了），还有就是它只为阅读而生的纯粹——拿着kindle你只能看书。我总是会被任何做到极致的事物所吸引。在纠结（有钱早买了）了很久，了解了美版日版国行等等之后，终于在亚马逊买了一台国行的kindle paperwhite2。kindle6比kp2要便宜400块，至于外壳手感差一点什么的都无所谓，可是没有背光阅读灯这一点，只能放弃它了。kv则要2000快，虽然优化了很多体验，但是这个定价还是略黑啊。好了，拿到包裹开始拆。 完整包装。这是最新版的包装，之前的包装盒有一边是带斜角的，封条与包装盒一体。新版的封条比较简陋（其实就是直接用了kindle6的包装）。背面去掉外壳，里面的盒子。封条，是一种不干胶，直接沿着箭头撕开就行了。我觉得还是原来的与盒子一体化的封条让人更有安全感。打开盒子就可以看到kindle了，如果你看到kindle上的画面不是图上这个，说明kindle不是全新的。因为这个画面只有出厂的时候才会有，一旦开启过，不管是刷机还是怎么样都回不到这个画面，只能返厂。拿出kindle，下面是两本基本没用的说明书，在下面就是数据线，巨长无比的数据线，-_-|||不知道是亚马逊太实在了还是怎么滴，那么长的数据线有必要么。。。按电源键开机，点一遍新手教程，然后会提示你注册kindle，都买kindle了应该都有亚马逊账号吧，国行的直接注册到z.cn。问题来了，我的kindle怎么注册都不行，一直提示超时，让我一度怀疑是不是买了假货呢。联系客服，话说亚马逊的客户还是应该赞一下的，都不需要你打电话过去，你去网页上点一下让客服打给你，马上就会收到一个人工客服打过来的电话。然后开始各种重启，换wifi得操作，发现还是不行。最后她说第一次注册时，对网络的要求比较奇怪，有些网络不行。一想刚才wifi换来换去都是公司网络，等于没变，最后用手机3G网络共享热点试了一下，果然好了。第一次注册成功，后面就没问题了。在设置-设备信息中可以看到kindle的序列号，最新4G版本的应该都是9017开头的。最后来一张kindle与实体书的对比吧。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"kindle","slug":"kindle","permalink":"https://lchml.com/tags/kindle/"}]},{"title":"IP数据库","slug":"ipdb-creator","date":"2015-01-19T16:00:00.000Z","updated":"2022-05-12T06:06:39.476Z","comments":true,"path":"technology/ipdb-creator/","link":"","permalink":"https://lchml.com/technology/ipdb-creator/","excerpt":"项目放在github上，python版本ipdb_creator，java版本ip-locator。","text":"项目放在github上，python版本ipdb_creator，java版本ip-locator。 IP数据库生成首先要知道IP的分配是一直变化的，所以不会存在绝对准确的IP库。IP库需要经常更新才能保证较高的准确度。IP的分配由国际非盈利性组织ICANN负责，所以要生成最新的IP库首先需要从这里下载5个最新原始分配文件，分别是delegated-arin-latest delegated-ripencc-latest delegated-lacnic-latest delegated-afrinic-latest delegated-apnic-latest。 我们需要处理的是文件中ipv4的记录，每条记录的格式如下： 1apnic|AU|ipv4|1.0.0.0|256|20110811|assigned AU: 表示澳大利亚的简称 ipv4: 表示记录的ip类型 1.0.0.0: 表示记录的起始IP 256: 表示记录从起始IP往后256个地址 20110811: 表示分配时间 assigned(allocated): 表示已分配 国家缩写与名字的对应关系，可以直接看python项目中的country_code文件。在大部分应用场景下，国内IP需要精确到省或者市级别，国外IP大部分只需要精确到国家级别。那怎么才能得到比较准确的国内IP库呢？ 现在网上有很多免费的IP查询工具，有的比较友好提供了HTTP的查询接口。经过长时间的查询对比发现，其中IP淘宝和17MON的准确率相对比较高。为了得到最全面的数据，我把delegated-apnic-latest中分配给CN的所有记录拿出来，然后对每条记录中的每个24网段进行扫描，最后把得到的中国全部24网段IP地址进行合并，就得到了国内IP库。对于IP分配中一些没有指明国家码的记录也可以用同样地方法。要注意，大部分免费提供的IP查询接口都是对频率有限制的，如上面说的两个都是限制每个来源IP每秒10次的频率。 CN记录拆分为24网段以一条记录为例 apnic|CN|ipv4|1.0.8.0|2048|20110412|allocated，把记录转换成CIDR格式1.0.8.0&#x2F;21，以java为例： 12345678910String[] params = line.split(&quot;\\\\|&quot;); // do filter ...String baseIP = params[3];int masklen = 32 - (int) (log(Integer.parseInt(params[4]), 2));String netcidr = baseIP + &quot;/&quot; + masklen;if (masklen &gt; 24) masklen = 24;IPv4Network networks = new IPv4Network(prefix);for (String subnet : networks.getSubnet(24)) &#123; // query ...&#125; 可以看到关键的方法就是getSubnet(24)，简单地说就是，从起始地址开始，每隔256个IP截断，最后就得到了对应的24网段列表。来看它的实现： 1234567891011121314public List&lt;String&gt; getSubnet(int masklen) &#123; if (masklen &gt; 32 || masklen &lt; 8 || masklen &lt; numericCIDR) &#123; throw new NumberFormatException(&quot;masklen can not be greater than 32&quot;); &#125; int numberOfIPs = 1 &lt;&lt; (32 - masklen); Long startIP = baseIPnumeric &amp; netmaskNumeric; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i=0; i&lt;Math.pow(2, masklen-numericCIDR); i++) &#123; String subnet = IPUtil.ipLong2String(startIP) + &quot;/&quot; + masklen; startIP += numberOfIPs; list.add(subnet); &#125; return list;&#125; 查询及频率限制以淘宝IP查询为例，接口可以在浏览器输入 http://ip.taobao.com/service/getIpInfo.php?ip=1.0.8.1 查看返回的结果，返回结果为json格式， 123456789101112131415161718192021private IpData queryFromTaobao(String ip) throws Exception &#123; limitRate.check(); String ret = HttpClientPool.getInstance().getMethod(TAOBAO_URL + &quot;?ip=&quot; + ip, 5000); if (ret == null) &#123; return null; &#125; else &#123; JSONObject json = JSON.parseObject(ret); if (json.getInteger(&quot;code&quot;) == 0) &#123; JSONObject dataJson = json.getJSONObject(&quot;data&quot;); IpData ipData = new IpData(); ipData.setCountry(dataJson.getString(&quot;country&quot;)); ipData.setProvince(dataJson.getString(&quot;region&quot;)); ipData.setCity(dataJson.getString(&quot;city&quot;)); ipData.setIsp(dataJson.getString(&quot;isp&quot;)); ipData.setIp(ip); return ipData; &#125; else &#123; return null; &#125; &#125;&#125; 其中LimitRate是本地实现的一个简单频率控制，通过Queue接口实现一个限制队列大小的LimitQueue类，然后在一个单例的LimitRate中初始化一个LimitQueue队列，指定队列大小为10，时间间隔为1000ms。每次查询前先调用LimitRate的check方法，如果队列长度小于10，直接返回；等于10就从LimitQueue队列中取出队列顶部的时间（即最早进入队列的时间）与当前时间对比，若间隔小于1000ms，则sleep(1001-间隔ms数)，最后把当前时间写入队列。 12345678910111213public void check() throws InterruptedException &#123; if (queue.size() &lt; limit) return; Long first = queue.peek(); if (first == null) return; long now = System.currentTimeMillis(); if (now - first &lt;= duration) &#123; logger.info(&quot;limit rate checked, sleep a while&quot;); Thread.sleep(duration - now + first + 1); &#125; queue.offer(now);&#125; 虽然对查询频率做了限制，但这并不保证接口的每一次查询都能正确返回结果，所以查询结果无效时应该重新查询，直到得到有效结果为止。 IP网段合并最后需要对扫描的结果进行合并，由于扫描时全部拆分成24网段，而IP的分配又是不连续的，所以合并的时候要仔细，不要出错。首先要对扫描结果按IP排序，然后依次取出每一条结果，如果第n条与第n-1条的结果是相同的，则存入临时队列，直到当n与n-1的结果不同，这时把临时队列中的数据进行合并，合并结果存入最终的输出队列，并清空临时队列，循环此过程，最后就可以得到合并的结果。以下面三条结果的合并为例： 1231.0.1.0/24;中国;福建省;福州市;电信;1.0.1.123;2561.0.2.0/24;中国;福建省;福州市;电信;1.0.2.20;2561.0.3.0/24;中国;福建省;福州市;电信;1.0.3.247;256 (1) 首先对每一个网段的IP范围，如1.0.1.0&#x2F;24的IPRange是1.0.1.0~1.0.1.255对应的long型范围是16777472-16777727，1.0.2.0&#x2F;24对应16777728-16777983，如果16777728 - 1 &lt;&#x3D; 16777727，则说明两个网段是连续的，则合并成新的IPRange：16777472-16777983，以此类推，最后得到16777472-16778239（如果网段中存在不连续的情况，则会得到多个IPRange）。 (2) 接着处理得到的IPRange(s)，先把IPRange转换成能包含它本身的最小IP网段，16777472-16778239的startIP为16777472，endIP为16778239，n从1开始，n++直到满足 $$endIP - 2^n &lt;&#x3D; startIP$$ $$endIP - 2^{n-1} &gt; startIP$$ 得到结果startIP&#x2F;(32-n)转换成可读形式：1.0.0.0&#x2F;22。 (3) 最后，由于合并后网段包含范围超出了原本的三个网段，所以要对该结果再进行拆分。如果合并后的网段的起始IP小于合并前的起始IP，则以合并前的最小网段为界，把合并后网段拆分为小于，等于，大于合并前的最小网段的三个范围（合并后的网段的最大IP大于合并前的最大IP情况，也同理可推），这里的实现稍微有点复杂，通过代码来理解会比较容易一些，对应方法为IPUtil.cidrPartition()。最后得到合并后的网段： 121.0.1.0/24;中国;福建省;福州市;电信;1.0.3.247;2561.0.2.0/23;中国;福建省;福州市;电信;1.0.3.247;512 IP数据库使用完整的数据库已经生成，那么如何使用它呢？ RadixTreeRadixTree（基树）是通用的字典类型数据结构，在Linux内核及Nginx中被用于路由表的设计。RadixTree与传统的二叉树差不多，只是在寻找方式上，利用比如一个unsigned int的类型的每一个比特位作为树节点的判断。比如一个数 10001010101010100101010100101010按照Radix树的插入就是在根节点，如果遇到0，就指向左节点，如果遇到1就指向右节点，在插入过程中构造树节点，在删除过程中删除树节点。 插入由于java中没有无符号整型，为了能表示最大的ipv4，我们用long型的低32位代替。key为ip的主机字节序，mask为网段的子网掩码，value为该网段的信息。以1.0.1.0/24为例，key&#x3D;0x01000100，mask&#x3D;0xFFFFFF00。从最高位开始，判断key的每一个位，1则前往右节点，0则前往左节点。如果当前节点不存在，则创建新的节点。 12345678910111213141516171819202122232425262728293031323334353637public void put(long key, long mask, IpData value) &#123; long bit = 0x80000000L; // 128.0.0.0 int node = ROOT_PTR; int next = ROOT_PTR; // 从最高位开始，判断key的每一个位，1则前往右节点，0则前往左节点 while ((bit &amp; mask) != 0) &#123; next = ((key &amp; bit) != 0) ? rights[node] : lefts[node]; if (next == NULL_PTR) // 节点不存在，跳出循环 break; bit &gt;&gt;= 1; node = next; &#125; if (next != NULL_PTR) &#123; // next不为NULL，是因bit&amp;mask为0，也就是已经判断过key的最后一位，而退出上面的while的，则覆盖当前节点的值 values[node] = value; return; &#125; while ((bit &amp; mask) != 0) &#123; if (size == allocatedSize) expandAllocatedSize(); next = size; // 新增一个空节点 values[next] = NO_VALUE; rights[next] = NULL_PTR; lefts[next] = NULL_PTR; if ((key &amp; bit) != 0) &#123; rights[node] = next; &#125; else &#123; lefts[node] = next; &#125; bit &gt;&gt;= 1; node = next; size++; &#125; values[node] = value; // 最后走完key的所有位，到达目标节点，存入value&#125; 查找如果明白插入的原理，那么查找就比较简单了。给定一个ip，首先将ip地址转换成主机字节序的四个字节，从32位的key的最高位开始，0就转向左节点，1就转向右节点，这样从树的根节点开始，直到找到对应的叶子节点为止，在此查找路径上最后一个值不为NO_VALUE的node的value就是查找的结果。 1234567891011121314public IpData selectValue(long key) &#123; long bit = 0x80000000L; IpData value = NO_VALUE; int node = ROOT_PTR; while (node != NULL_PTR) &#123; if (values[node] != NO_VALUE) value = values[node]; node = ((key &amp; bit) != 0) ? rights[node] : lefts[node]; bit &gt;&gt;= 1; &#125; return value;&#125; 结束为了省点买IP付费数据库的钱，也不容易啊。方案还在进一步完善中，目前由于是单台机器，在1秒10次的频率限制下，完整跑一次需要的时间较长，正在考虑设置代理请求，加快查询频率，如果出口IP够多的话，可以大幅提高速度。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lchml.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"IPDB","slug":"IPDB","permalink":"https://lchml.com/tags/IPDB/"}]},{"title":"我们的世界","slug":"ourworld","date":"2015-01-19T16:00:00.000Z","updated":"2022-05-12T06:08:30.275Z","comments":true,"path":"life/ourworld/","link":"","permalink":"https://lchml.com/life/ourworld/","excerpt":"一张有意思的图","text":"一张有意思的图","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"随想","slug":"随想","permalink":"https://lchml.com/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"龙门 · 杏梅尖","slug":"mountaineering","date":"2015-01-14T16:00:00.000Z","updated":"2022-05-12T05:59:35.315Z","comments":true,"path":"life/mountaineering/","link":"","permalink":"https://lchml.com/life/mountaineering/","excerpt":"杏梅尖–位于孙权故里龙门古镇之龙门山，海拨1067.6米，为富阳最高峰。","text":"杏梅尖–位于孙权故里龙门古镇之龙门山，海拨1067.6米，为富阳最高峰。 时间：2015年1月11号 早晨6点起床，收拾东西吃完早饭，7点驱车从家去公司，约定时间7:30到达公司，人未到齐，等到8点，5个人一辆车从公司出发。 约40分钟后到达山脚下，上山前发现自己的水带的不够，在路边小店多买红牛和尖叫（真是爬山时的好东西），出发！ 山脚下的小狗们。 开始上山，早上的山脚还没有阳光进来，略冷。 可以看见山谷外面的阳光 去看龙门瀑布的“野路”，不是很好爬，幸好前一天专门去20公里外的迪卡侬买了一身登山装备，还是很有用的。 到达龙门瀑布，看起来就像一条小水沟，照片上甚至都找不到了，不信你找找看。 走回到正路上，抬头发现看到的天已经很蓝了。此时大约9点50，已经爬了一个小时左右。 接下来近一个小时的路，大家闷头往上爬。一直爬到半山腰的休息站–杏梅坞。美的像油画一般。下面的照片已经被我作为手机屏保了。 同路的还有一个叫“溪山行”的户外俱乐部队伍（可以给广告费么），所有人开始在湖边吃午饭，补充能量。看到他们拿出来的食物时，心里落差好大，我们只是准备了普通得干粮充饥，可是他们居然带着寿司，卤味，排骨，自热盒饭，甚至于还有人带着户外厨具，油盐酱醋全部带齐。真是给跪了，煮面的，炒菜的。。。。。。看不下去了，补充完体力，继续出发。此时大约10点20分，离山顶还有约500米。 大约爬了半小时，有一块大岩石，可以休息。还顺手灌了点山沟里的水。 继续上路，经过一个破房子，然后继续走啊走，爬啊爬，终于看到了希望的画面。 一种即将走向光明的即视感，有没有？咬牙冲上去，发现这只是登顶前的休息处。登山不登顶，做人怎能赢！目测离目标最高峰还有100米的海拔，此时大约下午1点。 接下来的路变的比较陡，爬起来比较累，好在已经不远了。好不容易爬上来，结果看到一个牌子：新的起点·新的高度！真正得最高峰–杏梅尖已经可以看见了，就在身后，大家在这里合影一个。 继续爬！最终在1点40左右终于成功登顶！鼓掌！ 在山顶休息到2点左右，开始下山，最后4点10分到达山脚下，下山时几乎没有休息（对膝盖和小腿真是折磨啊）。最后，5点成功回到公司。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"杏梅尖","slug":"杏梅尖","permalink":"https://lchml.com/tags/%E6%9D%8F%E6%A2%85%E5%B0%96/"}]},{"title":"Eclipse on Mac with svn","slug":"mac-eclipse-svn","date":"2014-12-25T16:00:00.000Z","updated":"2022-05-12T05:59:42.714Z","comments":true,"path":"technology/mac-eclipse-svn/","link":"","permalink":"https://lchml.com/technology/mac-eclipse-svn/","excerpt":"自从换了mac，IDE也同时换成了idea，一直没有去用过eclipse。前两天心血来潮(zuo)，想着怀旧一下，打开eclipse搞一搞。结果悲剧发生了，mac下的eclipse用svn居然如此艰难，以至于花了好多时间才搞定它（其实我也用不着，只是有搞不出来不爽的强迫症。。。）。下面总结一下这个悲剧。","text":"自从换了mac，IDE也同时换成了idea，一直没有去用过eclipse。前两天心血来潮(zuo)，想着怀旧一下，打开eclipse搞一搞。结果悲剧发生了，mac下的eclipse用svn居然如此艰难，以至于花了好多时间才搞定它（其实我也用不着，只是有搞不出来不爽的强迫症。。。）。下面总结一下这个悲剧。 下载完eclipse解压打开，然后安装Subclipse。然后到eclipse设置里看下subversion，悲剧了，弹出提示： 1234567Failed to load JavaHL Library.These are the errors that were encountered:no libsvnjavahl-1 in java.library.pathno svnjavahl-1 in java.library.pathno svnjavahl in java.library.pathjava.library.path = /usr/lib/jvm/java-6-sun-1.6.0.20/jre/lib/i386/client:/usr/lib/jvm/java-6-sun-1.6.0.20/jre/lib/i386:/usr/lib/xulrunner-addons:/usr/lib/xulrunner-addons:/usr/java/packages/lib/i386:/lib:/usr/lib 按照常用套路，google之（悄悄告诉你，最好别用度娘），发现原来由于mac osx这个二货中自带的Subversion居然是个阉割货（不明白为什么要阉割掉），里面没有JavaHL相关的库，这个库的作用简单地说，就是提供接口给第三方比如subclipse这种来调用本地的svn用的，所以当subclipse发现没有这个库的时候，就没办法了。（这里其实还有个选择，就是安装subclipse的时候勾上SVNKit，这样的话它就会自带一个svn客户端，不需要通过JavaHL调用本地svn，不过不推荐这么搞，一个环境下，最好用同样的svn） 所以解决问题的关键是要给svn安装一个JavaHL库，google了好久，被坑了好多回，发现JavaHL这个库没法独立给svn补回去（或者是我没找到对的方法），于是只有换掉整个svn这个思路，先记得svn --version看看已经有的svn版本，免得换了以后发现版本不一样又发生悲剧（比如我）。 在mac上安装svn，首先需要安装brew，当然也可以用macport，反正一个意思。安装brew非常简单，一个ruby脚本就搞定了(mac是自带ruby环境的)： 1$ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot; 然后就可以使用brew命令了，类似于debain下面的apt-get。安装完整的svn，命令： 1$brew install --universal --java subversion 如果你恰好用的是跟它一样的最新版本，那没关系，如果你用的是1.6或1.7的版本，那就需要对应的把subversion换成subversion16或subversion17。安装过程中需要make，可能花费一点时间，这要看你的机器了。 完成后，你可以看到安装过程中要求你执行以下命令： 12$sudo mkdir -p /Library/Java/Extensions $sudo ln -s /usr/local/lib/libsvnjavahl-1.dylib /Library/Java/Extensions/libsvnjavahl-1.dylib 不过执行第一个命令前记得先看下这个目录是不是已经存在，已经存在就不用mkdir了。执行第二个命令，把包链接过去就完事了。 最后重启eclipse，再去subversion那个选项看看，是不是已经找到JavaHL库了呢？","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"svn","slug":"svn","permalink":"https://lchml.com/tags/svn/"}]},{"title":"学贵专·而不以泛滥为贤","slug":"java-interview","date":"2014-12-22T16:00:00.000Z","updated":"2022-05-12T06:00:17.681Z","comments":true,"path":"technology/java-interview/","link":"","permalink":"https://lchml.com/technology/java-interview/","excerpt":"工作一年多时间，做了很多事，学了很多新东西。但对自己的掌握的东西没有一个明确地概念，为了对自我有更清晰的认识，决定去网上投一些简历，类似的网站有很多，选了拉勾网这个目前比较火的程序猿招聘网站，简单制作了自己的简历。投了几个薪水相对较高的公司职位（因为这样要求也会比较高），很快就收到了来自阿里巴巴聚划算的面试电话。从毕业后就没有面试过的我，面试时还是挺紧张的。","text":"工作一年多时间，做了很多事，学了很多新东西。但对自己的掌握的东西没有一个明确地概念，为了对自我有更清晰的认识，决定去网上投一些简历，类似的网站有很多，选了拉勾网这个目前比较火的程序猿招聘网站，简单制作了自己的简历。投了几个薪水相对较高的公司职位（因为这样要求也会比较高），很快就收到了来自阿里巴巴聚划算的面试电话。从毕业后就没有面试过的我，面试时还是挺紧张的。 面试过程中的问题大概有这些： 介绍一下自己的工作，做过哪些项目。 协议的设计，优点等（不讲协议细节和实现）。 整个系统的架构，怎么处理大量用户量。 长连接处理，讲讲netty框架的链式处理。 假如要用netty传输一个10G的大文件，应该怎么做。 应急处理，如果服务器的负载突然很高，可能的原因，分析方法。例如一个8核的CPU，负载达到百分之五六十。CPU任务队列等问题。 springmvc用annotation设计方法参数校验。 说说http长链接。 说一下java中的NIO和AIO。 说说memcached和redis之间的区别。 说说redis内部的实现机制。 java的强引用，弱引用，幽灵引用之间的区别。 消息队列activemq的推拉机制。 脚本，web前端的使用。python怎么生成pyc文件。 看过哪些源码。 最后，你直接告诉我，你有没有跳槽的想法。 问题不多，但是有好几个没能说出来，回头再一想发现其实自己是知道的，这种感觉很不好。这应该就是平时缺乏积累总结的原因，没有形成系统的知识。感觉面试官人不错，还说了他的面试的目的，主要是：了解一下我做过的工作，工作中用到的知识，以及对这些知识的掌握程度。虽然我不准备跳槽，但是还是非常感谢他的这次面试，让我对问题有更多的认识。 整个面试过程的自我总结：自己的知识面已经挺广了，大部分java服务器开发会用到得知识都有涉及，但是对自己用到的内容掌握程度不够深入，有些东西仅限于使用和皮毛。还有对自己遇到过解决过的问题，没有及时总结归纳，导致面试的时候有的能想起来有的想不起来。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"面试","slug":"面试","permalink":"https://lchml.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Java执行外部程序的问题","slug":"java-exec-shell","date":"2014-12-18T16:00:00.000Z","updated":"2022-05-12T06:00:21.032Z","comments":true,"path":"technology/java-exec-shell/","link":"","permalink":"https://lchml.com/technology/java-exec-shell/","excerpt":"通过java调用shell脚本，其实是创建一个本地进程。","text":"通过java调用shell脚本，其实是创建一个本地进程。 Java.lang.Runtime.exec 方法和 Java.lang.ProcessBuilder.start 方法都可以创建一个本地的进程，然后返回代表这个进程的 Java.lang.Process 引用。 Runtimejava.lang.Runtime是一个本地运行环境类，其构造方法是私有的，只能通过getRuntime()来获取实例。Runtime的exec方法可以用来运行外部程序，如启动浏览器等。它有四种重载方式： public Process exec(String command); public Process exec(String[] cmdArray); public Process exec(String command, String[] envp); public Process exec(String[] cmdArray, String[] envp); 第三种就是第一种的基础上带上环境变量，同理，第四种是第二种带上环境变量。 如果我们要执行一个shell脚本，我们可以用第一种方法： 12String shell = &quot;/bin/bash /Users/lc/dosomething.sh param1 param2&quot;;Runtime.getRuntime().exec(shell); 如果需要得到脚本执行的输出结果： 123456Process process = Runtime.getRuntime().exec(shell);BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));String line;while ((line = reader.readLine()) != null) &#123; System.out.println(line);&#125; 脚本执行可能有问题，所以要输出错误信息： 1234BufferedReader readerErr = new BufferedReader(new InputStreamReader(process.getErrorStream()));while ((line = readerErr.readLine()) != null) &#123; System.out.println(line);&#125; waitFor可是在实际使用的时候发现有时候有结果输出，有时候却没有。这就是第一个时好时坏的原因：主程序会等待Process执行一段时间，但是时间很短，可能Process还没有执行完就结束了。所有就会发生时候时候坏的情况，为了避免这种情况的发生，我们需要调用Process的waitFor方法： 1234567Process process = Runtime.getRuntime().exec(shell);BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));String line;while ((line = reader.readLine()) != null) &#123; System.out.println(line);&#125;process.waitFor(); 该方法会让当前线程进入等待，直到Process中断或完成。waitFor方法还有一个int的返回值，0表示正常退出，其他值则表示执行异常。 close重新打包部署以后以为都好了，但是过了一段时间再去使用的时候发现又没有结果输出了。问题出在哪呢？在StackOverFlow上找了好久才找到问题，也就是第二个时好时坏的原因：如果Process有返回，那么必须要关闭process.getInputStream()，否则waitFor会一直等待。所以我们加上对应流的close，最后再次重新打包部署。 12345Process process = Runtime.getRuntime().exec(shell);// read InputStream and ErrorStreamreader.close();readerErr.close();process.waitFor(); exec !&#x3D; bash执行shell脚本的时候好像没问题了，但是如果执行西面的命令时，就会发生错误。 12String shell = &quot;ls -a &gt; all.txt&quot;;Runtime.getRuntime().exec(shell); 错误信息： 12&gt; ls: &gt;: No such file or directory&lt;br/&gt;ls: all.txt: No such file or directory 原因是命令不会被再次解析，重定向符号&gt;失效，这时候就需要用到exec的第二种重载方法： 12String[] cmd = &#123;&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls -a &gt; all.txt&quot;&#125;;Process process = Runtime.getRuntime().exec(cmd); ProcessBuilderProcessBuilder也可以用来执外部程序，它约等于Runtime.exec()方法的第一种重载方式，只是它的参数不能是String。而必须是String…或者ArrayList的形式。 12345678910ProcessBuilder pb = new ProcessBuilder(&quot;ls&quot;, &quot;-a&quot;);Process process = pb.redirectErrorStream(true).start();InputStream stdin = process.getInputStream();BufferedReader reader = new BufferedReader(new InputStreamReader(stdin));String line;while ((line = reader.readLine()) != null) &#123; System.out.println(line);&#125;reader.close()process.waitFor(); 从代码种可以看出，它相比Runtime有一个好处，就是可以把ErrorStream重定向到stdin，这样我们就只需要读一个输入流就可以了，没有错误时，读出返回的正常结果，有错误时读出返回的异常信息。 More更多关于Runtime.exec()可能发生的错误可以看下JavaWorld上的这篇文章When Runtime.exec() won’t","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"}]},{"title":"小问题也是大问题","slug":"log-server","date":"2014-12-13T16:00:00.000Z","updated":"2022-05-12T05:59:49.322Z","comments":true,"path":"technology/log-server/","link":"","permalink":"https://lchml.com/technology/log-server/","excerpt":"log-server是为服务器提供监控报警等功能的一个服务，由于上线前后有很多其他任务要完成，所以只能抽零碎时间先写了一个能跑起来的用着。一直想找个机会重构一下（程序员的洁癖），前段时间空了一些，所以专门抽时间重新写了一下。在过程中遇到不少问题，有些花了不少时间google，所以觉得有必要记录一下。备忘同时也算是分享吧。","text":"log-server是为服务器提供监控报警等功能的一个服务，由于上线前后有很多其他任务要完成，所以只能抽零碎时间先写了一个能跑起来的用着。一直想找个机会重构一下（程序员的洁癖），前段时间空了一些，所以专门抽时间重新写了一下。在过程中遇到不少问题，有些花了不少时间google，所以觉得有必要记录一下。备忘同时也算是分享吧。 SpringMVC容器问题一个基于SpringMVC的web应用，结构如下图所示。 启动时，需要将Mongodb中的配置信息加载到cache中，进行初始化。通常我们会实现ServletContextListener来做初始化的工作。由于初始化配置的逻辑是通过一个service来做的，所以在Listener中通过@Resource注入对应的Service。在web.xml中加入listener的配置，然后运行，会出现异常javax.naming.NameNotFoundException（如果通过@Autowired注入，则是java.lang.NullPointerException）。原因是一样的：listener中的Service注入失败了。 1234567public class InitListener implements ServletContextListener &#123; @Resource private InitService initService; // contextInitialized and contextDestroyed ...&#125; 无效的注入为什么会注入失败呢？原因很简单，因为我们实现的Listener本身并不是IOC容器中的bean，在非容器中的bean里通过注解的方式注入容器中的bean肯定是会失败的。怎么办呢？我们可以先获取到Spring容器的实例，再从容器中取出需要的bean（InitService已经通过@Service注解或xml配置文件注入到容器中）。 1234567@Override public void contextInitialized(ServletContextEvent event) &#123; WebApplicationContext springContext = WebApplicationContextUtils .getRequiredWebApplicationContext(event.getServletContext()); InitService initService = springContext.getBean(InitService.class); initService.test();&#125; 再运行一次程序，发现。。。还是不行！异常信息：java.lang.IllegalStateException: No WebApplicationContext found: no ContextLoaderListener registered?。 ContextLoaderListener使用SpringMVC时，我们通常会在web.xml配置DispatcherServlet初始化Spring的IOC容器，拦截*.do的请求给controller处理。 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;logserver&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/logserver-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;logserver&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 为什么在Listener中找不到WebApplicationContext呢？首先我们要搞清楚web程序启动时的初始化顺序：Listener &gt; Filter &gt; Servlet。找到Spring源码中的DispatcherServlet.java可以看到它最终是实现了HttpServlet。 123public class DispatcherServlet extends FrameworkServletpublic abstract class FrameworkServlet extends org.springframework.web.servlet.HttpServletBeanpublic abstract class HttpServletBean extends javax.servlet.http.HttpServlet implements org.springframework.core.env.EnvironmentCapable, org.springframework.context.EnvironmentAware 所以答案很明显，因为DispatcherServlet在Listener之后初始化，而Spring容器是通过DispatcherServlet是产生的，Listener中当然找不到WebApplicationContext了。 我们注意到异常的提示中还有一个信息：no ContextLoaderListener registered?，没有注册ContextLoaderListener。我们在源码中找到ContextLoaderListener.java。 12345678/** * Bootstrap listener to start up and shut down Spring&#x27;s root &#123;@link WebApplicationContext&#125;. * Simply delegates to &#123;@link ContextLoader&#125; as well as to &#123;@link ContextCleanupListener&#125;. * ... */public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123; ...&#125; 再想一下上面说的初始化顺序，很明显，我们应该用ContextLoaderListener来初始化Spring容器。在web.xml中加入如下配置。 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:/application-context.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 由于InitListener中需要用到Spring容器，所以要注意把ContextLoaderListener放在InitListener前面。再次运行程序，搞定了！等等，事情还没完。 运行成功以后看log发现，所有Task的Scheduled方法都重复执行了，也就是说所有task都被初始化了两次，猜测应该是每个Task被实例化了两次导致。 12345678910111213@Servicepublic class TestTask &#123; private static final Logger logger = LoggerFactory.getLogger(TestTask.class); public TestTask() &#123; logger.info(&quot;TestTask create&quot;); &#125; @Scheduled(fixedRate = 10000L) public void run() &#123; logger.info(&quot;TestTask run()&quot;); &#125;&#125; 运行发现，确实TestTask create了两次。为什么呢？因为ContextLoaderListener和DispatcherServlet都会根据xml配置初始化容器。而两个xml中都有下面的配置。 1234&lt;context:annotation-config/&gt;&lt;task:annotation-driven/&gt;&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;&lt;context:component-scan base-package=&quot;org.lic.logserver&quot;/&gt; 我们把logserver-servlet.xml中的scan目录改成只扫描controller所在的包。 1&lt;context:component-scan base-package=&quot;org.lic.logserver.controller&quot;/&gt; 而application-context.xml中排除controller包 123&lt;context:component-scan base-package=&quot;org.lic.logserver&quot;&gt; &lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;org.lic.logserver.controller&quot;/&gt;&lt;/context:component-scan&gt; 再次运行，发现Scheduled方法已经按希望的方式，每隔10s执行一次。 Spring-aop问题虽然Scheduled方法已经运行正确，但是通过log可以看到Task的构造方法确还是被执行了两次。这里应该感到很奇怪，为什么构造方法执行了两次，Scheduled方法却没有呢？ 1&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; 由于在spring的xml中配置了aop的动态代理，导致所有被织入了切面的类都会创建AOP代理。这会产生两次构造器调用，第一次是目标类的构造器调用，第二次是代理类的构造器调用。所以织入了AOP切面的目标类，不应在构造方法中做过多处理，以免因为两次调用带来其他影响。（关于AOP动态代理的问题，可以单独拿出来说一说） Fastjson的toJSONString问题四个常用的处理json的类库：Gson、Jackson、Fastjson、Json-lib。其中Fastjson由阿里巴巴公司开发，性能较为突出。由于在log-server中需要把收集的数据持久化到MongoDB，因此需要把JavaBean转成json存储。让所有需要持久化的Bean继承AbstractBean。 1234567public abstract class AbstractBean &#123; @Override public String toString() &#123; return JSON.toJSONString(this); &#125;&#125; 在使用过程中发现有一个Bean的其中一个属性没有被写到json中，对比了其它属性发现，只有一个不同点：这个属性没有对应的getter方法。给它加上getter方法后发现，果然可以了。问题虽然解决了，可是这只是猜想，下面我们就去求证一下。 首先去github上找到fastjson的源码clone一份，导入以后找到JSON.java中的toJSONString方法。 1234567891011121314151617181920public static final String toJSONString(Object object) &#123; return toJSONString(object, new SerializerFeature[0]);&#125;public static final String toJSONString(Object object, SerializerFeature... features) &#123; SerializeWriter out = new SerializeWriter(); try &#123; JSONSerializer serializer = new JSONSerializer(out); for (com.alibaba.fastjson.serializer.SerializerFeature feature : features) &#123; serializer.config(feature, true); &#125; serializer.write(object); return out.toString(); &#125; finally &#123; out.close(); &#125;&#125; 其中最重要的一句是serializer.write(object);，顺着往下找. 123456789101112131415public final void write(Object object) &#123; if (object == null) &#123; out.writeNull(); return; &#125; Class&lt;?&gt; clazz = object.getClass(); ObjectSerializer writer = getObjectWriter(clazz); try &#123; writer.write(this, object, null, null, 0); &#125; catch (IOException e) &#123; throw new JSONException(e.getMessage(), e); &#125;&#125; 这里最重要的一句是writer.write(this, object, null, null, 0);。ObjectSerializer是一个接口，getObjectWriter(clazz)会根据不同类型的Object返回对应的子类。我们找到对应的JavaBeanSerializer，其中的write方法就是最后我们要找的地方了，这个方法比较长就不贴出来了。从方法中可以看到我们的猜测是对，私有成员属性，必须要有对应的get方法才能被写入json中。总结：JaveBean中，所有getXXX方法都会被写入到json中（除了一些特殊的名字以外），所有的共有成员属性会被写到json中。私有成员属性不会，static类型属性不会。 文件读取乱码问题一般从文件中读取文本内容时，会用下面的方法。 1BufferedReader reader = new BufferedReader(new FileReader(new File(path))); 但是由于文件的编码格式的原因，读取中文时可能会出现乱码问题，可以改用下面的方法指定编码格式。 1BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(path)), &quot;utf-8&quot;));","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"}]},{"title":"点滴生活","slug":"some-advices","date":"2014-12-09T16:00:00.000Z","updated":"2022-05-12T06:10:07.118Z","comments":true,"path":"life/some-advices/","link":"","permalink":"https://lchml.com/life/some-advices/","excerpt":"我们坚持做一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。","text":"我们坚持做一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。 说话 事情没完全确认前，先不说，好比钱没到帐就不是你的，万一变数你会尴尬。 任何秘密，就地消化，到你为止。 说话别夸张，为了一时效果惊人，你要付出不靠谱的代价。 口无遮拦者都是只管自己说的爽，不管别人听的心情。 心情平静的方法 将最艰巨的任务放在早晨。 放开你不能控制的事情。 列出三件你喜爱的事情。 走向窗前望向窗外，深呼吸。 现在就试一试。","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"随想","slug":"随想","permalink":"https://lchml.com/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"相对论","slug":"theory-of-relativity","date":"2014-12-08T16:00:00.000Z","updated":"2022-05-12T05:57:02.931Z","comments":true,"path":"technology/theory-of-relativity/","link":"","permalink":"https://lchml.com/technology/theory-of-relativity/","excerpt":"一直以来对物理学都非常感兴趣，向往时间旅行之类的事情，中学时还买了《时间简史》和《果壳中的宇宙》来看，虽然现在已经记不得其中的大部分内容，但是里面对于引力扭曲时空和时间膨胀的论述一直让我记忆深刻，可能是因为当时这个观点彻底颠覆了我对这个世界的理解吧。","text":"一直以来对物理学都非常感兴趣，向往时间旅行之类的事情，中学时还买了《时间简史》和《果壳中的宇宙》来看，虽然现在已经记不得其中的大部分内容，但是里面对于引力扭曲时空和时间膨胀的论述一直让我记忆深刻，可能是因为当时这个观点彻底颠覆了我对这个世界的理解吧。 准备知识首先，我们需要知道几个科学名词。 证伪原则科学的表述在于其是可证伪的。通俗的讲就是，所有的科学定律都是可以被证伪的，但是又尚未被证伪的。 天下乌鸦都是黑色的。这是一条大家都知道的常识，但是这句话被证实了吗？显然没有，你发现了中国的乌鸦和外国的乌鸦都是黑色的，那你无法证明所有的乌鸦都是黑色的，就算你找到了全世界所有所有的乌鸦，那你还是没有证实这句话，因为你无法证明过去的乌鸦或者以后的乌鸦也会是全部黑色。“你TMD不是抬杠吗？”，我又一次被拍了。我没有抬杠，因为你确实没有拿出全部的事实去证实，咱搞科学要严谨。但是，现在可以大胆地立下一个预言：天下乌鸦就是黑色的。如果有一天你在非洲某一个角落发现了一只乌鸦，我不用看，它肯定是黑色的，屡试不爽。假如真有一天您真的发现了白色的乌鸦，好！那这条规律就被推翻了。也就是我们的科学规律，仅仅是现在正确罢了，以后谁知道（所以，怀疑精神很重要！！） 回到正统的物理学，当一个小球从你的眼前飞过，如果知道当前的速度和位置，那完全可以计算出它是怎么飞过来的以及以后将如何运动，几百年过去了，这个规律没有人怀疑。到了20世纪，当我们研究放眼到高速运动的物体或者开始研究粒子的时候，牛顿定律也就不再适用了。后面会讲到。 总结：科学道理不能用摆事实，讲道理去证明它。只能是针对现在的事实，总结出规律，提出一种预言，直到有一天它被推翻。所以数学和逻辑学便被划分为非科学的。原因在于它们并不需要经验去检验它们，他们被休谟称为必然真理。数学和逻辑学基于其体系起始的公理，而公理是否为真往往是不可证伪的，因而也是非科学的。同样，精神分析学说，占星说，骨相学，马克思之后的“马克思主义”也都是非科学的，因为它们都不可被证伪。 思维实验顾名思义，就是使用想像力去进行的实验。来看一个著名的思维实验： 伽利略：您说重的铁球比轻的先落地？亚里士多德：对的！伽利略：如果我把一个重的一个轻的绑在一起，那是不是整体质量超过了那个重的？并且这个整体会比单独的重的铁球先落地？亚里士多德：对！！伽利略：被绑在一起的那轻的铁球会比重的铁球速度慢，也就是会阻碍重的铁球。亚里士多德：对的！！伽利略：那速度会低于单独的重铁球，但是它俩的质量比单独的铁球重，不矛盾吗？亚里士多德：？？？我想想！！。。。其实相对论完全离不开爱因斯坦超级牛叉的大脑，思维实验。 经典物理学说到经典物理学，大家首先想到的肯定是牛顿。其实在牛顿之前还有一个伟大的人物，他为牛顿的成就打下了坚实的基础，他就是被誉为“现代自然科学之父”的意大利物理学家、数学家、天文学家伽利略。 伽利略定律回到前面说的思维实验，两个铁球同时落地，也就是说两个铁球降落的速度和他们的质量是无关的。这也就是伽利略的第一个广为人知的成就：自由落体定律，这个定律说的是如果不考虑空气阻力的话，那任何物体下降的速度都是一样的，且都是呈固定的加速度。 再来看另一个思维实验，如上图所示，一个足够光滑的U型的轨道，一个小球从左边放下去，它会滑到右边的最高处。如果把U型轨道的右边向下倾斜呢，小球还是会回到最高处。伽利略想到把右边的轨道继续往下倾斜，小球还是会继续向前滚，直到到达最高处，如果右边轨道一直向下倾斜，直到变成无限长的水平轨道，那小球就永远到不了最高点，所以小球就会一直这么滚下去。于是伽利略得出了第二个定律，也就是惯性定律，在一个完美光滑的表面运动的物体，会有一种保持这个运动的“惯性”，除非有外力阻止这个惯性。（这其实就是牛顿第一定律，只是伽利略的表达没有牛顿那么准确、优美，最高就把这个功劳归于了牛顿，所以说表达能力很重要啊。） 伽利略的相对性原理：在任何惯性系中，力学规律保持不变。这句话，您唯一不认识的估计就是这个惯性系了。该如何理解呢？ 假如A和B，A在陆地，B在匀速行驶的船上。我们可以说A是静止的，B是运动的吗？那显然是不行的。因为判断一个物体是静止还是运动，是需要一个参照物的。严谨的说，A相对于陆地是静止的，但是A相对于船来说就是运动的。B也一样，B相对与陆地是运动的，但是相对于船来说，就是静止的。所以，参照物很重要。B在匀速运动的船上，现在把船上所有的窗户关上，那这时候B知道他相对地面是静止的还是匀速运动的吗？那显然是不知道的。我们都坐过火车（想象一个非常完美，没有颠簸的火车），除非火车速度发生变化，否则我们是无法感知我们相对于地面是在动还是静止。那能通过实验来证明B的状态吗？这时候B从手中释放了一个小球，发现小球确实是垂直落了下来，然后B又用绳子将小球挂起来，发现绳子确实与水平线垂直。力学规律丝毫没有变化，所以伽利略就将匀速运动和静止状态统称为惯性系。试想如果此时船突然加速，那绳子必然将倾斜，力学规律就发生了变化，这也就是非惯性系了。大家一定要记得这个原理，因为相对论就是要从这里颠覆经典物理学的。 看到这里你肯定会想：“如此简单的规律，如果我活在那个时代多好，我肯定是个科学家”。 牛顿到底有多牛之前果壳网上看到过一篇著名的文章《牛逼顿的一生》。这里简述一下（再次感慨）： 牛顿是历史上最最伟大的炼金师，同时也是伟大的物理学家，天文学家，数学家，哲学家，神学家，而且对英国金本位制确实也起到了关键作用。物理方面：三大运动定律，质量守恒定律，能量守恒，动量守恒，万有引力。数学方面开创了微积分学科。天文方面反射式望远镜，光学色散和牛顿环。金融方面金本位制。哎，绝对是历史上绝无仅有的，跨越了这么多的学科，以后也不会有这样的全才，因为现在学科分的越来越细了。上述的一些概念，不再进行说明，顾名思义，也能猜出大概是什么意思，即使不懂这些，也无碍理解相对论。但是有一点是一定要说的，就是牛顿留下了震古烁今，彪炳千古的著作《自然哲学的数学原理》，牛顿的公式被后人重写过，但是这本书绝对是传世经典。讲什么的？讲的就是自然与数学之间的关系，一个小球从你眼前滑过，你可以利用数学预测出任何时间他的位置。用着《原理》可以计算日食，月食出现的时间，几乎可以做到分秒不差。还记得海王星是如何被发现的吗？在天王星被发现之后，科学家发现他的实际运行轨道和计算结果有偏离，科学家就大胆预言，在天王星的旁边应该还有一颗行星，正是这个行星影响了天王星的运动轨迹（牛顿的万有 引力定律，简单理解就是任何物体之间都存在引力）事实证明了这一点。也就是从这件事儿以后，再没有任何人怀疑牛顿，从此牛顿就是神，神就是牛顿，谁都不能怀疑！！牛顿一统江湖。现在还在感叹这本书的牛掰之处。随便总结个物理规律，写成数学公式，然后就开始折腾这些公式，咦，发现了一个新解，反过来实验，还真TMD有这种现象。所以有那句话，物理学家都是数学家。 牛顿的理论体系是建立在他的绝对时间和绝对空间的假设之上的，牛顿对时间和空间有着如下的理解： 绝对的、真正的和数学的时间自身在流逝着，而且由于其本性而在均匀地、与任何外界事物无关地流逝着。 绝对空间，就其本性而言，是与外界任何事物无关而永远是相同的和不动的。&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;——牛顿，《自然哲学的数学原理》 这就是牛顿的绝对时空观，不要看名字这么屌，其实这就是我们认识的理所当然的世界。但是您还是要仔细看一看，因为问题真的来了。当时牛顿已经把自己的理论推广到了整个宇宙，宇宙是稳定的。全人类，太阳，所有的恒星都在按照自己的方式和速度运动，无论无何运动，我们感受空间的方式是一样的，长宽高，而不管物体如何运动，只要测量准确，我们都可以得到相同的长宽高。同样，全宇宙都同样经历着时间的流逝，只要计算精确，我们可以计算出任何物体运动相关的时间。牛顿认为宇宙中充满了‘以太’这种物质，这种物质虽然没有对天体的运动产生阻力，但是它却是是客观存在的，我们的地球就是迎着这个‘以太’风来运动的，只需要时间来证明它就可以了。牛顿是神，我们都得信，我们后人的的任务就是想尽一切办法，来证明这个以太的存在。但是事实呢？科学家进行了无数次试验，最终都没有证明以太的存在，相反却恰恰无情地推翻了牛顿的绝对时空观，但是牛顿是神，肯定是实验的误差导致的。。。但是100多年过去了，还是毫无进展，物理学界也陷入了前所未有的恐慌当中。。。 说到这里，你会觉得这个世界还是你认识的那个天经地义的世界，没什么特别的，但是接下来，将慢慢颠覆你的常识，挑战你的思维底线。 光速测量毋庸置疑，对光速的思考，是爱因斯坦提出相对论的重要根基之一。 接近真相刚开始科学家认为光速是无限大的，每天早晨我们打开窗户的一瞬间，屋子就被照亮了，我们从来没有看到过屋子的一部分先被照亮，另一部分再被照亮。对光速产生怀疑的第一人：伽利略。他用测量声速的方法来测量光速： 两个人各自提一个带有遮光板的灯，站在距离1.6千米的山顶，伽利略先打开灯，同时摁下计时器，对面的人看到光的同时也打开灯，伽利略看到反回来的光之后再次摁下计时器。在这个时间差，光走了往返的距离，虽然误差比较大，但是伽利略的方法是对的，但是最终实验失败了，因为光速实在是太大的。我们现代人都知道光速是30万公里每秒，一秒绕地球7圈，一秒走的距离让最快的阿波罗飞船也要跑4天。 30年后，光速的测量首先在天文学上获得了成功，丹麦天文学家罗默通过观测天体的运动，首先测量出了光速大概是22.5W公里&#x2F;秒，测量方法。又过了170年，1849年，法国物理学家索菲，也就是物理课本上讲的旋转轮齿法。 一束光穿过齿轮的缝隙，会被前面的镜子反射回来，如果现在齿轮开始缓慢旋转，由于光速极快，在缝隙中穿过去之后，依然能够从同一个缝隙反射回来。那现在开始加速齿轮旋转的速度，一直加速到反射回来的光恰好被齿轮挡住了，没有从缝隙中反射回来。这时，光走过的距离是可以测量的，并且时间可以从齿轮的旋转频率计算出来，进而可以得到光的速度，是31.5万千米/秒，这个离真相只有咫尺之遥了。 惊人发现时间又过了30年，1873年，英国科学家麦克斯韦（有观点认为，他对物理学的发展做出的贡献仅次于艾萨克·牛顿和阿尔伯特·爱因斯坦）发表了可以和牛顿《自然哲学的数学原理》比肩的《论电和磁》，出版之后并没有得到太多的认同，因为论述的电和磁都是虚无缥缈的东西，无法像小球那样做实验验证。麦克斯韦认为电和磁是同一种物质的不同的表现形式，他们的性质和相互作用被麦克斯韦用简洁优美的方程组描述：麦克斯韦方程组。该方程组绝对是数学美的典范，无数科学家被他的美所震撼，仅从他完美的表现形式，他就不可能是错误的（历史也证明了这一点，所有经典物理学的公式都被相对论修改过，但是唯独麦克斯韦方程组，少一笔不行，多一笔又显得多余）。 根据这个方程组，麦克斯韦预言了电磁波的存在，但是伟大的天才只活到了48岁，没有亲眼看到电磁波的诞生。没过几年，德国青年物理学家赫兹在实验室的发现，震惊了全世界，全世界物理学家都开始忙碌起来，最终证明麦克斯韦的电磁理论全部正确。赫兹测出了电磁波的频率和波长，相乘就是电磁波的传播速度了，计算的结果是31.5万千米/秒，一个惊人的速度。 等等，稍等一下，这个数字怎么这么熟悉，天啊！！竟然和光速一样。这是巧合还是必然？怎么会有这么巧的事情。难道光是一种电磁波？？这个发现让全世界的科学家兴奋不已，各种实验接踵而至，实验表明光确实和电磁波表现出了相同的性质，最后一致认同，光就是一种电磁波。 物极必反波的传播速度是传播介质的波长乘以频率，也就是由介质所决定。当一个石子投进水里，在这个涟漪产生的瞬间，水波的传播也就和石子没有了任何关系，水波会相对于水（介质）传播出去，所以谈到水波的速度，隐含的参考系是水，而不是石子。再说光，光速的参考系也不是你的手电筒，在手电筒发出光线的一瞬间，光的传播已经和手电筒没有了任何关系，决定它速度的是介质。众所周知，光可以在真空中传播，遥远的星光穿过空无一物的宇宙空间，到达地球，那这个参考系、这个传播介质是什么呢？ 还记得前面说到的牛顿的绝对时空观吗？一个叫‘以太’的物质一直没有被证实。既然知道了光在以太中的传播速度，那光速就是成了证明‘以太’存在的最佳证人。我们的地球高速围绕太阳公转，可以设想一下：假设地球公转速度是v（忽略自转的影响），光速为c，我们迎着这个‘以太风’，发射一个光线，那我们观测到的光的传播速度应该是c-v，因为光在往前跑，我们也同样在往前跑。背着‘以太风’发射一个光线，那我们观测到的光的传播速度应该是c+v，因为我们和光的方向相背。只要证明了这一点，那‘以太’这种物质就是存在的。那经典物理学的大厦就正式宣布建造完成了。 世上最最成功的失败实验，迈克尔逊莫雷实验，这个实验确实想证明以太的存在，但是无论实验精确到什么程度，实验结果都证明’以太’是不存在的，光的速度没有受到任何影响。理论错了？不可能，科学家不愿意相信，因为牛顿的绝对时空观和以太学说看上去是那么完美。然后开始出现了各种各样的解释，一切的解释都是建立在牛顿的绝对时空观的基础之上。特别是以韦伯（爱因斯坦的物理老师）为首的科学家，他们相信，只要再多做一些实验，最终的胜利依然属于牛顿。风起云涌，这股热潮从19世纪刮到了20世纪，但是极少有人站出来质疑理论的根基是否出了问题。好，欢迎主角登场吧！！ 经典物理学革命 动力学理论认为热和光都是运动的方式，现在这一理论的优美和明晰，正被两朵乌云笼罩着。&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;——开尔文勋爵，《在热和光动力理论上空的十九世纪乌云》 开尔文所说的两朵乌云一朵是指黑体辐射理论出现的问题（量子力学），而另一个就是上面所说的迈克耳孙-莫雷实验测量的零结果。 狭义相对论主角登场-人类文明的彻底洗礼爱因斯坦，22岁，瑞士人，苏黎世联邦工业大学物理系本科毕业，取得数学和物理双本科学位，不爱写作业，爱思考，没有经过亲自验证的理论不会轻易承认，敢于质疑权威，导致和老师关系都不好，毕业后想留校当助教，申请过多次，都被拒绝，甚至有些就没有回信。毕业之后8个月没有稳定工作，不顾母亲反对，和自己喜欢的女孩在一起，为解决生计，当过高中代课数学老师，1902年在瑞士的一家专利局找到一份工作，职称为“三级技术员”，无任何成就。（未婚就把女友的肚子搞大，这个算成就吗） 主角终于登场，不过简历真心寒碜，在教授、博导多如牛毛的欧洲物理学界，真为他感到担忧。不过专利局的工作给了他充裕的思考时间，经常满桌子都是数学草稿，左手抱孩子，右手写字。但是这个年轻人超强的思维能力和推理能力绝对让你不寒而栗，当你理解他的时候，你会感到兴奋不已，数秒的思考之后，你会感到无比恐慌。 绝对光速你以接近光速（假设）和一束光同时离开地球向宇宙进发，地球上的人看到你和光几乎齐头并进，这一点毋庸置疑。那你看到的也是相对静止，齐头并进？绝不可能，你看到的必然是这束光以光速离你而去。光是一种电磁波，从麦克斯韦方程组可以得知，震荡的电场产生震荡的磁场，震荡的磁场再次产生震荡的电场，如此循环下去，就形成了电磁波。就像是一个队列的人报数一样，1，2，3。。。传播的速度取决于报数的频率。火车从A移动到B，是这个实体在移动，电磁波不同，波的传播依靠的是介质，而介质并没有向前移动。例如水波，肉眼看到的是水波在扩散没错，但是单独的每一滴水，它仅仅是在上下震荡，水并没有向前移动。电磁波的传播可以理解为报数的话，那电磁波的速度就取决于报数人反应速度了，真空这个介质就充当于报数人的角色。 伟大的麦克斯韦方程组，已经证明了，电磁波的传播速度与波源的运动速度无关。试想我们将一个石子扔入湖中，不管我们是垂直仍还是斜着扔，水波的传播速度是不变的。 思维实验： 我一个人在黑漆漆的宇宙，因为身边没有参照物，所以不管以高速飞行还是静止不动，我都是完全不知道的。假如现在我的速度提升到接近光速（我依然不知道，因为没有任何参照物），这时候如果我发出一束光，我将看到什么？一个和我保持相对静止的光？一个震荡的电磁场，却没有感应下去？这不可能，根据伟大的麦克斯韦方程组，光速和光源是没有关系的，而且介质没有变，我看到的应该还是光速（而且我真心不知道我当时的速度），我看到的应该还是交替震荡下去的电场和磁场。再次想象一下队列报数，这个报数的反应速度在地面上和在火车上不一样吗？显然很荒谬。不管在哪，这个报数的反应速度绝对不会变的。再次强调一下，物体往前走是这个实体真的移动了，但是波的介质没有移动，只是依次传递下去。众所周知，我们地球人测量出了光速c，那测量的时候是在绝对静止的条件下吗？显然不是，我们的地球在不停地自转公转的呦！！再次回到迈克尔逊莫雷实验实验，它不就是证明了光速不变吗？这个实验犯了一个致命的错误，他先假设以太是存在的，结果证明了以太确实不存在，显然很矛盾，只是当时科学家真的不敢怀疑牛顿。 小爱同学在纸上写下：对于任何参考系来说，在真空中光的传播速度恒为c。 爱因斯坦对经典物理学的第一次困惑小爱已经确定，光速恒为C，假设你在空无一物的宇宙中，那你能通过测量光速来，确定自己是静止的还是匀速运动的呢？显然不会，因为光速始终不变。小爱并没有停止他的思考，小爱认为，应该是在惯性系中，一切物理规律保持不变才对。试想，如果在不同的惯性系（匀速或静止）中，物理规律发生了变化，那科学家早早地就可以在实验室测出地球的公转速度了，而且不仅力学实验不变，热学，光学，电磁学都应该不会发生变化。小爱对于现在的成就很满意，但是马上又困惑起来：“光速恒定看起来是如此地简洁，严谨，美妙。根据经典的速度合成公式，如果火车的速度是v，一个小鸟在火车中以速度w飞行，那站在地面上的人看到小鸟的速度应该是v+w，这点没错，如果火车上有一个人打出一束光，那站在地面上的人看到的光的速度应该是c+v？这又和自己的光速恒定很矛盾，经典物理学在过去的几百年中在各个领域取得了非常大的成就，但是我的推理也是分毫不差，该相信谁？难道这个世界有高速低速之分？”想着想着，小爱睡着了，做了一个非常美妙的梦。。。 高速列车杀人事件，摄像机的记录更让人困惑。背景：A和B同时爱上了一个女人，两人决定来一次公平的决战，在高速列车（0.5倍的光速）的同一个车厢，车厢中间有一盏灯，两人站在车厢的两边，灯会在1分钟之后自动打开，当两人看到灯光的时候，就向对方开枪。 结果A被干掉了，B手臂受了重伤。警方（小爱）来到了现场，了解情况之后，警方说：“如果你能提供证据证明你们是公平决斗的，那你将无罪。” 就在车厢中间有一台高速摄像机，记录了整个过程（如下图），观看完录像，警方说：从录像中看到，光同时到达你们，而且你们是看到光之后才开枪的，你无罪。就在警方上车，准备离开现场的时候，后面有个人追了上来，大声喊：“不是这样的，这一切都是B精心设计的阴谋。我是站台的管理员，枪击发生的时候，列车正好经过我们站，站台的摄像机也同样记录了发生的一切，警官，一块儿看一下录像吧。” 录像显示：列车在高速行驶，B面对的方向正好是列车行驶的方向，光线确实是先到达B，也就是B在遵守规则的情况下，看到光后开了枪（如下图）。看到眼前的一切，小爱童鞋大脑一片空白。这关键时刻掉链子岂不是很没面子，小爱果断开启外挂模式：“两台摄像机都没有任何问题，光速与光源的运动无关，从这两个事实来看，时间是相对的，对于站台上的人和高速列车上的人来说，没有真正的同时，任何所谓同时发生的事情，都只能是对同一个惯性系中的人才成立”。 彻底抛弃绝对时间观念继续回到一起举过的例子，你坐在宇宙飞船中以接近光速和一束光同时向宇宙进发，地面上的人看到是你与光几乎不分前后地离他而去，光只比你快一点点。你看到的是这束光以光速C离你而去，如果你对这个依然百思不得其解的话，只能说明绝对时间观念在你脑海中根深蒂固。如果你能感受到你的时间和地面上的人的时间是不同的，你过了1秒，地球上已经过了1个小时。对你来说，1秒钟内，那束光跑的很远很远了，但是在地球上的人看到的是这束光用了1个小时才拉开与你的距离。这些解释貌似合情合理，但是却无法用实验去验证，全靠意淫是不行的，下面不得不呈现支撑这个逻辑的理论基础了—思维实验+数学。 时间膨胀我们该如何描绘时间变慢呢？注意，这里不是你的劳力士走得慢了，是时光的流逝，流的慢。我们用一个光子钟来衡量时间，因为光速太快，所以我们假设光子往返10亿次是过了1秒钟。这时候A拿着光子钟站在地面，B拿着光子钟坐在高速飞行的宇宙飞船上。从图上可以看到，B的光子钟要想滴答一次，光子走过了更多的距离。由于光速是恒定不变的，A的光子钟震荡10亿次，B的光子钟是斜着走的，没有震荡10亿次，假设是5亿次。那A过了1秒，B的时间只过了0.5秒。换个角度说，就是B的光子滴答这一下用的时间更长了。推导一下公式：根据毕达哥拉斯定理（勾股定理），可以推导出速度与时间的关系： $$(ct′)^2+(vt)^2&#x3D;(ct)^2$$ $$c^2t′^2+v^2t^2&#x3D;c^2t^2$$ $$c^2t′^2&#x3D;c^2t^2−v^2t^2$$ $$t′^2&#x3D;\\frac{c^2t^2−v^2t^2}{c^2}$$ $$t′^2&#x3D;(1-\\frac{v^2}{v^2})t^2$$ $$t′&#x3D;t\\sqrt{1-\\frac{v^2}{c^2}}$$ 这个公式推导比较简单，简要说明一下含义：c是光速，当我们的速度v很小的时候，比如火车60米&#x2F;秒，那么$$\\sqrt{1-\\frac{v^2}{c^2}}$$的值是0.999999983，非常接近1，等式几乎成立，你坐火车100年，下来之后之比陆地上的人年轻53.6秒，也就是坐火车和静止在地面上的人的时间快慢非常接近。我们的登月飞船的速度是10500米&#x2F;秒，已经够快了吧，那这个值仅仅是0.999387312，和陆地上的时间还是非常接近，也就是在飞船上飞100年下来，你也仅仅年轻了22天左右。如果v很大，是0.99c，那这个值就是0.004，你的一年相当于地球上的250年。速度越接近光速，这个公式体现出的时间膨胀越明显。如果超过光速呢？这个值就是虚数，没有意义（到底有没有意义？难道可以穿越时空？） 畅想一下你长生不老的场景吧：假如你坐上了0.99c的宇宙飞船，一年之后飞回来，地球上已经过了250年。但是你真的是仅仅过了一年，绝不是你体验了250年的精彩生活仅老了一岁。你一天也没有多过，并且每天都是24小时。如果地球的人能时时刻刻看到你的话，地球人撒尿用2分钟，因为你的时间过的很慢，地球人看你撒一次尿用了将近一天的时间。但是，当你回到地球的时候，地球真的已经过了250年，你来到了将来。 这里谈论的时间变慢了，不是你的劳力士不准确了，是时间本身变慢了，与时间有关的一切都变慢了——时间膨胀了。有个更好的理解方法：你把时间想象成一个实体，刚开始从起点到终点是100米，时间膨胀之后，同样的时间，起点到终点变成了500米。 空间收缩爱因斯坦没有停下他的脚步，继续推导公式(L代表长度)： $$L&#x3D;L′\\sqrt{1-\\frac{v^2}{c^2}}$$ 和没有绝对的时间是一样的，也没有绝对的空间，表现出速度越大，长度会收缩。牛顿这时候活着的话，肯定疯了。我们所说的收缩是相对与另一个空间的收缩效应，地球上的人看飞船上的人，确实变小了，但是飞船上的人拿尺子测量发现自己没有变小，那是因为尺子也变小了。跑步的人相对于静止来说也变小了，不过根据上一节的计算，缩小的量真是微乎其微。如果是高速运动的物体，那收缩的就相当明显了。 新的速度合成在经典物理学里面，我们学习过速度合成。火车相对地面的速度是v，如果人在火车上以v’同样向前行动，那地面上的人看到火车上的人的速度应该是v+v’，但是在爱因斯坦的相对论里面，由于火车的行驶，导致火车的时间膨胀和空间收缩。地面上的人看到的合成速度应该是什么呢？ $$w&#x3D;\\frac{u+v}{1+\\frac{uv}{c^2}}$$ 可以看出，当u和v相对于光速无限小的时候，这个等式几乎和经典的速度合成公式是一样的 $$w&#x3D;u+v$$ 质量和速度，牛顿真的要疯了在经典物理学里面，我们研究一切运动的基础就是质量守恒。不管小球如何运动，小球的质量是不会变的。现在摆在爱因斯坦面前的是动量守恒定律： $$m_0v_0&#x3D;m_1v_1+m_2v_2$$ 根据洛伦兹变化是和动量守恒定律，爱因斯坦推算出了质量和速度的关系： $$m&#x3D;\\frac{m_0}{\\sqrt{1−\\frac{v^2}{c^2}}}$$ 速度越大的物体，他的质量会变得越大。牛顿如果真的在天有灵的话，看到爱因斯坦这一切举动，是不是要疯掉？ 光速的极限爱因斯坦认为，任何信息或能量的传递都无法超越光速。思维实验：有一个力作用在小球上使它加速，根据前面的推导，速度越大小球的质量就会变得越大，这时候就需要用更大的力才能保持住一定的加速度，当加速到无限接近光速的时候，这个小球的质量也就会变得无限大，这时虽然用较小的力依然能让它加速，但是由于质量非常大了，加速度几乎可以忽略，为了让这个质量无穷大的小球继续朝光速进发，必须用无穷大的力，但是无穷大的力是不存在的。以上是在数学上展现的特性。就不列举公式了，多一个公式，少5%的读者。（在量子物理学，光速极限到底有没有被推翻呢？推荐《上帝会掷骰子吗？》曹天元，相当棒的一本关于量子的书）地球围绕太阳公转，是因为太阳和地球之间存在引力，想象一下，如果太阳突然消失，会发生什么？地球会突然被甩得很远？不，爱因斯坦认为，这个信息的传递不会超越光速，地球会在8分钟后被甩开。 著名的质能方程看到这个名词，大家肯定觉得无比亲切。这就是大部分人对相对论的初步认识。质量为m小球以速度v向前运动，那他拥有的动能是 $$\\frac{1}{2}mv^2$$ 爱因斯坦结合相对论理论，对这个公式进行推导（查阅了各种资料，真心看不懂怎么推导出来的，貌似用到了“无穷级数展开”的数学知识），结果出现了如此简洁美妙的质量和能量转换的方程： $$E&#x3D;mc^2$$ 记得高中老师讲过：一克的木炭，质量完全转化成能量，可以让一个100瓦的灯泡亮100万年。有些人该说我脑残了，一斤的木炭燃烧完全后，连顿饭都做不熟。对，没错，您说的燃烧，是化学反应，只是碳结合氧气转化成了二氧化碳而已，整个过程质量完全没有减少，碳的质量只是转移到了二氧化碳当中。这个质能方程说明的是质量真的少了，少的质量转化成了能量。这个方程解释了放射性元素为什么会释放如此大的能量。 双生子佯谬看了上面的内容，您也许感觉狭义相对论还是比较好理解的，没想象的那么难，看看下面的问题吧，相信你再次怀疑了自己的智商。来看一个经典的思维实验双生子佯谬。 想象一下，你即将坐上一艘亚光速飞船告别地球上的双胞胎弟弟去太空旅行，当你弟弟看到你的飞船瞬间冲上云霄，一下子就飞得不见踪影时，他在心里想，等哥哥回来的时候，我就比他老了，哥哥会比我显得更年轻。可是，你在飞船上可不一定这么想，在你的感觉来说，你觉得是地球载着你的弟弟突然飞离你而去了，你越想越觉得有道理，不一会儿，你就感慨到：“等我再见到弟弟的时候，我就更老了。”亲爱的读者，你觉得他们见面的时候，到底是谁变得更年轻？ 要想知道答案，还得再坚持会儿。。。 广义相对论广义相对论和狭义相对论只有一字之差，却是人类认识宇宙的一大步，意义无法估量。如果没有爱因斯坦，狭义相对论也会在5年之内由别人提出，包括庞加莱，洛伦兹，还有爱因斯坦的导师，闵科夫斯基，他们对狭义相对论已经有了初步的思考和成果，但是如果没有爱因斯坦，人类对宇宙的真正认识还不知道要推迟多少年，绝对是独门绝技。 等效原理爱因斯坦有一点很不满，那就是为什么物理规律不变的前提是惯性系呢？上帝在创造这个宇宙的时候，把惯性系摆在了如此重要的地位吗？上帝应该创造一个普世的规律才对。况且，我们所说的惯性系真的存在吗？我们经常说静止或者匀速状态为惯性系，但是我们的地球却在公转自转，绝对的惯性系是不存在的。又是爱因斯坦的思维实验： 假设你在一个密闭的电梯里睡着了，当你醒来的时候，发现你漂浮在电梯当中。那你能知道你是在自由落体运动还是漂浮在太空中？显然不知道。假如你醒来之后发现你站在电梯里，电梯对你有支撑，你对电梯有压力，那你能分辨你是在地球上，还是这个电梯在太空中推着你做加速运动？显然还是不能。反过来说：你现在站在地球上，受到了地球的引力。想在太空中感受到同样的感觉该怎么做？对，只要有一个作用在你身上产生大小为g的加速度的力就可以了。爱因斯坦的结论是引力和加速度等效。 万物的规律终于得到了统一，狭义相对论提到：在惯性系中，一切物理规律不变，在非惯性系当中呢？只要我们将这个变速的参考系，等效为一个引力场就可以了。非惯性系就是惯性系加一个引力场。看似不起眼的思维转变，能得出什么样的惊人推论呢？ 引力造成时空弯曲试想，在自由落体的电梯当中，你向正前方抛出一个小球，那你看到的这个小球必然是直线运动，但是地面上的人看到的是这个小球做抛物线运动。试想，你站在电梯中，向前打出一束光，这光线必然是直的，地面上的人看到的也是直的。假如电梯自由落体降落，如果你看到的光线是直的，那地面上看到的光线必然是弯曲的。当然，光速太快了，我们无法感受到光线的弯曲而已，但是我们真的可以相信光线真的弯曲了，只是弯曲的程度太小了。 根据上面的两个例子，小球和光线都有向下的加速度，加速度和引力又是等效的，那我们可不可以这样理解：引力使光线弯曲了？地球的引力弯曲了光线？好大胆的想法！！狭义相对论提到过，运动的物体，时间会膨胀（也就是时间会变慢）。引力可以使一个静止的小球运动起来，结论是引力会让时间膨胀，这么说会不会更深刻呢？ 我们把上述现象称之为“广义相对论的时空弯曲效应”。 双生子佯谬的结果似乎与狭义相对论矛盾：双生兄弟中的每一个人都认为对方相对于自己运动，因此由于时间膨胀的作用，每一个人都认为对方应该比自己年轻。狭义相对论指出所有观测者都有同等意义，没有任何一个参考系（frame of reference）是会获得优待的。因此旅行者会预期回到地球后会看见比他更年轻的双生兄弟，但这就与他兄弟的想法恰好相反。但实际上旅行者的期望是错误的：狭义相对论并没有说所有观测者都有同等意义，而是只有在惯性系中的观测者（即没有进行加速运动的观测者）才有同等的意义。但宇宙飞船在旅途中亳无疑问是至少加速过一次的，所以旅行者并不是惯性系。反之，留在地球上的兄弟在整个航程中都是在惯性系之中（如果忽略源自地球质量及移动所带来的相对较小的加速度），所以他能够把他跟他兄弟分辨开来。有些人在解决这吊诡时会认为狭义相对论并不能够用于加速中的物体，而只可使用广义相对论，这是不正确的。举个例说，该对双生兄弟的年龄是可以借着求时空间隔（spacetime interval）在他们任何一个惯性系中所行走的时空路径（这些路径被称为世界线）上的积分来准确地计算出来的。近似的方法可以用来计算一加速中的宇宙飞船的相对性行为。狭义相对论唯一不适用的情况是当重力的影响是不能被忽略的时候，这时就真的需要用到广义相对论。这个结果是由狭义相对论所推测出的（移动时钟的时间膨胀现象），而且能够透过实验来验证。 超级无敌星光实验，为爱因斯坦正名我们对爱因斯坦已经崇拜地五体投地了。但是在当时群星璀璨的欧洲物理学界，并没有得到普遍的认可，思维实验和数学推理确实无懈可击，但是这些都没有得到实验验证，特别是诺贝尔奖的评委会更是反对相对论学说。如何验证引力可以使光线弯曲呢？如上图，Z为恒星，在位置A能观测到恒星Z，那在位置B依然可以观测到Z出现在相同的位置，只是距离远了，但是角度不会有任何偏差。这时太阳处在位置B和恒星Z之间，如果真的如爱因斯坦所说，引力可以使光纤弯曲，那在B观测Z恒星的位置会发生变化。事实比想象中残酷，您已经看出问题来了，在位置B的时候，是白天，火红的太阳当头照，根本无法看到天上的星星。爱因斯坦：可以，日全食的时候！！ 1919年一支英国科学考察队远征西非，在日食期间观察到天空中太阳附近一颗恒星位置的微小移动。这证实了爱因斯坦的论断，恒星发出的光线经过太阳时，被引力弯曲了。爱因斯坦红遍全世界，一战成名。要知道这时候爱因斯坦依然没有获得诺贝尔物理学奖，因为评委会真的不懂相对论（那个年代懂相对论的人真的没几个），但是爱因斯坦又如此推崇备至，评委会想办法给自己一个台阶，在1921年爱因斯坦由于光电效应的研究，获得了诺贝尔物理学奖。 引力的本质这才是广义相对论研究的核心问题。引力到底是什么？牛顿认为引力就是一个看不见的线。例如地球绕着太阳转，一旦太阳消失，这个线会立刻断开，地球会立刻被甩出去。狭义相对论证明，没有任何信号传递是超过光速的，地球应该在8分钟后被甩出去。引力不是看不见的线，那引力到底是什么？ 在前面的推理中我们知道，引力可以使时空弯曲。试想，在一个未被弯曲的时空里面，向前投出一个小球，那小球必然会匀速直线运动，运动轨迹不会有弧线。在一个被弯曲的时空里面，抛出一个小球，小球就不会匀速直线运动，而是顺应着这个弯曲的时空前进。假设一个篮球是一个被弯曲的时空，一个蚂蚁想从该时空的一个点移动到另外一个点，即使走的是最短的距离，那走的也是一个弧线。爱因斯坦认为引力并不是引起小球曲线运动的根本原因，根本原因应该是时空弯曲，弯曲的时空决定了小球的运动轨迹，引力只是一种表象。想象一下，如果一个篮球放在一个网上，靠近篮球的网就会凹陷下去，当一个小的玻璃球从小球旁边划过时，会受到凹陷部分的影响，进而改变运动的方向。把空间想象成一个个的大网，地球放在网上，一颗流星如果速度很快，就会划过天际，掠过地球而去，如果流星速度不够快，那就会陷入那个凹陷部分，降落在地球上。 黑洞我们已经承认了，引力可以弯曲时空，那什么产生的引力呢？是质量。质量越大，引力就会越大，造成的时空弯曲也就最厉害。把宇宙当成一个网（参考上图），上面的星球质量越大，体积越小则陷得越深，如果有一颗小行星分别从他们旁边划过，肯定最后面的那个是最难划过的。任何一个星球如果质量保持不变，体积不断缩小，那都会有这种越陷越深的趋势，所以任何星球他的质量和体积都有那样的临界值。如果体积小到一定程度就会发生上图的这种现象。这就是黑洞了，任何行星经过它的边界，都无法穿过它，包括光，都会陷进去，也就是黑洞会将一切进入它边界的行星吸收掉。 虫洞爱因斯坦和罗森塔尔在推演广义相对论的公式过程中出现了一种解，如下图说存在这种连接，连着着宇宙中的相隔非常非常远的两个区域。两个黑洞的连接可以组成一个虫洞了。《星际穿越》中的虫洞就是这个。这个虫洞不但可以突然让你穿越几百光年的距离出现在另一个地方，也可以让你从一个时间穿越到另一个时间。不仅是从现在到将来，还可以从现在到过去。所以虫洞也就成了现代科幻小说和科幻电影常用的一个标准。通过黑洞可以达到时间旅行的效果，那黑洞里面都有什么呢？霍金说：所谓黑洞，就是一切你无法了解的事件真相的集合。晕倒，他直接说不知道不得了。不过想想也知道，那么多的宇宙射线都被黑洞吸进去了，一旦进去，差不多也必死无疑吧。 是什么吓到了爱因斯坦爱因斯坦在推导他的广义相对论公式时发现了他自己都无法相信的结论：宇宙不可能是稳定的，要么膨胀要么收缩。这让爱因斯坦惶恐不安，他抬头仰望星空，在有历史记录以来，星空都是同样的景象。爱因斯坦真的无法接受这个理论，然后他就在公式中假设了一个常量，等着以后去证明这个值（物理研究的一种手法，先假设有这个值，然后根据结果返回来验证这个值），爱因斯坦常出了一口气，又一次被自己的聪明折服了，这下宇宙稳定了，洗洗睡觉。真相总会呈现。哈勃发现了距离地球几十万光年的仙女星系，我们的宇宙真的比想象中大很多。更重要的是我们所看到的所有星系都在离我们远去，而且距离越远的星系，跑得越快。我们的宇宙正在膨胀，而且是加速膨胀。爱因斯坦看到哈勃的成果之后追悔莫及，当初怎能偷懒画蛇添足？但是这却反过来证明了广义相对论的伟大。不要停下来，既然宇宙是膨胀的，那是不是宇宙有一个诞生的时刻，宇宙先从一个点开始，然后突然爆炸出来呢？这就是宇宙大爆炸。 著名的思维实验，有兴趣可以看看，开开脑洞。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"物理学","slug":"物理学","permalink":"https://lchml.com/tags/%E7%89%A9%E7%90%86%E5%AD%A6/"},{"name":"相对论","slug":"相对论","permalink":"https://lchml.com/tags/%E7%9B%B8%E5%AF%B9%E8%AE%BA/"}]},{"title":"Shell常用命令","slug":"shell-commands","date":"2014-12-04T16:00:00.000Z","updated":"2022-05-12T05:57:59.739Z","comments":true,"path":"technology/shell-commands/","link":"","permalink":"https://lchml.com/technology/shell-commands/","excerpt":"Shell是Unix操作系统下传统的用户和计算机的交互界面，也是控制系统的脚本语言。对于程序员来说，熟悉shell的使用是一门基本功，但有时又像一门暗器（快狠准），在这里记录一些平时工作生活中用到过的命令，温故知新，就算忘了也有个地方可以快速查询。如果没有，没关系，几乎所有命令都可以通过command --help来查看用法。","text":"Shell是Unix操作系统下传统的用户和计算机的交互界面，也是控制系统的脚本语言。对于程序员来说，熟悉shell的使用是一门基本功，但有时又像一门暗器（快狠准），在这里记录一些平时工作生活中用到过的命令，温故知新，就算忘了也有个地方可以快速查询。如果没有，没关系，几乎所有命令都可以通过command --help来查看用法。 lsof查看8080端口被哪个进程占用 lsof -i:8080 123$ lsof -i:8080COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 30712 lc 31u IPv6 999925 0t0 TCP *:http-alt (LISTEN) vi:%s将文件中所有的字符串aaaa替换成bbbb，vi命令：:%s/aaaa/bbbb/g awkawk在对数据分析并生成报告时尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。基本语法 awk &#39;&#123;pattern + action&#125;&#39; &#123;filenames&#125; 尽管操作可能会很复杂，但语法总是这样。几种常用示例： 以;为分隔符，输出第4列大于0的行。$n表示第n列，n&#x3D;0表示一整行。 1$ awk -F &#x27;;&#x27; &#x27;$4&gt;0&#x27; test.dat 以;为分隔符，所有第4列大于0的值的和。 1$ cat test.dat|awk -F &#x27;;&#x27; &#x27;&#123;if($4&lt;0)sum+=$4&#125; END &#123;print sum&#125;&#x27; split用于把文件分割成多份，使用起来很简单：split [-bl] file [prefix]。 -b 表示对文件按大小进行切分。 -c 表示对文件按行数进行切分。 prefix 用于指定切分后的文件名前缀，可以不写，默认为xaa、xab、xac … 如原文件all.dat的大小为1.2M，共12801行。用-b进行切分： 12345$split -b 600k all.dat$ls -lh1.2M all.dat600k xaa554k xab 用-l进行切分： 1234567$split -l 5000 all.dat$wc -l *12801 all.dat5000 xaa5000 xab2081 xac25802 total 应用场景：有一个每天定时处理数据的任务，某一天突然发现数据量特别大，处理时间太长，这时可以把原数据分成多份，然后用多个线程同时处理数据，确保不会超出时间。 du &#x2F; df两个命令都可以用于查看文件空间的占用情况，df一般用于查看磁盘的使用情况，du一般用于查看文件夹的大小。 df -h 查看磁盘的使用情况，可以看到的信息如下。-h参数用于显示大小时把byte换算成K&#x2F;M&#x2F;G等可读单位。 123456789$ df -hFilesystem Size Used Avail Use% Mounted on/dev/sda1 7.9G 954M 6.6G 13% /tmpfs 16G 0 16G 0% /lib/init/rwudev 16G 120K 16G 1% /devtmpfs 16G 4.0K 16G 1% /dev/shm/dev/sda8 1.8T 32G 1.7T 2% /home/dev/sda7 7.9G 147M 7.8G 2% /tmp/dev/sda6 7.9G 563M 7.0G 8% /var du -sh查看当前目录的大小，du -sh *查看每个子目录的大小，-s参数表示显示总和，如果不带-s会显示所有子文件和文件夹的大小。 scp远程文件传输，secure copy。与ssh命令使用相同的验证方法并且提供相同的安全性。scp实质相当于利用SSH协议来传输数据的cp命令。 常见的两种用法： 本地文件拷贝到远程主机，scp /local/path user@remotehost:/home/path 远程主机文件拷贝到本地，scp user@remotehost:/home/path /local/path 当需要指定ssh的端口时，用-P port注意P需要大写，因为-p已经被rcp命令使用。如果需要拷贝文件夹，带上-r参数。-v和大多数其他命令一样，用来显示执行过程的详细信息。 12$ scp -P 1046 star-test.dat lc@10.120.104.56:/home/lc/star-test.dat 100% 2250 2.2KB/s 00:00 grep强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print。 常用参数： -c 只输出匹配的行数。 -v 排除[options]匹配的结果 -i 不区分大小写。 -l -L 只列出匹配&#x2F;不匹配的文件名。 -w 只匹配整个单词，而不是字符串的一部分（如匹配”magic”，而不匹配”magical”）。 -n 结果中显示行号。 grep命令可以通过管道符号叠加使用，如： 12345678$ cat a.txt12123$ cat a.txt|grep -n [0-9]|grep -v 12:24:3 comm用于对两个有序的文件进行比较。 这个命令的使用有个前提，就是比较的两个文件必须是有序的不带参数时，的效果如下（cat用来显示文件内容）： 123456789101112131415161718$ cat a.txt011223$ cat b.txt121320$ comm a.txt b.txt01 12 132 203 输出结果有三列：第一列只在a中出现，第二列只在b中出现，第三列在a，b中都出现。因此comm有三个对应的可选参数： -1 不显示只在第一个文件中出现过的列，也就是不显示第一列。 -2 不显示只在第二个文件中出现过的列，也就是不显示第二列。 -3 不显示两个文件中都出现过的列，也就是不显示第三列。 应用场景：每天通过数据挖掘得到一批符合条件的用户，需要对他们进行某个操作，并且每个用户只能被操作一次，而每天提供的用户没有经过去重，那么每天操作前需要对之前已经操作过的用户进行去重。也就是例如文件done.txt是已经操作过的用户，new.txt是新拿到的用户，那么通过comm -13 done.txt new.txt &gt; todo.txt就可以得到我们想要的结果。 sort将文件中的每一个行作为一个单元进行比较。 默认不带参数的比较原则是从首字符向后，依次按字符的ASCII码进行比较，结果按升序输出。效果： 12345678910$ cat a.txt12212$ sort a.txt11222 常用的参数： -u 对结果进行去重。 -r 按降序输出结果。 -o 将结果存入指定的文件，由于sort默认把结果输出到标准输出，所以通常需要用&gt;符号来把结果重定向输出到文件中。但是当你想把结果放到被比较的原文件中时，用重定向会把原文件清空。这是就需要通过-o来指定输出结果到原文件。 -n 按照数值进行排序。 -t -k 这两个一般同时使用，-t用来指定分隔符，-k表示分割后用来进行比较的列。 -d 只处理英文字母、数字、空格字符，忽略其他字符。 -f 忽略大小写。 -m 将几个排序好的文件进行合并。 应用场景：上面comm命令的场景中，新得到的文件应该先进行排序sort -u new.txt -o new.txt，操作完后应该把新操作的用户合并到已操作的用户中sort -m -u done.txt new.txt -o done.txt。 cut切割字符串，用于文件时，以每一行为单元处理。 cut的使用比较简单，常用的只有两个参数： -d 指定分隔符，不指定时默认以制表符\\t作为分隔符，通常与-f一起使用。 -f 目标被分隔成几段以后，用-f表示取出其中的某几段。 -c -b 分别表示已字符&#x2F;字节为单位，取出指定的区间。 示例： 1234$ echo &quot;1,2,3,4,5&quot;|cut -d , -f 2-42,3,4$ echo &quot;1,2,3,4,5&quot;|cut -c 2-4,2, sed非交互式的编辑器，不会修改文件，把结果输出的屏幕。 sed的用法比较多，也比较复杂，下面只列举一下常用的用法： 123456$ cat a.txt01234 1.删除文件中的2~4行 123$ sed &#x27;2,4d&#x27; a.txt04 2.取出文件中的1~3行 1234$ sed -n &#x27;1,3p&#x27; a.txt012 3.删除从包含1的行到第一个包含3的行 123$ sed &#x27;/1/,/3/d&#x27; a.txt04 注意：sed本身不会改变文件 paste把文件以列的方式，进行合并。 两个常用参数： -d 指定合并时的间隔符，不指定则默认为制表符\\t。 -s 将文件的列转换为行。 示例： 123456789101112131415$ cat a.txt12$ cat b.txt34$ paste -d &#x27;,&#x27; a.txt b.txt1,3,42,$ paste -s b.txt3 4$ paste -s -d &#x27;,&#x27; b.txt3,4 持续更新…","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"Shell","slug":"Shell","permalink":"https://lchml.com/tags/Shell/"}]},{"title":"打开脑洞","slug":"aboutmovie","date":"2014-12-03T16:00:00.000Z","updated":"2022-05-12T06:04:15.869Z","comments":true,"path":"life/aboutmovie/","link":"","permalink":"https://lchml.com/life/aboutmovie/","excerpt":"最近看得电影","text":"最近看得电影 最近看了很多同一个类型的电影 Predestination中文名叫《前目的地》 Coherence《相干性》还有另一个名称，彗星来的那一夜。 Interstellar地球人都知道的《星际穿越》 加上以前看过的一些同类型电影 The Man from Earth《这个男人来自地球》 Triangle《恐怖游轮》 Contact《超时空接触》 Moon《月球》 Twelve Monkeys《十二猴子》 The Thirteenth Floor《十三度凶间》 Dark City《移魂都市》 The Machinist《机械师》 Black Mirror《黑镜》 还有一些一时之间也想不起来了，这些电影看完的时候，往往脑洞会被炸得无比大，心中的对起想象力的赞叹让我很有冲动写篇影评骂一骂来展示自己的biger，但影评没写出来，却发现经常会想起电影里的各种情景，不得不说，他们拍的确实有那么一点深刻了。 未来是现世一步步发展过去的。记得之前有一个问题：如果用电流刺激你的大脑，让你得到与真实环境刺激一样的神经感受，那么这到底算什么呢。我相信，总有一天技术会达到，并且现在离那也不遥远，互联网就在做这样的事情，你说这是真的呢还是真的呢？ 你看到了黑点却说没有黑点","categories":[{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"LC","slug":"LC","permalink":"https://lchml.com/tags/LC/"},{"name":"电影","slug":"电影","permalink":"https://lchml.com/tags/%E7%94%B5%E5%BD%B1/"}]},{"title":"从风险角度看SaaS研发工作","slug":"dev-risk","date":"1999-12-31T16:00:00.000Z","updated":"2023-08-30T11:25:11.678Z","comments":true,"path":"technology/dev-risk/","link":"","permalink":"https://lchml.com/technology/dev-risk/","excerpt":"首先我们承认一个基本事实：系统不可能 100%可靠。人无完人，由人创造的系统同样也不可能是完美的系统。因此我们在研发工作中对风险管理的目标从来不是100%可靠，而是在特定环境下，在特定时间段内，控制某种损失发生的可能性。","text":"首先我们承认一个基本事实：系统不可能 100%可靠。人无完人，由人创造的系统同样也不可能是完美的系统。因此我们在研发工作中对风险管理的目标从来不是100%可靠，而是在特定环境下，在特定时间段内，控制某种损失发生的可能性。 一个项目或者产品的研发工作不可避免的存在风险。比如公司调整、市场变化、突发政策、人员变动、依赖延期、系统BUG、技术难题等等。作为系统架构师或研发管理者，我们需要对项目的各种风险做到心中有数，设计好应对措施并跟踪风险情况。同时，风险的影响面和发生概率随着项目的阶段和环境的变化都可能会发生变化，需要及时进行重新分析和评估。 研发工作中的风险，从产生来源可以分为技术风险和业务风险，其中技术风险主要是指由技术直接或间接产生的风险，包括可行性风险、系统风险、操作风险等。务风险主要是指项目能否正常进行以及是否能带来预期价值的风险，包括市场风险、成本风险、政策风险、组织风险等。从影响程度和发生概率看，又可以分为高风险、低风险、大概率风险、小概率风险。 当项目或产品处于不同的发展阶段时，对风险的管理也需要有不同的思路。当一个产品处于发展初期，那么他的业务风险通常会远高于技术风险，因为在发展初期，最大的风险通常是业务的生存问题和价值问题，是否能通过立项，是否能为客户提供价值，是否会被组织调整，是否能在市场上站稳脚跟。而此时技术视角下，系统稳定性、功能BUG等风险通常造成的损失可控，影响范围小，因此我们应该更注重研发效率和适应快速的变化。 对于成熟期的产品，通常已经有大量的客户，有一定的市场占有率，业务风险相对已经比较小。这时更多的是技术风险，因为作为成熟期的产品，一定是有存量客户，有对客户非常重要的服务场景，甚至直接是客户关键生产链路中的一环。一旦出现功能BUG、预期不符、系统不可用等情况，都会影响客户，甚至造成巨大资损，直接影响客户留存和品牌声誉。 想要管理风险的前提是要能识别风险，识别风险有很多方法，有人靠经验，有人靠数据，也有人靠直觉，还有燃尽图、FEMA、交通灯等各种方法论，无论哪种方式，前提一定是要有大量的信息输入，这就要求我们在做研发工作时，要掌握尽可能全面的信息。例如在研发工作中有大量的风险都是围绕着变更引起的，如产品需求、技术优化、代码重构、架构调整、机房迁移、人员调整等。因此只要涉及到变更，就一定要想到风险，并基于此去挖掘更多相关的信息。 识别到风险的下一步是根据影响大小，紧急程度等结果采取相应的应对措施，在研发工作中，常用的风险应对措施有回避、减轻、接受、转移等。 回避风险 风险回避策略是指当项目风险潜在威胁发生可能性太大，不利后果也太严重，又无其它风险管理策略可用时，主动放弃项目或改变项目目标与行动方案，从而规避风险的一种风险管理策略。相信大家都有过砍需求的经历，例如当我们评估某个需求变更或技术优化会带来极大风险（可能是进度、成本、稳定性等各种风险），而只有有限的收益时，我们可以选择放弃此次变更，这就是一种回避风险的方式。 减轻风险 减轻风险策略是通过缓和或预知等手段来减轻风险，降低风险发生的可能性或减缓风险带来的不利后果，以达到风险减少的目的。这是一种积极的风险处理手段。也研发流程中是最常用的方式，如测试就是为了减轻系统变更的风险，应急预案演练、全链路压测都是为了减轻系统稳定性风险，技术方案评审是为了减轻技术架构变更和腐烂带来的风险，灰度发布是为了减轻服务发布带来的风险，每日站会通是为了减轻进度风险。 接受风险 接受风险策略是指有意识地选择自己承担风险后果的策略。当采取其它风险规避方法的费用超过风险事件造成的损失时，可采取接受风险的方法。例如当我们的客户有突发大流量时，我们通常会选择限流或降级的措施，而不是日常冗余大量空闲资源。例如当确认有进度风险时，采用赶工的方式来解决。 转移风险 转移风险策略是指将风险转移至其他人或其它组织，其目的是借用合同或协议，在风险事故一旦发生时将损失的一部分转移到有能力承受或控制项目风险的个人或组织。如项目BPO，或采购第三方系统，签订背靠背合约。 风险处置之后，还需要对风险进行跟踪和复盘。对于高风险事件，需要保证所有风险都有相应的措施。对于低风险事件，可以通过系统化流程化的方式进行跟踪。同时在风险的复盘中，我们要积极探究风险产生的结构化因素，如分支模型有问题、发布流程有问题等，并对相应的问题改进优化，降低后续风险发生的可能性。 商业在本质上是一种冒险的尝试。无论在经营还是研发中，我们必须能够识别和平衡风险与回报。比如，研发新功能或者做系统重构，显然都会有风险，但也应该有足够的回报。彼得德鲁克说：“没有尽善尽美的战略决策。人们总要付出代价。对相互矛盾的目标、相互矛盾的观点及相互矛盾的重点，人们总要进行平衡。最佳的战略决策只能是近似合理的，而且总是带有风险的。”。风险是业务的成功的阶梯，对风险的理解和管理是研发工作的重点内容。我相信没有缓解的风险越多，出现重大问题的可能性就越大。将风险视为一种可能性，而非威胁，积极面对风险才能解决风险。","categories":[{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"},{"name":"研发","slug":"研发","permalink":"https://lchml.com/tags/%E7%A0%94%E5%8F%91/"}]}],"categories":[{"name":"book","slug":"book","permalink":"https://lchml.com/categories/book/"},{"name":"technology","slug":"technology","permalink":"https://lchml.com/categories/technology/"},{"name":"life","slug":"life","permalink":"https://lchml.com/categories/life/"}],"tags":[{"name":"李城","slug":"李城","permalink":"https://lchml.com/tags/%E6%9D%8E%E5%9F%8E/"},{"name":"政治","slug":"政治","permalink":"https://lchml.com/tags/%E6%94%BF%E6%B2%BB/"},{"name":"文学","slug":"文学","permalink":"https://lchml.com/tags/%E6%96%87%E5%AD%A6/"},{"name":"科幻","slug":"科幻","permalink":"https://lchml.com/tags/%E7%A7%91%E5%B9%BB/"},{"name":"经济","slug":"经济","permalink":"https://lchml.com/tags/%E7%BB%8F%E6%B5%8E/"},{"name":"历史","slug":"历史","permalink":"https://lchml.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"传记","slug":"传记","permalink":"https://lchml.com/tags/%E4%BC%A0%E8%AE%B0/"},{"name":"心理学","slug":"心理学","permalink":"https://lchml.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"文化","slug":"文化","permalink":"https://lchml.com/tags/%E6%96%87%E5%8C%96/"},{"name":"心学","slug":"心学","permalink":"https://lchml.com/tags/%E5%BF%83%E5%AD%A6/"},{"name":"书单","slug":"书单","permalink":"https://lchml.com/tags/%E4%B9%A6%E5%8D%95/"},{"name":"管理","slug":"管理","permalink":"https://lchml.com/tags/%E7%AE%A1%E7%90%86/"},{"name":"企业","slug":"企业","permalink":"https://lchml.com/tags/%E4%BC%81%E4%B8%9A/"},{"name":"经营","slug":"经营","permalink":"https://lchml.com/tags/%E7%BB%8F%E8%90%A5/"},{"name":"领导力","slug":"领导力","permalink":"https://lchml.com/tags/%E9%A2%86%E5%AF%BC%E5%8A%9B/"},{"name":"销售","slug":"销售","permalink":"https://lchml.com/tags/%E9%94%80%E5%94%AE/"},{"name":"工具","slug":"工具","permalink":"https://lchml.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"考古","slug":"考古","permalink":"https://lchml.com/tags/%E8%80%83%E5%8F%A4/"},{"name":"中东","slug":"中东","permalink":"https://lchml.com/tags/%E4%B8%AD%E4%B8%9C/"},{"name":"国际","slug":"国际","permalink":"https://lchml.com/tags/%E5%9B%BD%E9%99%85/"},{"name":"数据库","slug":"数据库","permalink":"https://lchml.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"服务器","slug":"服务器","permalink":"https://lchml.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"大数据","slug":"大数据","permalink":"https://lchml.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"诗词","slug":"诗词","permalink":"https://lchml.com/tags/%E8%AF%97%E8%AF%8D/"},{"name":"人文","slug":"人文","permalink":"https://lchml.com/tags/%E4%BA%BA%E6%96%87/"},{"name":"中国史","slug":"中国史","permalink":"https://lchml.com/tags/%E4%B8%AD%E5%9B%BD%E5%8F%B2/"},{"name":"散文","slug":"散文","permalink":"https://lchml.com/tags/%E6%95%A3%E6%96%87/"},{"name":"架构","slug":"架构","permalink":"https://lchml.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"SaaS","slug":"SaaS","permalink":"https://lchml.com/tags/SaaS/"},{"name":"分布式","slug":"分布式","permalink":"https://lchml.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"职场","slug":"职场","permalink":"https://lchml.com/tags/%E8%81%8C%E5%9C%BA/"},{"name":"建筑","slug":"建筑","permalink":"https://lchml.com/tags/%E5%BB%BA%E7%AD%91/"},{"name":"心理","slug":"心理","permalink":"https://lchml.com/tags/%E5%BF%83%E7%90%86/"},{"name":"宗教","slug":"宗教","permalink":"https://lchml.com/tags/%E5%AE%97%E6%95%99/"},{"name":"演讲","slug":"演讲","permalink":"https://lchml.com/tags/%E6%BC%94%E8%AE%B2/"},{"name":"PPT","slug":"PPT","permalink":"https://lchml.com/tags/PPT/"},{"name":"哲学","slug":"哲学","permalink":"https://lchml.com/tags/%E5%93%B2%E5%AD%A6/"},{"name":"法律","slug":"法律","permalink":"https://lchml.com/tags/%E6%B3%95%E5%BE%8B/"},{"name":"中国哲学","slug":"中国哲学","permalink":"https://lchml.com/tags/%E4%B8%AD%E5%9B%BD%E5%93%B2%E5%AD%A6/"},{"name":"哲学史","slug":"哲学史","permalink":"https://lchml.com/tags/%E5%93%B2%E5%AD%A6%E5%8F%B2/"},{"name":"中国通史","slug":"中国通史","permalink":"https://lchml.com/tags/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2/"},{"name":"LC","slug":"LC","permalink":"https://lchml.com/tags/LC/"},{"name":"python","slug":"python","permalink":"https://lchml.com/tags/python/"},{"name":"Java","slug":"Java","permalink":"https://lchml.com/tags/Java/"},{"name":"httpclient","slug":"httpclient","permalink":"https://lchml.com/tags/httpclient/"},{"name":"jvm","slug":"jvm","permalink":"https://lchml.com/tags/jvm/"},{"name":"coredump","slug":"coredump","permalink":"https://lchml.com/tags/coredump/"},{"name":"crash","slug":"crash","permalink":"https://lchml.com/tags/crash/"},{"name":"消息队列","slug":"消息队列","permalink":"https://lchml.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"MQ","slug":"MQ","permalink":"https://lchml.com/tags/MQ/"},{"name":"Kafka","slug":"Kafka","permalink":"https://lchml.com/tags/Kafka/"},{"name":"延时消息","slug":"延时消息","permalink":"https://lchml.com/tags/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF/"},{"name":"日志","slug":"日志","permalink":"https://lchml.com/tags/%E6%97%A5%E5%BF%97/"},{"name":"游记","slug":"游记","permalink":"https://lchml.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"新西兰","slug":"新西兰","permalink":"https://lchml.com/tags/%E6%96%B0%E8%A5%BF%E5%85%B0/"},{"name":"自驾","slug":"自驾","permalink":"https://lchml.com/tags/%E8%87%AA%E9%A9%BE/"},{"name":"面试","slug":"面试","permalink":"https://lchml.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java基础","slug":"Java基础","permalink":"https://lchml.com/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"bimaconf","slug":"bimaconf","permalink":"https://lchml.com/tags/bimaconf/"},{"name":"配置中心","slug":"配置中心","permalink":"https://lchml.com/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"name":"Grafana","slug":"Grafana","permalink":"https://lchml.com/tags/Grafana/"},{"name":"InfluxDB","slug":"InfluxDB","permalink":"https://lchml.com/tags/InfluxDB/"},{"name":"数据大盘","slug":"数据大盘","permalink":"https://lchml.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%A7%E7%9B%98/"},{"name":"SSL","slug":"SSL","permalink":"https://lchml.com/tags/SSL/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://lchml.com/tags/HTTPS/"},{"name":"CloudFlare","slug":"CloudFlare","permalink":"https://lchml.com/tags/CloudFlare/"},{"name":"Druid","slug":"Druid","permalink":"https://lchml.com/tags/Druid/"},{"name":"zipkin","slug":"zipkin","permalink":"https://lchml.com/tags/zipkin/"},{"name":"sleuth","slug":"sleuth","permalink":"https://lchml.com/tags/sleuth/"},{"name":"springboot","slug":"springboot","permalink":"https://lchml.com/tags/springboot/"},{"name":"dubbo","slug":"dubbo","permalink":"https://lchml.com/tags/dubbo/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://lchml.com/tags/elasticsearch/"},{"name":"分布式追踪","slug":"分布式追踪","permalink":"https://lchml.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%BD%E8%B8%AA/"},{"name":"Hirika","slug":"Hirika","permalink":"https://lchml.com/tags/Hirika/"},{"name":"java","slug":"java","permalink":"https://lchml.com/tags/java/"},{"name":"碎片化","slug":"碎片化","permalink":"https://lchml.com/tags/%E7%A2%8E%E7%89%87%E5%8C%96/"},{"name":"深度思考","slug":"深度思考","permalink":"https://lchml.com/tags/%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83/"},{"name":"玉皇山","slug":"玉皇山","permalink":"https://lchml.com/tags/%E7%8E%89%E7%9A%87%E5%B1%B1/"},{"name":"凤凰山","slug":"凤凰山","permalink":"https://lchml.com/tags/%E5%87%A4%E5%87%B0%E5%B1%B1/"},{"name":"八卦田","slug":"八卦田","permalink":"https://lchml.com/tags/%E5%85%AB%E5%8D%A6%E7%94%B0/"},{"name":"万松书院","slug":"万松书院","permalink":"https://lchml.com/tags/%E4%B8%87%E6%9D%BE%E4%B9%A6%E9%99%A2/"},{"name":"何美玲","slug":"何美玲","permalink":"https://lchml.com/tags/%E4%BD%95%E7%BE%8E%E7%8E%B2/"},{"name":"泰国","slug":"泰国","permalink":"https://lchml.com/tags/%E6%B3%B0%E5%9B%BD/"},{"name":"清迈","slug":"清迈","permalink":"https://lchml.com/tags/%E6%B8%85%E8%BF%88/"},{"name":"曼谷","slug":"曼谷","permalink":"https://lchml.com/tags/%E6%9B%BC%E8%B0%B7/"},{"name":"芭提雅","slug":"芭提雅","permalink":"https://lchml.com/tags/%E8%8A%AD%E6%8F%90%E9%9B%85/"},{"name":"Webcat","slug":"Webcat","permalink":"https://lchml.com/tags/Webcat/"},{"name":"HTTP","slug":"HTTP","permalink":"https://lchml.com/tags/HTTP/"},{"name":"websocket","slug":"websocket","permalink":"https://lchml.com/tags/websocket/"},{"name":"JVM","slug":"JVM","permalink":"https://lchml.com/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://lchml.com/tags/GC/"},{"name":"GRPC","slug":"GRPC","permalink":"https://lchml.com/tags/GRPC/"},{"name":"Hexo","slug":"Hexo","permalink":"https://lchml.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://lchml.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"三亚","slug":"三亚","permalink":"https://lchml.com/tags/%E4%B8%89%E4%BA%9A/"},{"name":"ShadowSocks","slug":"ShadowSocks","permalink":"https://lchml.com/tags/ShadowSocks/"},{"name":"翻墙","slug":"翻墙","permalink":"https://lchml.com/tags/%E7%BF%BB%E5%A2%99/"},{"name":"NAS","slug":"NAS","permalink":"https://lchml.com/tags/NAS/"},{"name":"随想","slug":"随想","permalink":"https://lchml.com/tags/%E9%9A%8F%E6%83%B3/"},{"name":"服务发现","slug":"服务发现","permalink":"https://lchml.com/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"},{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://lchml.com/tags/Zookeeper/"},{"name":"横店","slug":"横店","permalink":"https://lchml.com/tags/%E6%A8%AA%E5%BA%97/"},{"name":"Eureka","slug":"Eureka","permalink":"https://lchml.com/tags/Eureka/"},{"name":"日本","slug":"日本","permalink":"https://lchml.com/tags/%E6%97%A5%E6%9C%AC/"},{"name":"disconf","slug":"disconf","permalink":"https://lchml.com/tags/disconf/"},{"name":"netty","slug":"netty","permalink":"https://lchml.com/tags/netty/"},{"name":"TCP","slug":"TCP","permalink":"https://lchml.com/tags/TCP/"},{"name":"svn","slug":"svn","permalink":"https://lchml.com/tags/svn/"},{"name":"Git","slug":"Git","permalink":"https://lchml.com/tags/Git/"},{"name":"电影","slug":"电影","permalink":"https://lchml.com/tags/%E7%94%B5%E5%BD%B1/"},{"name":"moviehell","slug":"moviehell","permalink":"https://lchml.com/tags/moviehell/"},{"name":"转载","slug":"转载","permalink":"https://lchml.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"黄山","slug":"黄山","permalink":"https://lchml.com/tags/%E9%BB%84%E5%B1%B1/"},{"name":"巴厘岛","slug":"巴厘岛","permalink":"https://lchml.com/tags/%E5%B7%B4%E5%8E%98%E5%B2%9B/"},{"name":"香港","slug":"香港","permalink":"https://lchml.com/tags/%E9%A6%99%E6%B8%AF/"},{"name":"BloomFilter","slug":"BloomFilter","permalink":"https://lchml.com/tags/BloomFilter/"},{"name":"数据结构","slug":"数据结构","permalink":"https://lchml.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"redis","slug":"redis","permalink":"https://lchml.com/tags/redis/"},{"name":"nutcracker","slug":"nutcracker","permalink":"https://lchml.com/tags/nutcracker/"},{"name":"成都","slug":"成都","permalink":"https://lchml.com/tags/%E6%88%90%E9%83%BD/"},{"name":"重庆","slug":"重庆","permalink":"https://lchml.com/tags/%E9%87%8D%E5%BA%86/"},{"name":"Guava","slug":"Guava","permalink":"https://lchml.com/tags/Guava/"},{"name":"北高峰","slug":"北高峰","permalink":"https://lchml.com/tags/%E5%8C%97%E9%AB%98%E5%B3%B0/"},{"name":"西湖","slug":"西湖","permalink":"https://lchml.com/tags/%E8%A5%BF%E6%B9%96/"},{"name":"kindle","slug":"kindle","permalink":"https://lchml.com/tags/kindle/"},{"name":"IPDB","slug":"IPDB","permalink":"https://lchml.com/tags/IPDB/"},{"name":"杏梅尖","slug":"杏梅尖","permalink":"https://lchml.com/tags/%E6%9D%8F%E6%A2%85%E5%B0%96/"},{"name":"物理学","slug":"物理学","permalink":"https://lchml.com/tags/%E7%89%A9%E7%90%86%E5%AD%A6/"},{"name":"相对论","slug":"相对论","permalink":"https://lchml.com/tags/%E7%9B%B8%E5%AF%B9%E8%AE%BA/"},{"name":"Shell","slug":"Shell","permalink":"https://lchml.com/tags/Shell/"},{"name":"研发","slug":"研发","permalink":"https://lchml.com/tags/%E7%A0%94%E5%8F%91/"}]}